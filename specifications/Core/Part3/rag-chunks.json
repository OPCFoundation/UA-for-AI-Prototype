{
  "Title": "Part 3 - Address Space Model",
  "Chunks": [
    {
      "Id": "08dd0a16-c81d-4ea2-a18d-85756872b38e",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "1 Scope"
    },
    {
      "Id": "d8f484eb-711d-4b62-94c9-3e639e22b3d9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 1 Scope\n---\n",
      "Content": "This specification describes the OPC Unified Architecture (OPC UA) AddressSpace and its Objects. This Part is the OPC UA meta model on which OPC UA information models are based."
    },
    {
      "Id": "8ec0a0c7-6b24-4c91-b569-871d3d437749",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "2 Normative references"
    },
    {
      "Id": "dc256c47-5b79-4580-a41d-708dcf43721f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 2 Normative references\n---\n",
      "Content": "The following documents, in whole or in part, are normatively referenced in this document and are indispensable for its application. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments and errata) applies.\nOPC 10000-1, OPC Unified Architecture - Part 1: Overview and Concepts\n[http://www.opcfoundation.org/UA/Part1/](http://www.opcfoundation.org/UA/Part1/)\nOPC 10000-4, OPC Unified Architecture - Part 4: Services\n[http://www.opcfoundation.org/UA/Part4/](http://www.opcfoundation.org/UA/Part4/)\nOPC 10000-5, OPC Unified Architecture - Part 5: Information Model\n[http://www.opcfoundation.org/UA/Part5/](http://www.opcfoundation.org/UA/Part5/)\nOPC 10000-6, OPC Unified Architecture - Part 6: Mappings\n[http://www.opcfoundation.org/UA/Part6/](http://www.opcfoundation.org/UA/Part6/)\nOPC 10000-8, OPC Unified Architecture - Part 8: Data Access\n[http://www.opcfoundation.org/UA/Part8/](http://www.opcfoundation.org/UA/Part8/)\nOPC 10000-11, OPC Unified Architecture - Part 11: Historical Access\n[http://www.opcfoundation.org/UA/Part11/](http://www.opcfoundation.org/UA/Part11/)\nOPC 10000-18, OPC Unified Architecture - Part 18: Role-Based Security"
    },
    {
      "Id": "ddeb7fa6-65aa-46ca-a38f-2d48883768bb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 2 Normative references\n---\n",
      "Content": "[http://www.opcfoundation.org/UA/Part18/](http://www.opcfoundation.org/UA/Part18/)\nOPC 10000-21, OPC Unified Architecture - Part 21: Device Onboarding\n[http://www.opcfoundation.org/UA/Part21/](http://www.opcfoundation.org/UA/Part21/)\nISO 639 (all parts), Codes for the representation of names of languages\n[https://www.iso.org/iso-639-language-codes.html](https://www.iso.org/iso-639-language-codes.html)\nISO 3166 (all parts), Codes for the representation of names of countries and their subdivisions\n[https://www.iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html)\nISO/IEC/IEEE 60559:2020, Information technology - Microprocessor Systems - Floating-Point arithmetic\nhttps://www.iso.org/standard/80985.html\n\u0022https://www.iso.org/standard/80985.html\nRFC 5646, Tags for Identifying Languages\n[https://datatracker.ietf.org/doc/html/rfc5646](https://datatracker.ietf.org/doc/html/rfc5646)\nISO 8601-1:2019, Date and time - Representations for information interchange - Part 1: Basic\n[https://www.iso.org/standard/70907.html](https://www.iso.org/standard/70907.html)\nUnicode Annex15, Unicode Standard Annex #15: Unicode Normalization Forms\n[http://www.unicode.org/reports/tr15/](http://www.unicode.org/reports/tr15/)\nW3C XML Schema Definition Language (XSD) Part 2, DataTypes"
    },
    {
      "Id": "ffd15d85-96c8-4f54-b120-e1833eecbd88",
      "Header": "Document: Part 3 - Address Space Model\nSection: 2 Normative references\n---\n",
      "Content": "[http://www.w3.org/TR/xmlschema-2/](http://www.w3.org/TR/xmlschema-2/)\nISO 4217, Codes for the representation of currencies\n[https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)\nRFC 3986, Uniform Resource Identifier (URI): Generic Syntax:\n[https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)\nRFC 4151, The \u0027tag\u0027 URI Scheme\n[https://datatracker.ietf.org/doc/html/rfc4151](https://datatracker.ietf.org/doc/html/rfc4151)\nUnicode C0 Controls and Basic Latin:\n[https://www.unicode.org/charts/PDF/U0000.pdf](https://www.unicode.org/charts/PDF/U0000.pdf)\nUnicode C1 Controls and Latin-1 Supplement:\n[https://www.unicode.org/charts/PDF/U0080.pdf](https://www.unicode.org/charts/PDF/U0080.pdf)[t](t)\nUnicode Property List:\n[https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt](https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt)"
    },
    {
      "Id": "852ee19f-7119-45c1-9276-7d83e82c5e72",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "3 Terms, definitions, abbreviations and conventions"
    },
    {
      "Id": "17b99e00-74ef-42c0-bf44-ee5af002a3f2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3 Terms, definitions, abbreviations and conventions\n---\n",
      "Content": "3.1 Terms and definitions"
    },
    {
      "Id": "aa8bc453-1903-4c94-ad88-b1fd16fface8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "For the purposes of this document, the terms and definitions given in[OPC 10000-1](/\u00A7UAPart1) and the following apply.\n3.1.1 AddIn"
    },
    {
      "Id": "e63ac616-fb90-44fb-b6c1-cb8285db9f3a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.1 AddIn\n---\n",
      "Content": "a widely applicable feature or feature-set represented by an ObjectType that will be applied using aggregation"
    },
    {
      "Id": "09807f4f-0496-4aac-8d0c-5b93d63dbd5a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.2 DataType"
    },
    {
      "Id": "f80ed70a-2006-4f73-bbbc-91402a3a6aaa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.2 DataType\n---\n",
      "Content": "instance of a DataType Node that is used together with the ValueRank Attribute to define the data type of a Variable"
    },
    {
      "Id": "cceba0e3-7d51-4fc2-9c57-a944389b64b5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.3 Built-in DataType"
    },
    {
      "Id": "fa03af42-0fd5-4a21-adc2-d3f9cf7c1e3b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.3 Built-in DataType\n---\n",
      "Content": "a fundamental building block DataType defined by this standard\nNote 1 to entry: The list of Built-in DataTypes and their encodings are defined in[OPC 10000-6](/\u00A7UAPart6)."
    },
    {
      "Id": "22a6ec37-3227-4cbf-9882-a89007a71e4c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.4 Simple DataType"
    },
    {
      "Id": "5c74fba3-a90b-4d5c-8050-fb211bbabf55",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.4 Simple DataType\n---\n",
      "Content": "a DataType which is not a Structure, Enumeration or OptionSet\nNote 1 to entry: See[5.8.2](/\u00A7_Ref209454732) for additional information."
    },
    {
      "Id": "8b176bdf-c24d-4f64-a0b8-7074a0c2ea53",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.5 DataTypeId"
    },
    {
      "Id": "56f47813-5b7a-42b1-89d6-4f51bc7e6270",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.5 DataTypeId\n---\n",
      "Content": "NodeId of a DataType Node"
    },
    {
      "Id": "b6136b1e-0418-421e-a5ef-6ec64588dc92",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.6 DataTypeRefinement"
    },
    {
      "Id": "f4930eac-2a79-4038-adc9-41b3bc908e55",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.6 DataTypeRefinement\n---\n",
      "Content": "refinement of a Structured DataType restricting the usage of fields and adding meta data to fields"
    },
    {
      "Id": "63596666-e400-4ac0-ad92-7e6ea443739d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.7 DataVariable"
    },
    {
      "Id": "1eea4384-5081-4858-b792-215e5a34a5c8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.7 DataVariable\n---\n",
      "Content": "Variables that represent values of Objects, either directly or indirectly for complex Variables, where the Variables are always the TargetNode of a HasComponent Reference"
    },
    {
      "Id": "f80222bb-54f5-48ae-a627-5535eb4222ed",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.8 EventType"
    },
    {
      "Id": "062ba500-398c-4095-9fea-23235fd8125d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.8 EventType\n---\n",
      "Content": "ObjectType Node that represents the type definition of an Event"
    },
    {
      "Id": "574c30e8-f047-4070-b5ed-1a4ce0027065",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.9 Hierarchical Reference"
    },
    {
      "Id": "f678cfd5-a670-4060-9f16-9fe6e2d172f8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.9 Hierarchical Reference\n---\n",
      "Content": "Reference that is used to construct hierarchies in the AddressSpace\nNote 1 to entry: All hierarchical ReferenceTypes are derived from HierarchicalReferences."
    },
    {
      "Id": "19522e54-3450-4612-8e99-242cd644a527",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.10 InstanceDeclaration"
    },
    {
      "Id": "01449fa4-11e3-474f-9e53-0bdf2ea89efa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.10 InstanceDeclaration\n---\n",
      "Content": "Node that is used by a complex TypeDefinitionNode to expose its complex structure\nNote 1 to entry: This is an instance used by a type definition."
    },
    {
      "Id": "ac7d9e5f-0e9a-4fb7-93b4-90019b09abe3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.11 Interface"
    },
    {
      "Id": "827c337a-e9a0-4183-a0eb-006e332f862d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.11 Interface\n---\n",
      "Content": "an abstract ObjectType used to specify a feature or feature-set that shall be implemented by the Object or ObjectType where it is applied to"
    },
    {
      "Id": "7d84f6fa-5c72-4238-a57e-2d6e2fd7b267",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.12 ModellingRule"
    },
    {
      "Id": "f5dff133-3df1-4a44-bdc1-d589a9ae8801",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.12 ModellingRule\n---\n",
      "Content": "metadata of an InstanceDeclaration that defines how the InstanceDeclaration will be used for instantiation and also defines subtyping rules for an InstanceDeclaration"
    },
    {
      "Id": "3d810ff7-4c43-472e-8dad-e32260ff2d7a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.13 Property"
    },
    {
      "Id": "91deacda-16f5-4406-b88d-3eac0377a9d2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.13 Property\n---\n",
      "Content": "Variables that are the TargetNode for a HasProperty Reference\nNote 1 to entry: Properties describe the characteristics of a Node."
    },
    {
      "Id": "bfdc6522-2107-45b6-8515-844167b0f9ae",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.14 SourceNode"
    },
    {
      "Id": "221fc1ec-34ae-411b-8503-889fcd09fee9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.14 SourceNode\n---\n",
      "Content": "Node having a Reference to another Node\nEXAMPLE: In the Reference\u0022A contains B\u0022, \u0022A\u0022 is the SourceNode."
    },
    {
      "Id": "c07e1e87-6f6e-4143-be32-8477b077c892",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.15 SubtypeRestriction"
    },
    {
      "Id": "bb551ede-e8f9-4d5e-b0ce-974486cb5ca7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.15 SubtypeRestriction\n---\n",
      "Content": "restriction of the usage of a subtype of a DataType to only allow a subset of all its subtypes"
    },
    {
      "Id": "31043284-d3a4-4425-8d85-c955383b961f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.16 TargetNode"
    },
    {
      "Id": "9d3b7a95-0f03-4d74-a5b3-d59171775a40",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.16 TargetNode\n---\n",
      "Content": "Node that is referenced by another Node\nEXAMPLE: In the Reference\u0022A contains B\u0022, \u0022B\u0022 is the TargetNode."
    },
    {
      "Id": "719992fe-e54c-4b7f-a5b5-5af0537e0229",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.17 TypeDefinitionNode"
    },
    {
      "Id": "3a7d02fa-1867-4ceb-8c9b-c253bbe25497",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.17 TypeDefinitionNode\n---\n",
      "Content": "Node that is used to define the type of another Node\nNote 1 to entry: ObjectType and VariableType Nodes are TypeDefinitionNodes."
    },
    {
      "Id": "5be39782-a681-4333-b464-b59025fe2020",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.18 VariableType"
    },
    {
      "Id": "b5b7183e-a6bc-435d-af50-7d675521bb04",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.1.18 VariableType\n---\n",
      "Content": "Node that represents the type definition for a Variable"
    },
    {
      "Id": "817e7115-3a2b-45e4-835c-1b6b6c3adfde",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3 Terms, definitions, abbreviations and conventions\n---\n",
      "Content": "3.2 Abbreviated terms"
    },
    {
      "Id": "bdef69d7-1998-4d14-8cc6-f8c7f64d8c59",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.2 Abbreviated terms\n---\n",
      "Content": "UA Unified Architecture\nUML Unified Modeling Language\nURI Uniform Resource Identifier as defined by[RFC 3986](/\u00A7RFC3986)\nW3C World Wide Web Consortium\nXML Extensible Markup Language"
    },
    {
      "Id": "185bc775-8827-431b-8187-a2c879f74c02",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3 Terms, definitions, abbreviations and conventions\n---\n",
      "Content": "3.3 Conventions"
    },
    {
      "Id": "09cce99d-9a09-4ab9-a7fe-20b25be7d959",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3 Conventions\n---\n",
      "Content": "3.3.1 Conventions for AddressSpace figures"
    },
    {
      "Id": "85c4f364-c765-4b36-ac7c-14f86fa073ea",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.1 Conventions for AddressSpace figures\n---\n",
      "Content": "Nodes and their References to each other are illustrated using figures.[Figure 1](/\u00A7_Ref88631152) illustrates the conventions used in these figures."
    },
    {
      "Id": "b102a99c-4ea0-424b-bfd3-a91885c813f9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.1 Conventions for AddressSpace figures\nCaption: Figure 1 - AddressSpace Node diagrams\n---\n",
      "Content": "[image004.png](images/image004.png)"
    },
    {
      "Id": "a6b54ba2-0c75-4736-b369-178bacd72b28",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.1 Conventions for AddressSpace figures\n---\n",
      "Content": "Figure 1 - AddressSpace Node diagrams\nIn these figures, rectangles represent Nodes. Node rectangles may be titled with one or two lines of text. When two lines are used, the first text line in the rectangle identifies the NodeClass and the second line contains the BrowseName. When one line is used, it contains the BrowseName.\nNode rectangles may contain boxes used to define their Attributes and References. Specific names in these boxes identify specific Attributes and References.\nShaded rectangles with rounded corners and with arrows passing through them represent References. The arrow that passes through them begins at the SourceNode and points to the TargetNode. References may also be shown by drawing an arrow that starts at the Reference name in the \u0022References\u0022 box and ends at the TargetNode."
    },
    {
      "Id": "566e8e94-9898-475f-825f-1e19803f6911",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3 Conventions\n---\n",
      "Content": "3.3.2 Conventions for defining NodeClasses"
    },
    {
      "Id": "a7c25104-bd0f-494d-bc28-b2ae39ab106d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.2 Conventions for defining NodeClasses\n---\n",
      "Content": "Clause[4.10](/\u00A7_Ref115660529) defines AddressSpace NodeClasses.[Table 1](/\u00A7_Ref115688888) describes the format of the tables used to define NodeClasses.\nTable 1 - NodeClass Table Conventions"
    },
    {
      "Id": "c447e8ba-f3f6-4fab-b07a-b81d04736ae9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.2 Conventions for defining NodeClasses\nCaption: Table 1 - NodeClass Table Conventions\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\n\u0022Attribute name\u0022\n\u0022M\u0022 or \u0022O\u0022\nData type of the Attribute\nDefines the Attribute\n\n\n\n\nReferences\n\n\n\n\u0022Reference name\u0022\n\u00221\u0022, \u00220..1\u0022 or \u00220..*\u0022\nNot used\nDescribes the use of the Reference by the NodeClass\n\n\n\n\nStandard Properties\n\n\n\n\u0022Property name\u0022\n\u0022M\u0022 or \u0022O\u0022\nData type of the Property\nDefines the Property"
    },
    {
      "Id": "751ce682-ea3f-4f3a-91ee-638ba2f32087",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.2 Conventions for defining NodeClasses\n---\n",
      "Content": "The Name column contains the name of the Attribute, the name of the ReferenceType used to create a Reference or the name of a Property referenced using the HasProperty Reference.\nThe Use column defines whether the Attribute or Property is mandatory (M) or optional (O). When mandatory the Attribute or Property shall exist for every Node of the NodeClass. For References it specifies the cardinality. The following values may apply:\n\u00220..*\u0022 identifies that there are no restrictions, that is, the Reference does not have to be provided but there is no limitation how often it can be provided;\n\u00220..1\u0022 identifies that the Reference is provided at most once;\n\u00221\u0022 identifies that the Reference shall be provided exactly once.\nThe Data Type column contains the name of the DataType of the Attribute or Property. It is not used for References.\nThe Description column contains the description of the Attribute, the Reference or the Property.\nOnly this document may define Attributes. Thus, all Attributes of the NodeClass are specified in the table and may only be extended by other parts of this series of standards.\nThis document also defines ReferenceTypes, but ReferenceTypes may also be specified by a Server or by a client using the NodeManagement Services specified in[OPC 10000-4](/\u00A7UAPart4). Thus, the NodeClass tables contained in this document may contain the base ReferenceType called References identifying that any ReferenceType may be used for the NodeClass, including system specific ReferenceTypes. The NodeClass tables only specify how the NodeClasses can be used as SourceNodes of References, not as TargetNodes. If a NodeClass table allows a ReferenceType for its NodeClass to be used as SourceNode, this is also true for subtypes of the ReferenceType. However, subtypes of the"
    },
    {
      "Id": "3f0afd2d-e640-416f-a2c5-d23ae4ebb441",
      "Header": "Document: Part 3 - Address Space Model\nSection: 3.3.2 Conventions for defining NodeClasses\n---\n",
      "Content": "ReferenceType may restrict its SourceNodes.\nThis document defines Properties, but Properties can be defined by other standard organizations or vendors and Nodes can have Properties that are not standardised. Properties defined in this standard are defined by their name, which is mapped to the BrowseName having the NamespaceIndex 0, which represents the Namespace for OPC UA.\nThe Use column (optional or mandatory) does not imply a specific ModellingRule for Properties. Different Server implementations will choose to use ModellingRules appropriate for them."
    },
    {
      "Id": "f1e210bc-288d-499e-b05c-ed08bf228d87",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "4 AddressSpace concepts"
    },
    {
      "Id": "a8347a3f-989d-48d9-9059-b3ea5fb3041d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.1 Overview"
    },
    {
      "Id": "0aa826f7-2f31-451e-b9c9-f135d29b3fd8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.1 Overview\n---\n",
      "Content": "The remainder of Clause[4](/\u00A7_Ref387846225) defines the concepts of the AddressSpace. Clause[5](/\u00A7_Ref40785698) defines the NodeClasses of the AddressSpace representing the AddressSpace concepts. Clause[6](/\u00A7_Ref193170844) defines details on the type model for ObjectTypes and VariableTypes. Standard ReferenceTypes, DataTypes and EventTypes are defined in Clauses[7](/\u00A7_Ref192918160) to[8.61](/\u00A7_Ref138652042).\nThe informative[Annex A](/\u00A7_Ref138652200) describes general considerations on how to use the Address Space Model and the informative[Annex B](/\u00A7_Ref138652252) provides a UML Model of the Address Space Model. The normative[Annex C](/\u00A7_Ref182263562) defines a graphical notation for OPC UA data."
    },
    {
      "Id": "773de4d8-f531-4711-a263-f8df587ceab6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.2 URIs"
    },
    {
      "Id": "3cd80d47-fc14-4bb8-8c78-1d120716d603",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.2 URIs\n---\n",
      "Content": "URIs provide a syntax for constructing unique identifiers for resources that are used in several different contexts with this specification. Three use cases where implementors may need to construct their own URIs are:\nNamespaceUris used to identify an information model. NamespaceUris appear in UANodeSets(see[OPC 10000-6](/\u00A7UAPart6)) and in the NamespaceArray in a Server AddressSpace(see[OPC 10000-5](/\u00A7UAPart5));\nApplicationUris identify an OPC UA Application running on a particular Device and are assigned by the OwnerOperator or automatically created by the application software. An ApplicationInstance Certificate has the ApplicationUri in the subjectAltName(see[OPC 10000-6](/\u00A7UAPart6));\nProductInstanceUris identify a Device and are assigned by the Device Manufacturer(see[OPC 10000-21](/\u00A7UAPart21)). A DeviceIdentity Certificate has the ProductInstanceUri in the subjectAltName.\nThese URIs conform to[RFC 3986](/\u00A7RFC3986), however, this specification is very open ended. This clause provides recommendations for constructing these URIs.\nThe recommendations help ensure that URIs are unique by providing a scope controlled by a single authority (e.g. the domain name) and are human readable. Programs shall always treat URIs as opaque strings that can only be tested for equality with a case sensitive string comparison.\nURIs should be tag URIs ([RFC 4151](/\u00A7RFC4151)) or HTTP URLs ([RFC 3986](/\u00A7RFC3986)). URLs should only be used if they link to actual webpages."
    },
    {
      "Id": "bdbf6829-d803-407e-b330-7ef71d5b868a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.2 URIs\n---\n",
      "Content": "The scheme and domain name portions of the URI are in lower case. URIs may include query subcomponents and/or fragments.\nBelow are recommended URI formats for different use cases.\n1) NamespaceUri assigned by the creator of a InformationModel:\ntag:\u003Cauthority-domain-name\u003E,\u003Cyyyy-MM\u003E:UA:\u003Cmodel-short-name\u003E\nhttp://\u003Cauthority-domain-name\u003E/UA/\u003Cmodel-short-name\u003E\nWhere the \u003Cauthority-domain-name\u003E is a domain name owned by the authority creating the information model. In many cases this will be \u0027opcfoundation.org\u0027. \u003Cyyyy-MM\u003E is the year and month that the URI was created. The \u003Cmodel-short-name\u003E is a short identifier for the InformationModel.\n2) ApplicationUri assigned by the OwnerOperator\ntag:\u003Cdevice-domain-name\u003E,\u003Cyyyy-MM\u003E:\u003Cproduct\u003E\nhttp://\u003Cdevice-domain-name\u003E/\u003Cproduct\u003E\nWhere the \u003Cdevice-domain-name\u003E is a domain name or IP address for the Device that is unique within the OwnerOperator system. \u003Cyyyy-MM\u003E is the year and month that the URI was created. The \u003Cproduct\u003E is an identifier for the product which could contain many path segments.\n3) ApplicationUri automatically generated by product software:\ntag:\u003Cvendor-domain-name\u003E,\u003Cyyyy-MM\u003E:\u003Cproduct\u003E:\u003Cguid\u003E\nhttp://\u003Cvendor-domain-name\u003E/\u003Cproduct\u003E/\u003Cguid\u003E\nWhere \u003Cvendor-domain-name\u003E is a domain name owned by the product vendor. \u003Cyyyy-MM\u003E is the year and month that the URI was created. The \u003Cproduct\u003E is an identifier for the product which could contain many path segments and \u003Cguid\u003E is unique identifier generated when the product is first initialized on a particular Device.\n4) ProductInstanceUri assigned by a Device Manufacturer:\ntag:\u003Cmanufacturer-domain-name\u003E,\u003Cyyyy-MM\u003E:\u003Cproduct\u003E:\u003Cserial-number\u003E"
    },
    {
      "Id": "f453ffbe-3419-46ed-bb1e-bb39e01a17e2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.2 URIs\n---\n",
      "Content": "http://\u003Cmanufacturer-domain-name\u003E/\u003Cproduct\u003E/\u003Cserial-number\u003E\nWhere \u003Cmanufacturer-domain-name\u003E is a domain name owned by the Manufacturer. \u003Cyyyy-MM\u003E is the year and month that the URI was created. The \u003Cproduct\u003E is an identifier for the product which could contain many path segments and \u003Cserial-number\u003E is unique identifier for the Device assigned by the Manufacturer."
    },
    {
      "Id": "e01579a1-3176-44fd-b0d4-e5df71b50248",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.3 Object Model"
    },
    {
      "Id": "902f918d-0dca-44a2-8a08-7ef8a54c8728",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.3 Object Model\n---\n",
      "Content": "The primary objective of the OPC UA AddressSpace is to provide a standard way for Servers to represent Objects to Clients. The OPC UA Object Model has been designed to meet this objective. It defines Objects in terms of Variables and Methods. It also allows relationships to other Objects to be expressed.[Figure 2](/\u00A7_Ref130064097) illustrates the model."
    },
    {
      "Id": "70cf7118-001d-422f-91b4-8477a9ce20c9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.3 Object Model\nCaption: Figure 2 - OPC UA Object Model\n---\n",
      "Content": "[image005.png](images/image005.png)"
    },
    {
      "Id": "84f00a9c-944c-4a66-bedb-1cc4a0b2a31f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.3 Object Model\n---\n",
      "Content": "Figure 2 - OPC UA Object Model\nThe elements of this model are represented in the AddressSpace as Nodes. Each Node is assigned to a NodeClass and each NodeClass represents a different element of the Object Model. Clause[4.10](/\u00A7_Ref127675422) defines the NodeClasses used to represent this model."
    },
    {
      "Id": "f28e0693-23ae-4efc-9b16-604566ac6886",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.4 Node Model"
    },
    {
      "Id": "99ac1ee1-c1b8-4f44-8187-78360d9b4777",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4 Node Model\n---\n",
      "Content": "4.4.1 General"
    },
    {
      "Id": "7f88f5d6-c97f-484a-aa99-be409cc70979",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.1 General\n---\n",
      "Content": "The set of Objects and related information that the OPC UA Server makes available to Clients is referred to as its AddressSpace. The model for Objects is defined by the OPC UA Object Model (see[4.3](/\u00A7_Ref191560643)).\nObjects and their components are represented in the AddressSpace as a set of Nodes described by Attributes and interconnected by References.[Figure 3](/\u00A7_Ref114466674) illustrates the model of a Node and the remainder of 4.3 discusses the details of the Node Model."
    },
    {
      "Id": "2613b913-fc96-47d7-89cc-d32a180447d9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.1 General\nCaption: Figure 3 - AddressSpace Node Model\n---\n",
      "Content": "[image006.png](images/image006.png)"
    },
    {
      "Id": "9988eea3-870f-4e37-b724-4c87b78e25f7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.1 General\n---\n",
      "Content": "Figure 3 - AddressSpace Node Model"
    },
    {
      "Id": "8633f1b2-32a6-4991-8d92-5920e6f7346b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4 Node Model\n---\n",
      "Content": "4.4.2 NodeClasses"
    },
    {
      "Id": "54df5474-b9c8-4580-acbf-dce58d623057",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.2 NodeClasses\n---\n",
      "Content": "NodeClasses are defined in terms of the Attributes and References that shall be instantiated (given values) when a Node is defined in the AddressSpace. Attributes are discussed in[4.4.3](/\u00A7_Ref113946526) and References in[4.4.4](/\u00A7_Ref130228637).\nClause[5](/\u00A7_Ref40785698) defines the NodeClasses for the OPC UA AddressSpace. These NodeClasses are referred to collectively as the metadata for the AddressSpace. Each Node in the AddressSpace is an instance of one of these NodeClasses. No other NodeClasses shall be used to define Nodes, and as a result, Clients and Servers are not allowed to define NodeClasses or extend the definitions of these NodeClasses."
    },
    {
      "Id": "94db9cbe-db02-4350-8863-1237a3d510bc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4 Node Model\n---\n",
      "Content": "4.4.3 Attributes"
    },
    {
      "Id": "d059f186-ea01-4ff2-be70-e5f8345485b2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.3 Attributes\n---\n",
      "Content": "Attributes are data elements that describe Nodes. Clients can access Attribute values using Read, Write, Query, and Subscription/MonitoredItem Services. These Services are defined in[OPC 10000-4](/\u00A7UAPart4).\nAttributes are elementary components of NodeClasses. Attribute definitions are included as part of the NodeClass definitions in Clause[4.10](/\u00A7_Ref127675422) and, therefore, are not included in the AddressSpace.\nEach Attribute definition consists of an attribute id (for attribute ids of Attributes, see[OPC 10000-6](/\u00A7UAPart6)), a name, a description, a data type and a mandatory/optional indicator. The set of Attributes defined for each NodeClass shall not be extended by Clients or Servers.\nWhen a Node is instantiated in the AddressSpace, the values of the NodeClass Attributes are provided. The mandatory/optional indicator for the Attribute indicates whether the Attribute has to be instantiated."
    },
    {
      "Id": "f1695638-39c8-4033-b067-118c00bb7728",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4 Node Model\n---\n",
      "Content": "4.4.4 References"
    },
    {
      "Id": "ec973306-cfac-4473-b5da-6c77e050c5dd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.4 References\n---\n",
      "Content": "References are used to relate Nodes to each other. They can be accessed using the browsing and querying Services defined in[OPC 10000-4](/\u00A7UAPart4).\nLike Attributes, they are defined as fundamental components of Nodes. Unlike Attributes, References are defined as instances of ReferenceType Nodes. ReferenceType Nodes are visible in the AddressSpace and are defined using the ReferenceType NodeClass(see[5.3](/\u00A7_Ref126748663)).\nThe Node that contains the Reference is referred to as the SourceNode and the Node that is referenced is referred to as the TargetNode. The combination of the SourceNode, the ReferenceType and the TargetNode are used in OPC UA Services to uniquely identify References. Thus, each Node can reference another Node with the same ReferenceType only once. Any subtypes of concrete ReferenceTypes are considered to be equal to the base concrete ReferenceTypes when identifying References(see[5.3](/\u00A7_Ref126748663) for subtypes of ReferenceTypes).[Figure 4](/\u00A7_Ref114026424) illustrates this model of a Reference."
    },
    {
      "Id": "71c10f8a-3650-4fed-8471-2f349135c819",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.4 References\nCaption: Figure 4 - Reference Model\n---\n",
      "Content": "[image007.png](images/image007.png)"
    },
    {
      "Id": "23235a64-88f9-4645-bd66-dee071d3dfa1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.4.4 References\n---\n",
      "Content": "Figure 4 - Reference Model\nThe TargetNode of a Reference may be in the same AddressSpace or in the AddressSpace of another OPC UA Server. TargetNodes located in other Servers are identified in OPC UA Services using a combination of the remote Server name and the identifier assigned to the Node by the remote Server.\nOPC UA does not require that the TargetNode exists, thus References may point to a Node that does not exist."
    },
    {
      "Id": "3f35fdd3-d40c-49fa-8462-92792605a406",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.5 Variables"
    },
    {
      "Id": "0eadd125-fcf9-4bd2-ad44-520a0eab284d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.5 Variables\n---\n",
      "Content": "4.5.1 General"
    },
    {
      "Id": "e55e8d76-0f53-4daf-897c-6226fd4b4a8f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.5.1 General\n---\n",
      "Content": "Variables are used to represent values. Two types of Variables are defined, Properties and DataVariables. They differ in the kind of data that they represent and whether they can contain other Variables."
    },
    {
      "Id": "3cb1a890-196a-4ae5-90f4-33e39aea5147",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.5 Variables\n---\n",
      "Content": "4.5.2 Properties"
    },
    {
      "Id": "cce8e5be-3652-4062-b2b2-b858f700e7e9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.5.2 Properties\n---\n",
      "Content": "Properties are Server-defined characteristics of Objects, DataVariables and other Nodes. Properties differ from Attributes in that they characterise what the Node represents, such as a device or a purchase order. Attributes define additional metadata that is instantiated for all Nodes from a NodeClass. Attributes are common to all Nodes of a NodeClass and only defined by this specification whereas Properties can be Server-defined.\nFor example, an Attribute defines the DataType of Variables whereas a Property can be used to specify the engineering unit of some Variables.\nTo prevent recursion, Properties are not allowed to have Properties defined for them. To easily identify Properties, the BrowseName of a Property shall be unique in the context of the Node containing the Properties(see[5.6.3](/\u00A7_Ref127693460) for details).\nA Node and its Properties shall always reside in the same Server."
    },
    {
      "Id": "92d6cb88-fa87-4f48-a6b2-75d308ee3422",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.5 Variables\n---\n",
      "Content": "4.5.3 DataVariables"
    },
    {
      "Id": "4047f852-e13d-4620-aaad-9b6ab75d5f83",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.5.3 DataVariables\n---\n",
      "Content": "DataVariables represent the content of an Object. For example, a file Object may be defined that contains a stream of bytes. The stream of bytes may be defined as a DataVariable that is an array of bytes. Properties may be used to expose the creation time and owner of the file Object.\nFor example, if a DataVariable is defined by a data structure that contains two fields, \u0022startTime\u0022 and \u0022endTime\u0022 then it might have a Property specific to that data structure, such as \u0022earliestStartTime\u0022.\nAs another example, function blocks in control systems might be represented as Objects. The parameters of the function block, such as its setpoints, may be represented as DataVariables. The function block Object might also have Properties that describe its execution time and its type.\nDataVariables may have additional DataVariables, but only if they are complex. In this case, their DataVariables shall always be elements of their complex definitions. Following the example introduced by the description of Properties in[4.5.2](/\u00A7_Ref130228256), the Server could expose \u0022startTime\u0022 and \u0022endTime\u0022 as separate components of the data structure.\nAs another example, a complex DataVariable may define an aggregate of temperature values generated by three separate temperature transmitters that are also visible in the AddressSpace. In this case, this complex DataVariable could define HasComponent References from it to the individual temperature values that it is composed of."
    },
    {
      "Id": "c34cb2c7-9f14-49f5-83b5-f1979a5ba8cd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.6 TypeDefinitionNodes"
    },
    {
      "Id": "277e80d5-feeb-4539-8b08-fcc98e4038e6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6 TypeDefinitionNodes\n---\n",
      "Content": "4.6.1 General"
    },
    {
      "Id": "e1a4d085-4453-4974-b54e-c427f094c684",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.1 General\n---\n",
      "Content": "OPC UA Servers shall provide type definitions for Objects and Variables. The HasTypeDefinition Reference shall be used to link an instance with its type definition represented by a TypeDefinitionNode. Type definitions are required; however,[OPC 10000-5](/\u00A7UAPart5) defines a BaseObjectType, a PropertyType, and a BaseDataVariableType so a Server can use such a base type if no more specialised type information is available. Objects and Variables inherit the Attributes specified by their TypeDefinitionNode(see[6.4](/\u00A7_Ref128009730) for details).\nIn some cases, the NodeId used by the HasTypeDefinition Reference will be well-known to Clients and Servers. Organizations may define TypeDefinitionNodes that are well-known in the industry. Well-known NodeIds of TypeDefinitionNodes provide for commonality across OPC UA Servers and allow Clients to interpret the TypeDefinitionNode without having to read it from the Server. Therefore, Servers may use well-known NodeIds without representing the corresponding TypeDefinitionNodes in their AddressSpace. However, the TypeDefinitionNodes shall be provided for generic Clients. These TypeDefinitionNodes may exist in another Server.\nThe following example, illustrated in[Figure 5](/\u00A7_Ref130227898), describes the use of the HasTypeDefinition Reference. In this example, a setpoint parameter \u0022SP\u0022 is represented as a DataVariable in the AddressSpace. This DataVariable is part of an Object not shown in the figure.\nTo provide for a common setpoint definition that can be used by other Objects, a specialised VariableType is used. Each setpoint DataVariable that uses this common definition will have a HasTypeDefinition Reference that identifies the common \u0022SetPoint\u0022 VariableType."
    },
    {
      "Id": "494746b8-abd5-48fb-85f4-748cbb688835",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.1 General\nCaption: Figure 5 - Example of a Variable defined by a VariableType\n---\n",
      "Content": "[image008.png](images/image008.png)"
    },
    {
      "Id": "b518f080-7140-44b1-9ff3-d048f5bf7491",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.1 General\n---\n",
      "Content": "Figure 5 - Example of a Variable defined by a VariableType"
    },
    {
      "Id": "de36a388-9a2c-461e-b322-62e5bfb19263",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6 TypeDefinitionNodes\n---\n",
      "Content": "4.6.2 Complex TypeDefinitionNodes and their InstanceDeclarations"
    },
    {
      "Id": "570f3ad5-e62c-4c6f-8241-1c0891f86768",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.2 Complex TypeDefinitionNodes and their InstanceDeclarations\n---\n",
      "Content": "TypeDefinitionNodes can be complex. A complex TypeDefinitionNode also defines References to other Nodes as part of the type definition. The ModellingRules defined in[6.4.4](/\u00A7_Ref128179460) specify how those Nodes are handled when creating an instance of the type definition.\nA TypeDefinitionNode references instances instead of other TypeDefinitionNodes to allow unique names for several instances of the same type, to define default values and to add References for those instances that are specific to this complex TypeDefinitionNode and not to the TypeDefinitionNode of the instance. For example, in[Figure 6](/\u00A7_Ref130898447) the ObjectType\u0022AI_BLK_TYPE\u0022, representing a function block, has a HasComponent Reference to a Variable\u0022SP\u0022 of the VariableType\u0022SetPoint\u0022. \u0022AI_BLK_TYPE\u0022 could have an additional setpoint Variable of the same type using a different name. It could add a Property to the Variable that was not defined by its TypeDefinitionNode\u0022SetPoint\u0022. And it could define a default value for \u0022SP\u0022, that is, each instance of \u0022AI_BLK_TYPE\u0022 would have a Variable\u0022SP\u0022 initially set to this value."
    },
    {
      "Id": "36fed775-54b3-4d52-bf73-3ada17ca6e4f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.2 Complex TypeDefinitionNodes and their InstanceDeclarations\nCaption: Figure 6 - Example of a Complex TypeDefinition\n---\n",
      "Content": "[image009.png](images/image009.png)"
    },
    {
      "Id": "f0b17855-34b2-410c-8081-37571db593de",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.2 Complex TypeDefinitionNodes and their InstanceDeclarations\n---\n",
      "Content": "Figure 6 - Example of a Complex TypeDefinition\nThis approach is commonly used in object-oriented programming languages in which the variables of a class are defined as instances of other classes. When the class is instantiated, each variable is also instantiated, but with the default values (constructor values) defined for the containing class. That is, typically, the constructor for the component class runs first, followed by the constructor for the containing class. The constructor for the containing class may override component values set by the component class.\nTo distinguish instances used for the type definitions from instances that represent real data, those instances are called InstanceDeclarations. However, this term is used to simplify this specification, if an instance is an InstanceDeclaration or not is only visible in the AddressSpace by following its References. Some instances may be shared and therefore referenced by TypeDefinitionNodes, InstanceDeclarations and instances. This is similar to class variables in object-oriented programming languages."
    },
    {
      "Id": "77ad3b9e-ee00-48c5-8108-9e6473f3b2bc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6 TypeDefinitionNodes\n---\n",
      "Content": "4.6.3 Subtyping"
    },
    {
      "Id": "2e407c57-7e42-4e52-b527-12a52bf64aa7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.3 Subtyping\n---\n",
      "Content": "This standard allows subtyping of type definitions. The subtyping rules are defined in Clause[6](/\u00A7_Ref130963989). Subtyping of ObjectTypes and VariableTypes allows:\nClients that only know the supertype to handle an instance of the subtype as if it were an instance of the supertype;\ninstances of the supertype to be replaced by instances of the subtype;\nspecialised types that inherit common characteristics of the base type.\nIn other words, subtypes reflect the structure defined by their supertype but may add additional characteristics. For example, a vendor may wish to extend a general \u0022TemperatureSensor\u0022 VariableType by adding a Property providing the next maintenance interval. The vendor would do this by creating a new VariableType which is a TargetNode for a HasSubtype reference from the original VariableType and adding the new Property to it."
    },
    {
      "Id": "a52db581-1455-485d-ae71-7891ae08a619",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6 TypeDefinitionNodes\n---\n",
      "Content": "4.6.4 Instantiation of complex TypeDefinitionNodes"
    },
    {
      "Id": "b5defb97-568f-4bb9-b43a-6d89531360a2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.4 Instantiation of complex TypeDefinitionNodes\n---\n",
      "Content": "The instantiation of complex TypeDefinitionNodes depends on the ModellingRules defined in[6.4.4](/\u00A7_Ref128179460). However, the intention is that instances of a type definition will reflect the structure defined by the TypeDefinitionNode.[Figure 7](/\u00A7_Ref115491510) shows an instance of the TypeDefinitionNode\u0022AI_BLK_TYPE\u0022, where the ModellingRule Mandatory, defined in[6.4.4.4.1](/\u00A7_Ref192912661), was applied for its containing Variable. Thus, an instance of \u0022AI_BLK_TYPE\u0022, called AI_BLK_1\u0022, has a HasTypeDefinition Reference to \u0022AI_BLK_TYPE\u0022. It also contains a Variable\u0022SP\u0022 having the same BrowseName as the Variable\u0022SP\u0022 used by the TypeDefinitionNode and thereby reflects the structure defined by the TypeDefinitionNode."
    },
    {
      "Id": "aefafd41-15f4-41d0-b78d-d1bfff73039f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.4 Instantiation of complex TypeDefinitionNodes\nCaption: Figure 7 - Object and its Components defined by an ObjectType\n---\n",
      "Content": "[image010.png](images/image010.png)"
    },
    {
      "Id": "194977a9-b179-4c61-bfd3-d9054dcb09de",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.6.4 Instantiation of complex TypeDefinitionNodes\n---\n",
      "Content": "Figure 7 - Object and its Components defined by an ObjectType\nA client knowing the ObjectType\u0022AI_BLK_TYPE\u0022 can use this knowledge to directly browse to the containing Nodes for each instance of this type. This allows programming against the TypeDefinitionNode. For example, a graphical element may be programmed in the client that handles all instances of \u0022AI_BLK_TYPE\u0022 in the same way by showing the value of \u0022SP\u0022.\nThere are several constraints related to programming against the TypeDefinitionNode. A TypeDefinitionNode or an InstanceDeclaration shall never reference two Nodes having the same BrowseName using forward hierarchical References. Instances based on InstanceDeclarations shall always keep the same BrowseName as the InstanceDeclaration they are derived from. A special Service defined in[OPC 10000-4](/\u00A7UAPart4) called TranslateBrowsePathsToNodeIds may be used to identify the instances based on the InstanceDeclarations. Using the simple Browse Service might not be sufficient since the uniqueness of the BrowseName is only required for TypeDefinitionNodes and InstanceDeclarations, not for other instances. Thus, \u0022AI_BLK_1\u0022 may have another Variable with the BrowseName\u0022SP\u0022, although this one would not be derived from an InstanceDeclaration of the TypeDefinitionNode.\nInstances derived from an InstanceDeclaration shall be of the same TypeDefinitionNode or a subtype of this TypeDefinitionNode.\nA TypeDefinitionNode and its InstanceDeclarations shall always reside in the same Server. However, instances may point with their HasTypeDefinition Reference to a TypeDefinitionNode in a different Server."
    },
    {
      "Id": "e7bb7182-6b63-4ed8-8229-1089569bbf2b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.7 Event Model"
    },
    {
      "Id": "8ec45a15-449c-4b47-bfb2-b19483ebaad1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.7 Event Model\n---\n",
      "Content": "4.7.1 General"
    },
    {
      "Id": "8b4a3301-b6b1-40b2-9a19-dce89b1ea69f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.7.1 General\n---\n",
      "Content": "The Event Model defines a general purpose eventing system that can be used in many diverse vertical markets.\nEvents represent specific transient occurrences. System configuration changes and system errors are examples of Events. Event Notifications report the occurrence of an Event. Events defined in this document are not directly visible in the OPC UA AddressSpace. Objects and Views can be used to subscribe to Events. The EventNotifier Attribute of those Nodes identifies if the Node allows subscribing to Events. Clients subscribe to such Nodes to receive Notifications of Event occurrences.\nEvent Subscriptions use the Monitoring and Subscription Services defined in[OPC 10000-4](/\u00A7UAPart4) to subscribe to the Event Notifications of a Node.\nAny OPC UA Server that supports eventing shall expose at least one Node as EventNotifier. The Server Object defined in[OPC 10000-5](/\u00A7UAPart5) is used for this purpose. Events generated by the Server are available via this Server Object. A Server is not expected to produce Events if the connection to the event source is down for some reason (i.e. the system is offline).\nEvents may also be exposed through other Nodes anywhere in the AddressSpace. These Nodes(identified via the EventNotifier Attribute) provide some subset of the Events generated by the Server. The position in the AddressSpace dictates what this subset will be. For example, a process area Object representing a functional area of the process would provide Events originating from that area of the process only. It should be noted that this is only an example and it is fully up to the Server to determine what Events should be provided by which Node."
    },
    {
      "Id": "bcdba0b5-0e77-483b-a605-adadaa81c8f1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.7 Event Model\n---\n",
      "Content": "4.7.2 EventTypes"
    },
    {
      "Id": "0206947e-4595-4331-9608-3a66bbdcd8b1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.7.2 EventTypes\n---\n",
      "Content": "Each Event is of a specific EventType. A Server may support many types. This part defines the BaseEventType that all other EventTypes derive from. It is expected that other companion specifications will define additional EventTypes deriving from the base types defined in this part.\nThe EventTypes supported by a Server are exposed in the AddressSpace of a Server. EventTypes are represented as ObjectTypes in the AddressSpace and do not have a special NodeClass associated to them.[OPC 10000-5](/\u00A7UAPart5) defines how a Server exposes the EventTypes in detail.\nEventTypes defined in this document are specified as abstract and therefore never instantiated in the AddressSpace. Event occurrences of those EventTypes are only exposed via a Subscription. Components of an EventType defined with ModellingRules other than Mandatory or Optional cannot be returned in an Event Subscription. EventTypes exist in the AddressSpace to allow Clients to discover the EventType. This information is used by a client when establishing and working with Event Subscriptions. EventTypes defined by other parts of this series of standards or companion specifications as well as Server specific EventTypes may be defined as not abstract and therefore instances of those EventTypes may be visible in the AddressSpace although Events of those EventTypes are also accessible via the Event Notification mechanisms.\nStandard EventTypes are described in Clause[8.61](/\u00A7_Ref128437157). Their representation in the AddressSpace is specified in[OPC 10000-5](/\u00A7UAPart5)."
    },
    {
      "Id": "747abbdf-4cad-4274-8da6-3666833dcf0d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.7 Event Model\n---\n",
      "Content": "4.7.3 Event Categorization"
    },
    {
      "Id": "07191468-5941-4bd0-9043-a22010187918",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.7.3 Event Categorization\n---\n",
      "Content": "Events can be categorised by creating new EventTypes which are subtypes of existing EventTypes but do not extend an existing type. They are used only to identify an event as being of the new EventType. For example, the EventType DeviceFailureEventType could be subtyped into TransmitterFailureEventType and ComputerFailureEventType. These new subtypes would not add new Properties or change the semantic inherited from the DeviceFailureEventType other than purely for categorization of the Events.\nEvent sources can also be organised into groups by using the Event ReferenceTypes described in[7.16](/\u00A7_Ref135713256) and[7.18](/\u00A7_Ref135713552). For example, a Server may define Objects in the AddressSpace representing Events related to physical devices, or Event areas of a plant or functionality contained in the Server. Event References would be used to indicate which Event sources represent physical devices and which ones represent some Server-based functionality. In addition, References can be used to group the physical devices or Server-based functionality into hierarchical Event areas. In some cases, an Event source may be categorised as being both a device and a Server function. In this case, two relationships would be established. Refer to the description of the Event ReferenceTypes for additional examples.\nClients can select a category or categories of Events by defining content filters that include terms specifying the EventType of the Event or a grouping of Event sources. The two mechanisms allow for a single Event to be categorised in multiple manners. A client could obtain all Events related to a physical device or all failures of a particular device."
    },
    {
      "Id": "740f1c63-7d0c-47ba-b877-525bcf65671c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.8 Methods"
    },
    {
      "Id": "150d5d80-e8e6-422c-970d-2cb066b9cf99",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.8 Methods\n---\n",
      "Content": "Methods are \u0022lightweight\u0022 functions, whose scope is bounded by an owning (see Note) Object, similar to the methods of a class in object-oriented programming or an owning ObjectType, similar to static methods of a class. Methods are invoked by a client, proceed to completion on the Server and return the result to the client. The lifetime of the Method\u0027s invocation instance begins when the client calls the Method and ends when the result is returned.\nNOTE The owning Object or ObjectType is specified in the service call when invoking the Method.\nWhile Methods may affect the state of the owning Object, they have no explicit state of their own. In this sense, they are stateless. Methods can have a varying number of input arguments and return resultant arguments. Each Method is described by a Node of the Method NodeClass. This Node contains the metadata that identifies the Method\u0027s arguments and describes its behaviour.\nMethods are invoked by using the Call Service defined in[OPC 10000-4](/\u00A7UAPart4).\nClients discover the Methods supported by a Server by browsing for the owning Objects References that identify their supported Methods."
    },
    {
      "Id": "843ed497-c6d7-4165-ae6e-2bb4a886d062",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.9 Roles"
    },
    {
      "Id": "3a9caba1-241e-468c-9b37-72b90c259248",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9 Roles\n---\n",
      "Content": "4.9.1 Overview"
    },
    {
      "Id": "b4456729-599b-4e7a-a0db-b3cafd62b16e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.1 Overview\n---\n",
      "Content": "A Role is a function assumed by a Client when it accesses a Server. Roles are used to separate authentication (determining who a Client is) from authorization (determining what the Client is allowed to do). By separating these tasks Servers can allow centralized services to manage user identities and credentials while the Server only manages the Permissions on its Nodes assigned to Roles.\nThe set of Roles supported by a Server are published as components of the RoleSet Object defined in[OPC 10000-18](/\u00A7UAPart18). S ervers should define a base set of Roles and allow configuration Clients to add system specific Roles. Adding, deleting, and modifying Roles is restricted to callers with appropriate permissions.\nWhen a Session is created, or a Session-less Service is called, the Server must determine what Roles are granted to that Session or Session-less Service invocation. This specification defines standard mapping rules which Servers may support. Servers may also use vendor specific mapping rules in addition to or instead of the standard rules.\nThe Anonymous Role is the default Role which is always assigned to all Sessions.\nThe AuthenticatedUser Role is always assigned when a Session has been authenticated with a UserIdentityToken other than the AnonymousIdentityToken(see[OPC 10000-4](/\u00A7UAPart4)).\nThe TrustedApplication Role is always assigned when a Session has been authenticated with a trusted ApplicationInstance Certificate(see[OPC 10000-4](/\u00A7UAPart4)) and uses at least a signed communication channel.\nThe standard mapping rules allow Roles to be granted based on:\nUser identity;\nApplication identity;\nEndpoint;\nUser identity mappings can be based on user names, user certificates or user groups.\nApplication identity mappings are based on the ApplicationUri specified in the Client Certificate"
    },
    {
      "Id": "e9f84df2-cf0c-492c-9c37-83e2b6fe9d92",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.1 Overview\n---\n",
      "Content": "specified in the Client Certificate. Application identity can only be enforced if the Client proves possession of a trusted Certificate by using it to create a Secure Channel or by providing a signature in ActivateSession(see[OPC 10000-4](/\u00A7UAPart4)).\nEndpoint identity mappings are based on the URL used to connect to the Server. Endpoint identity can be used to restrict access to Clients running on particular networks. Endpoint identity mappings should not be used as the only criteria unless access to the endpoint is restricted by the network infrastructure. For example, an endpoint on a loopback address is only accessible from the same machine.\n[OPC 10000-5](/\u00A7UAPart5) defines the Objects, Methods and DataTypes used to represent and manage these mapping rules in the Address Space."
    },
    {
      "Id": "54e8d41c-36a9-4568-aa40-010a015018b9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9 Roles\n---\n",
      "Content": "4.9.2 Well Known Roles"
    },
    {
      "Id": "8d31773a-7241-47d0-b5b7-e577277df27e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.2 Well Known Roles\n---\n",
      "Content": "The NodeIds for the well-known Roles are defined in[OPC 10000-6](/\u00A7UAPart6). All Servers should support the well-known Roles which are defined in[Table 2](/\u00A7_Ref466032569).\nTable 2 - Well-Known Roles"
    },
    {
      "Id": "313b74e3-991c-4a07-9229-11bf4a74f1aa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.2 Well Known Roles\nCaption: Table 2 - Well-Known Roles\n---\n",
      "Content": "BrowseName\nSuggested Permissions\nAnonymous\nThe Role is allowed to browse and read non-security related Nodes only in the Server Object and all type Nodes.\nAuthenticatedUser\nThe Role is allowed to browse and read non-security related Nodes.\nTrustedApplication\nThe Role is allowed to browse and read non-security related Nodes.\nObserver\nThe Role is allowed to browse, read live data, read historical data/events or subscribe to data/events.\nOperator\nThe Role is allowed to browse, read live data, read historical data/events or subscribe to data/events.\nIn addition, the Session is allowed to write some live data and call some Methods.\nEngineer\nThe Role is allowed to browse, read/write configuration data, read historical data/events, call Methods or subscribe to data/events.\nSupervisor\nThe Role is allowed to browse, read live data, read historical data/events, call Methods or subscribe to data/events.\nConfigureAdmin\nThe Role is allowed to change the non-security related configuration settings.\nSecurityAdmin\nThe Role is allowed to change security related settings."
    },
    {
      "Id": "15a185c4-0967-40c9-b3f8-ea440aa00895",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.2 Well Known Roles\n---\n",
      "Content": ""
    },
    {
      "Id": "473378ee-6866-43a0-999f-74935c13fcae",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9 Roles\n---\n",
      "Content": "4.9.3 Evaluating Permissions with Roles"
    },
    {
      "Id": "cfec408b-1024-4c37-9aef-10127f8b3622",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\n---\n",
      "Content": "When a Client attempts to access a Node, the Server goes through the list of Roles granted to the Session and logically ORs the Permissions for the Role on the Node. If there are no Node specific Permissions then the default Permissions for the Role in the DefaultRolePermissions Property of the NamespaceMetadata for the namespace the Node belongs to are used (see[OPC 10000-5](/\u00A7UAPart5)). The resulting mask is the effective Permissions. If the bits corresponding to current operation are set, then the operation can proceed. If they are not set the Server returns Bad_UserAccessDenied.\nRoles appear under the Roles Object in the Server Address Space. Each Role has mapping rules defined which appear as Properties of the Role Object(see[OPC 10000-5](/\u00A7UAPart5)). The examples shown in[Table 3](/\u00A7_Ref466032570) illustrate how the standard mapping rules can be used to determine which Roles a Session has access to and, consequently, the Permissions that are granted to the Session.\nTable 3 - Example Roles"
    },
    {
      "Id": "657fb757-1f83-4142-b019-f012c80b1819",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\nCaption: Table 3 - Example Roles\n---\n",
      "Content": "Role\nMapping Rules\nDescription\nAnonymous\nIdentities = Anonymous\nApplications =\nEndpoints =\nAn identity mapping rule that specifies the Role applies to anonymous users.\nAuthenticatedUser\nIdentities = AuthenticatedUser\nApplications =\nEndpoints =\nAn identity mapping rule that specifies the Role applies to authenticated users.\nOperator1\nIdentities = User with name \u0027Joe\u0027\nApplications = urn:OperatorStation1\nEndpoints =\nAn identity mapping rule that specifies specific users that have access to the Role with a application rule that restricts access to a single Client application.\nOperator2\nIdentities = Users with name \u0027Joe\u0027 or \u0027Ann\u0027\nApplications = urn:OperatorStation2\nEndpoints =\nAn identity mapping rule that specifies specific users that have access to the Role with a application rule that restricts access to a single Client application.\nSupervisor\nIdentities = User with name \u0027Root\u0027\nApplications =\nEndpoints =\nAn identity mapping rule that specifies specific users that have access to the Role\nAdministrator\nIdentities = User with name \u0027Root\u0027\nApplications =\nEndpoints = opc.tcp://127.0.0.1:48000\nAn identity mapping rule that specifies specific users that have access to the Role when they connect via a specific Endpoint."
    },
    {
      "Id": "7ec38b1a-52cb-4344-acbe-82d1eac8fe5e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\n---\n",
      "Content": "The examples also make use of the Nodes defined in[Table 4](/\u00A7_Ref466032573). The table specifies the value of the RolePermissions Attribute for each Node.\nTable 4 - Example Nodes"
    },
    {
      "Id": "219a9f9e-4397-4202-85cf-9382addd13b4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\nCaption: Table 4 - Example Nodes\n---\n",
      "Content": "Node\nRole Permissions\nUnit1.Measurement\nAuthenticatedUser = Browse\nOperator1 = Browse, Read\nUnit2.Measurement\nAuthenticatedUser = Browse\nOperator2 = Browse, Read\nSetPoint\nAuthenticatedUser = Browse\nOperator1 and Operator2 = Browse, Read, Write\nSupervisor = Browse, Read\nDisableDevice\nAuthenticatedUser = Browse\nOperator1 and Operator2 = Browse, Read\nAdministrator = Browse, Read, Write"
    },
    {
      "Id": "d6ba7226-08a9-4ee2-a5f7-585cc667eef4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\n---\n",
      "Content": "When a Client creates a Session the Roles assigned to the Session depend on the rules defined for each Role.[Table 5](/\u00A7_Ref466032583) lists the assigned Roles for different Sessions created with different Users, Client applications and Endpoints.\nTable 5 - Example Role Assignment"
    },
    {
      "Id": "6f4a6bd7-3e77-4f10-a18b-b41192591395",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\nCaption: Table 5 - Example Role Assignment\n---\n",
      "Content": "User Provided by Client\nRoles Assigned to Session\nAnonymous\nAnonymous\nSam\nAuthenticatedUser\nJoe using OperatorStation1 application.\nAuthenticatedUser, Operator1\nJoe using OperatorStation2 application.\nAuthenticatedUser, Operator2\nJoe using generic application.\nAuthenticatedUser\nRoot using OperatorStation1 application.\nAuthenticatedUser, Supervisor\nRoot using generic application and 127.0.0.1 endpoint.\nAuthenticatedUser, Supervisor, Administrator\nRoot using generic application and another endpoint.\nAuthenticatedUser, Supervisor"
    },
    {
      "Id": "0abc8ebc-d0e4-45f8-ae34-c8c33ebd997b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\n---\n",
      "Content": "When a Client application accesses a Node the RolePermissions for the Node are compared to the Roles assigned to the Session. Any Permissions available to at least one Role is granted to the Client.[Table 6](/\u00A7_Ref466032595) provides a number of scenarios and examples and the resulting decision on access.\nTable 6 - Examples of Evaluating Access"
    },
    {
      "Id": "4ba8d283-2c74-4c99-90a8-6bc2245d5584",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.9.3 Evaluating Permissions with Roles\nCaption: Table 6 - Examples of Evaluating Access\n---\n",
      "Content": "Use Case\nRole Permissions\nAnonymous user on localhost browses Unit1.Measurement Node.\nAccess denied because no rule defined for Anonymous users.\nUser \u0027Sam\u0027 using OperatorStation1 application browses Unit1.Measurement Node.\nAllowed because AuthenticatedUser is granted Browse Permission.\nUser \u0027Sam\u0027 using OperatorStation2 application reads Value of Unit1.Measurement Node.\nAccess denied because AuthenticatedUser is not granted Read Permission.\nUser \u0027Joe\u0027 using OperatorStation1 application reads Value of Unit1.Measurement Node.\nAllowed because Operator1 is granted Read Permission.\nUser \u0027Joe\u0027 using OperatorStation2 application reads Value of Unit1.Measurement Node.\nAccess denied because AuthenticatedUser and Operator2 are not granted Read Permission.\nUser \u0027Joe\u0027 using generic OPC UA application reads Value of Measurement Node.\nAccess denied because AuthenticatedUser is not granted Read Permission.\nUser \u0027Joe\u0027 using OperatorStation1 application write Value of SetPoint Node.\nAllowed because Operator1 is granted Write Permission.\nUser \u0027Root\u0027 using OperatorStation1 application write the Value of SetPoint Node.\nDenied because AuthenticatedUser and Supervisor are not granted Write Permission.\nUser \u0027Joe\u0027 using OperatorStation1 application write Value of DisableDevice Node.\nAccess denied because AuthenticatedUser and Operator1 are not granted Write Permission.\nUser \u0027Root\u0027 using OperatorStation1 application write the Value of DisableDevice Node.\nAccess denied because AuthenticatedUser and Supervisor are not granted Write Permission.\nUser \u0027Root\u0027 using endpoint 127.0.0.1 to write Value of DisableDevice Node.\nAllowed because Administrator is granted Write Permission."
    },
    {
      "Id": "4a3eaaff-4a68-4845-bc92-289db70fac9a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4 AddressSpace concepts\n---\n",
      "Content": "4.10 Interfaces and AddIns for Objects"
    },
    {
      "Id": "1f690324-6641-4408-b305-2cf19d3d4aed",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10 Interfaces and AddIns for Objects\n---\n",
      "Content": "4.10.1 Overview"
    },
    {
      "Id": "408be752-5d15-4ff7-aec2-8ed088ad04a6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.1 Overview\n---\n",
      "Content": "OPC UA defines a type model supporting one object-oriented type hierarchy for ObjectTypes. Although the specification does not restrict those hierarchies to be single inheritance (i.e. a type can only have one super-type) it only specifies the semantic (inheritance rules) for single inheritance.\nIn general, good object-oriented design is accomplished by using composition to aggregate an object which provides several functions instead of over-using inheritance[[GH95]](/\u00A7GH95),[[FF04]](/\u00A7FF04).\nInterfaces and AddIns complement the type model and can be used when subtyping is not suitable for the required extension. They:\nallow enhancing multiple types at arbitrary positions in the type hierarchy.\nalso allow enhancing just instances."
    },
    {
      "Id": "43ec5563-1b0e-43f3-8358-2067d3ff0a86",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10 Interfaces and AddIns for Objects\n---\n",
      "Content": "4.10.2 Interface Model"
    },
    {
      "Id": "f95ebdf9-2195-4020-a7a7-9151024201f7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": "Interfaces are ObjectTypes that represent a generic feature (functionality), assumed to be usable by different ObjectTypes or Objects. The Interface model specifies the rules and mechanisms to achieve this.\nThe \u0022 InterfaceTypes\u0022 Object(see[OPC 10000-5](/\u00A7UAPart5)) has been defined so that all Interfaces of the Server are either directly or indirectly accessible browsing HierarchicalReferences starting from this Node.\nRules for the definition of Interfaces:\nInterface ObjectTypes shall be abstract subtypes of the BaseInterfaceType ObjectType.\nInstanceDeclarations on an Interface shall only have ModellingRules Optional or Mandatory.\nInterfaces can be subtyped as specified in clause 6.3.\nInterfaces shall not be the source of HasInterface References.\nRecommended convention: The first letter of an Interface should be \u0027I\u0027. See examples below.\nRules for applying Interfaces:\nWhen an ObjectType references an Interface with a HasInterface Reference or a subtype, the following rules apply:\nEach mandatory InstanceDeclaration of the fully-inherited InstanceDeclarationHierarchy of the Interface shall have for each BrowsePath a similar Node(see 6.2.4) with the ModellingRule Mandatory using the same BrowsePath in the fully-inherited InstanceDeclarationHierarchy of the ObjectType. The rules for instantiating InstanceDeclarations defined in 6.2.6 shall be applied.\nEach optional InstanceDeclaration of the fully-inherited InstanceDeclarationHierarchy of the Interface should have for each BrowsePath a similar Node(see 6.2.4) with the ModellingRule Mandatory or Optional using the same BrowsePath in the fully-inherited InstanceDeclarationHierarchy of the ObjectType. The rules for instantiating InstanceDeclarations defined in 6.2.6 shall be applied. If no similar Node with the same BrowsePath exists, the ObjectType"
    },
    {
      "Id": "9659d74d-215c-4da0-8889-fc240cec05dc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": "exists, the ObjectType and its sub-types shall not use the same BrowsePath for a different Node(e.g. with a different NodeClass).\nIf the rules cannot be fulfilled (e.g. name collisions) the ObjectType cannot apply the Interface, i.e. it shall not reference the Interface with a HasInterface Reference of a subtype.\nThe rules apply for each referenced Interface. As a consequence, an ObjectType cannot reference two Interfaces using the same BrowsePath for Nodes that are not similar Nodes or have TypeDefinitionNodes that are not compatible (compatible means they have either the same TypeDefinitionNode or one TypeDefinitionNode is the subtype of the other TypeDefinitionNode).\nSubtypes should not have a HasInterface Reference to an Interface if it was already applied to a super-type.\nWhen an Object references an Interface with a HasInterface Reference or a subtype, the following rules apply:\nThe Interface shall not be applied on the Object when the Interface cannot be applied on the TypeDefinitionNode of the Object.\nThe same rules on the Object apply as if the Interface would have been applied on the TypeDefinitionNode of the Object(e.g. all Mandatory InstanceDeclarations need to be applied).\nThe Nodes defined based on the Interface shall be handled as if they were defined by the TypeDefinitionNode. For example, the TranslateBrowsePathsToNodeIds Service shall return them first.\nIf several Interfaces should be applied to the Object, they should be treated as if they were all applied to the ObjectType of the Object at the same time. If this is not possible, the Interfaces cannot be applied to the Object together.\nInstances should not have a HasInterface Reference to an Interface if it was already applied to the TypeDefinitionNode.\nA BaseInterfaceType or any subtype of BaseInterfaceType shall not be the TargetNode of a HasTypeDefinition Reference."
    },
    {
      "Id": "efd8da64-625a-47e0-8ef0-501627c8a23b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": ".\n\n[Figure 8](/\u00A7_Ref33163443) illustrates example Interfaces:\nISerializeServiceType, an Interface to convert the Object and its components into a stream of bytes.\nITransactionServiceType, an Interface to perform a sequence of changes to the Object as a single operation.\nILocationType, an Interface to specify the installation location of the Object."
    },
    {
      "Id": "c1608c9d-a54f-41c9-b299-ba03549b4461",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\nCaption: Figure 8 - Examples of Interfaces\n---\n",
      "Content": "[image011.png](images/image011.png)"
    },
    {
      "Id": "13be099d-397d-4926-b15e-6b850c2aeb4c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": "Figure 8 - Examples of Interfaces\nThe following examples illustrate the application of these Interfaces. In[Figure 9](/\u00A7_Ref33163360) the example Interface ILocationType is applied to the XYZ-DeviceType ObjectType. It also illustrates the overriding of Property\u0022Address\u0022 by changing the ModellingRule from Optional to Mandatory.[Figure 10](/\u00A7_Ref33163303) in addition shows how to use the ISerializeService Interface on the instance only.[Figure 11](/\u00A7_Ref33163405) shows an Interface hierarchy where InstanceDeclarations of the referenced Interface and its parent type(s) are applied (the fully-inherited InstanceDeclarationHierarchy)."
    },
    {
      "Id": "aa0e85ad-00b8-4a24-a30b-7ab437d093d6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\nCaption: Figure 9 - Example: Interface application to an ObjectType\n---\n",
      "Content": "[image012.png](images/image012.png)"
    },
    {
      "Id": "c0059bd2-c1e6-4a21-b94d-980e851b9c80",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": "Figure 9 - Example: Interface application to an ObjectType"
    },
    {
      "Id": "df55633f-2175-49bc-b98b-5fb4b9be8b57",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\nCaption: Figure 10 - Example: One Interface applied to an ObjectType another one to the instance\n---\n",
      "Content": "[image013.png](images/image013.png)"
    },
    {
      "Id": "db92fd8d-5cdb-484f-82c7-cf6ec650c52e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": "Figure 10 - Example: One Interface applied to an ObjectType another one to the instance"
    },
    {
      "Id": "06d23889-df5e-4801-a002-9f7e933285c7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\nCaption: Figure 11 - Example: Interface Hierarchy\n---\n",
      "Content": "[image014.png](images/image014.png)"
    },
    {
      "Id": "c0e46696-398f-41cf-aaef-e658ccaf9c2e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.2 Interface Model\n---\n",
      "Content": "Figure 11 - Example: Interface Hierarchy\n\nClients can detect the implementation of Interfaces by filtering for the HasInterface Reference into the Browse Service request.\nOn instances, the Browse Service will return elements derived from an Interface together with elements of the Node\u0027s base type. Clients can also use the TranslateBrowsePathsToNodeId Service with BrowseNames of Interface members to get the NodeId of these members directly.\nIn the example in[Figure 10](/\u00A7_Ref33163303)\u0022 Address MD002 NodeId of this Property.\nOn Object instances, some Nodes of an Interface may not be available if defined with ModellingRule Optional."
    },
    {
      "Id": "43ec1ee5-15b4-4dab-85fb-54e9f1fced58",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10 Interfaces and AddIns for Objects\n---\n",
      "Content": "4.10.3 AddIn model"
    },
    {
      "Id": "233859af-b674-4890-96ea-ff0ddd2db03b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.3 AddIn model\n---\n",
      "Content": "AddIns associate a feature or feature-set, represented by an ObjectType to the Node(an Object or ObjectType) they are applied to. The Interface model is different than the AddIn model in that it is based on composition. An AddIn is applied to a Node by adding a Reference to the AddIn instance.\nThere are no restrictions for AddIn ObjectTypes and there is no special supertype for AddIns. To identify instances as an AddIn, the HasAddIn Reference or a subtype shall be used.\nThe AddIn ObjectType shall include the definition of a default BrowseName using the DefaultInstanceBrowseName Property. Instances of such an AddIn should use this default BrowseName. If an AddIn is instantiated multiple times in the same parent, only one instance can have the default BrowseName.\nThe definition of an AddIn and its use with a default BrowseName is illustrated in[Figure 12](/\u00A7_Ref33163199)."
    },
    {
      "Id": "43b6c122-babc-4dcf-903e-2a88dd84cbbf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.3 AddIn model\nCaption: Figure 12 - Example of AddIn with default BrowseName\n---\n",
      "Content": "[image015.png](images/image015.png)"
    },
    {
      "Id": "63fbaf37-9da2-456b-b222-6bcc86b2c52b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.3 AddIn model\n---\n",
      "Content": "Figure 12 - Example of AddIn with default BrowseName\nAs already described, an AddIn can be applied on types and instances. The use on an instance is shown in[Figure 13](/\u00A7_Ref33163165)."
    },
    {
      "Id": "800ffb36-3f24-45d2-8215-8e2df8ae59cf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.3 AddIn model\nCaption: Figure 13 - Example of AddIn applied to an instance\n---\n",
      "Content": "[image016.png](images/image016.png)"
    },
    {
      "Id": "1f7d5ad6-7763-41ef-9d8a-a3eaefab289b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 4.10.3 AddIn model\n---\n",
      "Content": "Figure 13 - Example of AddIn applied to an instance\nClients can detect the implementation of AddIns by passing the HasAddIn Reference as filter to the Browse Service request. If an AddIn has a default BrowseName, Clients can use the TranslateBrowsePathsToNodeId Service with the default BrowseName to get the NodeId of an AddIn.\nIn the example in[Figure 12](/\u00A7_Ref33163199) the relative path \u0022 MyFeature/MyPropertyM MD002 NodeId of this Property and the relative path \u0022 MyFeature/MyMethodO Method."
    },
    {
      "Id": "d461195d-d1d6-4e04-950a-d243756af7ae",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "5 Standard NodeClasses"
    },
    {
      "Id": "1954b90c-2485-4aa6-9513-5e1340cf4a16",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.1 Overview"
    },
    {
      "Id": "a83ae5cc-3111-46d3-b992-d724ef091664",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.1 Overview\n---\n",
      "Content": "Clause 5 defines the NodeClasses used to define Nodes in the OPC UA AddressSpace. NodeClasses are derived from a common Base NodeClass. This NodeClass is defined first, followed by those used to organise the AddressSpace and then by the NodeClasses used to represent Objects.\nThe NodeClasses defined to represent Objects fall into three categories: those used to define instances, those used to define types for those instances and those used to define data types. Subclause[6.3](/\u00A7_Ref192918126) describes the rules for subtyping and[6.4](/\u00A7_Ref128098709) the rules for instantiation of the type definitions."
    },
    {
      "Id": "f707961e-2d2c-4b91-aaae-a4b296d0121d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.2 Base NodeClass"
    },
    {
      "Id": "c63d57cb-026b-4667-9330-59f92851952e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.1 General"
    },
    {
      "Id": "5a33f46d-c202-405d-92f7-1068cb8e66f5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.1 General\n---\n",
      "Content": "The OPC UA Address Space Model defines a Base NodeClass from which all other NodeClasses are derived. The derived NodeClasses represent the various components of the OPC UA Object Model (see[4.2](/\u00A7_Ref114466780)). The Attributes of the Base NodeClass are specified in[Table 7](/\u00A7_Ref127764296). There are no References specified for the Base NodeClass.\nTable 7 - Base NodeClass"
    },
    {
      "Id": "48b23fed-e6a8-427f-bfee-bd341592f21f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.1 General\nCaption: Table 7 - Base NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nNodeId\nM\nNodeId\nSee[5.2.2](/\u00A7_Ref127611812)\nNodeClass\nM\nNodeClass\nSee[5.2.3](/\u00A7_Ref130971964)\nBrowseName\nM\nQualifiedName\nSee[5.2.4](/\u00A7_Ref129165702)\nDisplayName\nM\nLocalizedText\nSee[5.2.5](/\u00A7_Ref381260618)\nDescription\nO\nLocalizedText\nSee[5.2.6](/\u00A7_Ref128263306)\nWriteMask\nO\nAttributeWriteMask\nSee[5.2.7](/\u00A7_Ref176331998)\nUserWriteMask\nO\nAttributeWriteMask\nSee[5.2.8](/\u00A7_Ref181420178)\nRolePermissions\nO\nRolePermissionType[]\nSee[5.2.9](/\u00A7_Ref468871197)\nUserRolePermissions\nO\nRolePermissionType[]\nSee[5.2.10](/\u00A7_Ref468871280)\n\nO\nAccessRestrictionType\nSee[5.2.11](/\u00A7_Ref468871293)\nReferences\n\n\nNo References specified for this NodeClass"
    },
    {
      "Id": "fab7cf6f-754d-47e0-960c-e949a7be3cce",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.1 General\n---\n",
      "Content": ""
    },
    {
      "Id": "ed2d3626-586c-43de-8873-7dc352defd06",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.2 NodeId"
    },
    {
      "Id": "0f87f00b-678b-4922-9b9c-35ac6ec8241a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.2 NodeId\n---\n",
      "Content": "Nodes are unambiguously identified using a constructed identifier called the NodeId. Some Servers may accept alternative NodeIds in addition to the canonical NodeId represented in this Attribute. A Server shall persist the identifierType and identifier NodeId elements of a Node as well as the Namespace Uri which the namespaceIndex NodeId element references. A Server may change the namespaceIndex NodeId element of a Node with future Sessions and therefore a Client shall not assume the namespaceIndex will not change. The structure of the NodeId is defined in[8.2](/\u00A7_Ref121325674)."
    },
    {
      "Id": "4a6b0ed8-5962-47b3-8b54-7cbbc4a82bf9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.3 NodeClass"
    },
    {
      "Id": "308bf8f9-3320-4959-bce2-63a9f5052775",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.3 NodeClass\n---\n",
      "Content": "The NodeClass Attribute identifies the NodeClass of a Node. Its data type is defined in[8.29](/\u00A7_Ref130971442)."
    },
    {
      "Id": "c3d41b45-e638-4a4e-ac7c-81451344641e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.4 BrowseName"
    },
    {
      "Id": "77d21c8b-71bf-4d81-a966-a7ef7b301e29",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.4 BrowseName\n---\n",
      "Content": "Nodes have a BrowseName Attribute that is used as a non-localised human-readable name when browsing the AddressSpace to create paths out of BrowseNames. The TranslateBrowsePathsToNodeIds Service defined in[OPC 10000-4](/\u00A7UAPart4) can be used to follow a path constructed of BrowseNames.\nA BrowseName should never be used to display the name of a Node. The DisplayName should be used instead for this purpose.\nUnlike NodeIds, the BrowseName cannot be used to unambiguously identify a Node. Different Nodes may have the same BrowseName.\nSubclause[8.3](/\u00A7_Ref135813266) defines the structure of the BrowseName. It contains a namespace and a string. The namespace is provided to make the BrowseName unique in some cases in the context of a Node(e.g. Properties of a Node) although not unique in the context of the Server. If different organizations define BrowseNames for Properties, the namespace of the BrowseName provided by the organization makes the BrowseName unique, although different organizations may use the same string having a slightly different meaning.\nServers may often choose to use the same namespace for the NodeId and the BrowseName. However, if they want to provide a standard Property, its BrowseName shall have the namespace of the standards body although the namespace of the NodeId reflects something else, for example the local Server.\nStandards bodies defining standard type definitions shall use their namespace(s) for the NodeId of the TypeDefinitionNode as well as for the BrowseName of the TypeDefinitionNode. BrowseNames of TypeDefinitionNodes, ReferenceTypes, and DataTypes shall be unique. A ny well-known instances used as entry points shall also be unique. For example, the Root Node defined in[OPC 10000-5](/\u00A7UAPart5)."
    },
    {
      "Id": "4ff61f42-ee7d-43ec-ac37-22fe1dc9eaff",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.4 BrowseName\n---\n",
      "Content": ".\nThe string-part of the BrowseName is case sensitive. That is, Clients shall consider them case sensitive. Servers are allowed to handle BrowseNames passed in Service requests as case insensitive. Examples are the TranslateBrowsePathsToNodeIds Service or Event filter. If a Server accepts a case insensitive BrowseName it needs to ensure that the uniqueness of the BrowseName does not depend on case."
    },
    {
      "Id": "32223218-c13b-4d5a-a24c-80336688e513",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.5 DisplayName"
    },
    {
      "Id": "66f68926-de4e-46c9-bfee-065a9d30cd31",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.5 DisplayName\n---\n",
      "Content": "The DisplayName Attribute contains the localised name of the Node. Clients should use this Attribute if they want to display the name of the Node to the user. They should not use the BrowseName for this purpose. The Server may maintain one or more localised representations for each DisplayName. Clients negotiate the locale to be returned when they open a session with the Server. Refer to[OPC 10000-4](/\u00A7UAPart4) for a description of session establishment and locales. Subclause[8.5](/\u00A7_Ref135813289) defines the structure of the DisplayName. The string part of the DisplayName is restricted to 512 characters."
    },
    {
      "Id": "300efdc2-3f56-4e65-b84b-aff7211c2575",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.6 Description"
    },
    {
      "Id": "a4c2b35e-eb9f-48b6-85df-8f201b437a0a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.6 Description\n---\n",
      "Content": "The optional Description Attribute shall explain the meaning of the Node in a localised text using the same mechanisms for localisation as described for the DisplayName in[5.2.5](/\u00A7_Ref381258055)."
    },
    {
      "Id": "68ba32fd-8a7f-4637-8a25-c9f70e6b44de",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.7 WriteMask"
    },
    {
      "Id": "76ea9f12-c7f9-4e69-b836-d31ffe43b9d2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.7 WriteMask\n---\n",
      "Content": "The optional WriteMask Attribute exposes the possibilities of a client to write the Attributes of the Node. The WriteMask Attribute does not take any user access rights into account, that is, although an Attribute is writeable this may be restricted to a certain user/user group.\nIf the OPC UA Server does not have the ability to get the WriteMask information for a specific Attribute from the underlying system, it should state that it is writeable. If a write operation is called on the Attribute, the Server should transfer this request and return the corresponding StatusCode if such a request is rejected. StatusCodes are defined in[OPC 10000-4](/\u00A7UAPart4).\nThe AttributeWriteMask DataType is defined in[8.60](/\u00A7_Ref525200209)."
    },
    {
      "Id": "647f2e84-6b66-4f7a-a01d-b4109d7e8a52",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.8 UserWriteMask"
    },
    {
      "Id": "c3512bff-8b15-4de7-b821-ee3bc228ab03",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.8 UserWriteMask\n---\n",
      "Content": "The optional UserWriteMask Attribute exposes the possibilities of a client to write the Attributes of the Node taking user access rights into account. It uses the AttributeWriteMask DataType which is defined in[8.60](/\u00A7_Ref525200209).\nThe UserWriteMask Attribute can only further restrict the WriteMask Attribute, when it is set to not writeable in the general case that applies for every user.\nClients cannot assume an Attribute can be written based on the UserWriteMask Attribute.It is possible that the Server may return an access denied error due to some server specific change which was not reflected in the state of this Attribute at the time the Client accessed it."
    },
    {
      "Id": "9f16c526-a19d-41a6-bafb-a4c2c2a02bb5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.9 RolePermissions"
    },
    {
      "Id": "4958f6fb-d3b2-49d3-8122-67a99dec63d7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.9 RolePermissions\n---\n",
      "Content": "The optional RolePermissions Attribute specifies the Permissions that apply to a Node for all Roles which have access to the Node. The value of the Attribute is an array of RolePermissionType Structures(see[Table 8](/\u00A7_Ref466032608)).\nTable 8- RolePermissionType\nName\nType\nDescription\nRolePermissionType\nStructure\nSpecifies the Permissions for a Role\nroleId\nNodeId\nThe NodeId of the Role Object.\npermissions\nPermissionType\nA mask specifying which Permissions are available to the Role. See[8.55](/\u00A7_Ref493240480)\n\nServers may allow administrators to write to the RolePermissions Attribute.\nIf not specified, the value of DefaultRolePermissions Property from the NamespaceMetadata Object associated with the Node shall be used instead. If the NamespaceMetadata Object does not define the Property or does not exist, then the Server should not publish any information about how it manages Permissions.\nIf a Server supports Permissions for a particular Namespace it shall add the DefaultRolePermissions Property to the NamespaceMetadata Object for that Namespace(see[Figure 14](/\u00A7_Ref466032640)). If a particular Node in the Namespace needs to override the default values, the Server adds the RolePermissions Attribute to the Node. The DefaultRolePermissions Property and RolePermissions Attribute shall only be readable by administrators. If a Server allows the Permissions to be changed these values shall be writeable. If the Server allows the Permissions to be overridden for a particular Node but does not currently have any Node Permissions configured, then the value of the Attribute shall be an empty array. If the administrator wishes to remove overridden Permissions, an empty array shall be written to this Attribute. Servers shall prevent Permissions from being changed in such a way as to render the Server inoperable.\nIf a Server allows writes to the RolePermissions"
    },
    {
      "Id": "e7a92273-b1ac-4166-84ba-2406a54bfc78",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.9 RolePermissions\n---\n",
      "Content": "RolePermissions it shall preserve all bits written by the Client even if they are not valid for the Node. When a Client reads the RolePermissions or UserRolePermissions it shall ignore bits that are not valid for the Node.\nIf a Server publishes information about the Roles for a Namespace assigned to the current Session, it shall add the DefaultUserRolePermissions Property to the NamespaceMetadata Object for that Namespace. The value of this Property shall be a readonly list of Permissions for each Role assigned to the current Session. If a particular Node in the Namespace overrides the default RolePermissions the Server shall also override the DefaultUserRolePermissions by adding the UserRolePermissions Attribute to the Node. If the Server allows the Permissions to be overridden for a particular Node but does not currently have any Node Permissions configured, then the Server shall return the value of the DefaultUserRolePermissions Property for the Node Namespace.\nIf a Server implements a vendor specific Role Permission model for a Namespace, it shall not add the DefaultRolePermissions or DefaultUserRolePermissions Properties to the NamespaceMetadata Object."
    },
    {
      "Id": "76079c54-c938-479c-b977-e73b2087db0c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.9 RolePermissions\nCaption: Figure 14 - Permissions in the Address Space\n---\n",
      "Content": "[image017.png](images/image017.png)"
    },
    {
      "Id": "346ef8c0-0422-4164-87a1-df616cca6902",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.9 RolePermissions\n---\n",
      "Content": "Figure 14 - Permissions in the Address Space"
    },
    {
      "Id": "47786b0b-d1d8-49d0-8cdd-a72d410ee121",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.10 UserRolePermissions"
    },
    {
      "Id": "ba7cdd0c-6472-4a72-95c4-73db7efd5881",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.10 UserRolePermissions\n---\n",
      "Content": "The optional UserRolePermissions Attribute specifies the Permissions that apply to a Node for all Roles granted to current Session. The value of the Attribute is an array of RolePermissionType Structures(see[Table 8](/\u00A7_Ref466032608)).\nClients may determine their effective Permissions by performing a logical OR of Permissions for each Role in the array.\nThe value of this Attribute is derived from the rules used by the Server to map Sessions to Roles. This mapping may be vendor specific or it may use the standard Role model defined in[4.9](/\u00A7_Ref466032707).\nThis Attribute shall not be writeable. When a Client reads the UserRolePermissions it shall ignore bits that are not valid for the Node.\nIf not specified, the value of DefaultUserRolePermissions Property from the Namespace Metadata Object associated with the Node is used instead. If the NamespaceMetadata Object does not define the Property or does not exist, then the Server does not publish any information about Roles mapped to the current Session."
    },
    {
      "Id": "55f3a969-57d0-4923-a055-d92cd1e5fecb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2 Base NodeClass\n---\n",
      "Content": "5.2.11 AccessRestrictions"
    },
    {
      "Id": "cfdcc8e9-82dd-4316-8583-d968fd788de3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.2.11 AccessRestrictions\n---\n",
      "Content": "The optional AccessRestrictions Attribute specifies the AccessRestrictions that apply to a Node. Its data type is defined in[8.56](/\u00A7_Ref493239529). If a Server supports AccessRestrictions for a particular Namespace it adds the DefaultAccessRestrictions Property to the NamespaceMetadata Object for that Namespace(see[Figure 14](/\u00A7_Ref466032640)). If a particular Node in the Namespace needs to override the default value the Server adds the AccessRestrictions Attribute to the Node.\nIf a Server implements a vendor specific access restriction model for a Namespace, it does not add the DefaultAccessRestrictions Property to the NamespaceMetadata Object."
    },
    {
      "Id": "8d175a70-632f-4665-99e7-17dc36b6fb1d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.3 ReferenceType NodeClass"
    },
    {
      "Id": "784ac010-64c3-40c3-be01-3e7d39fb13cd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3 ReferenceType NodeClass\n---\n",
      "Content": "5.3.1 General"
    },
    {
      "Id": "a93e9ad0-217a-4748-b78a-2d27ef9c7f13",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.1 General\n---\n",
      "Content": "References are defined as instances of ReferenceType Nodes. ReferenceType Nodes are visible in the AddressSpace and are defined using the ReferenceType NodeClass as specified in[Table 9](/\u00A7_Ref114297294). In contrast, a Reference is an inherent part of a Node and no NodeClass is used to represent References.\nThis standard defines a set of ReferenceTypes provided as an inherent part of the OPC UA Address Space Model. These ReferenceTypes are defined in Clause[7](/\u00A7_Ref192918160) and their representation in the AddressSpace is defined in[OPC 10000-5](/\u00A7UAPart5). Servers may also define ReferenceTypes. In addition,[OPC 10000-4](/\u00A7UAPart4) defines NodeManagement Services that allow Clients to add ReferenceTypes to the AddressSpace.\nTable 9 - ReferenceType NodeClass"
    },
    {
      "Id": "caecf737-1508-45c5-b0cc-d1edc53b1899",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.1 General\nCaption: Table 9 - ReferenceType NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nIsAbstract\nM\nBoolean\nA boolean Attribute with the following values:\nTRUE it is an abstract ReferenceType, i.e. no Reference of this type shall exist, only of its subtypes.\nFALSE it is not an abstract ReferenceType, i.e. References of this type can exist.\nSymmetric\nM\nBoolean\nA boolean Attribute with the following values:\nTRUE the meaning of the ReferenceType is the same as seen from both the SourceNode and the TargetNode.\nFALSE the meaning of the ReferenceType as seen from the TargetNode is the inverse of that as seen from the SourceNode.\nInverseName\nO\nLocalizedText\nThe inverse name of the Reference, which is the meaning of the ReferenceType as seen from the TargetNode.\n\n\n\n\nReferences\n\n\n\nHasProperty\n0..*\n\nUsed to identify the Properties (see[5.3.3.2](/\u00A7_Ref126749213)).\nHasSubtype\n0..*\n\nUsed to identify subtypes (see[5.3.3.3](/\u00A7_Ref126749286)).\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node"
    },
    {
      "Id": "5484bb0a-9544-4e08-84cd-c229f7984e55",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.1 General\nCaption: Table 9 - ReferenceType NodeClass\n---\n",
      "Content": "Node has changed."
    },
    {
      "Id": "74f0bb54-1433-48d0-864f-8efe9176946b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.1 General\n---\n",
      "Content": ""
    },
    {
      "Id": "ea0ecc44-69f3-4226-9c98-e3bfcc2e2a98",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3 ReferenceType NodeClass\n---\n",
      "Content": "5.3.2 Attributes"
    },
    {
      "Id": "818caed4-df53-424d-bb50-5160cd44ac3a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.2 Attributes\n---\n",
      "Content": "The ReferenceType NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037). The inherited BrowseName Attribute is used to specify the meaning of the ReferenceType as seen from the SourceNode. For example, the ReferenceType with the BrowseName\u0022Contains\u0022 is used in References that specify that the SourceNode contains the TargetNode. The inherited DisplayName Attribute contains a translation of the BrowseName.\nThe BrowseName of a ReferenceType shall be unique in a Server. It is not allowed that two different ReferenceTypes have the same BrowseName.\nThe IsAbstract Attribute indicates if the ReferenceType is abstract. Abstract ReferenceTypes cannot be instantiated and are used only for organizational reasons, for example to specify some general semantics or constraints that its subtypes inherit.\nThe Symmetric Attribute is used to indicate whether or not the meaning of the ReferenceType is the same for both the SourceNode and TargetNode.\nIf a ReferenceType is symmetric, the InverseName Attribute shall be omitted. Examples of symmetric ReferenceTypes are \u0022Connects To\u0022 and \u0022Communicates With\u0022. Both imply the same semantic coming from the SourceNode or the TargetNode. Therefore both directions are considered to be forward References.\nIf the ReferenceType is non-symmetric the InverseName Attribute shall be set. The InverseName Attribute specifies the meaning of the ReferenceType as seen from the TargetNode. Examples of non-symmetric ReferenceTypes include \u0022Contains\u0022 and \u0022Contained In\u0022, and \u0022Receives From\u0022 and \u0022Sends To\u0022.\nAny subtype, either directly or indirectly of a concrete ReferenceType s hall not change the Symmetric Attribute definition of its parent type.\nReferences that use the InverseName, such as \u0022Contained In\u0022 References, are referred to as inverse References."
    },
    {
      "Id": "7757e2b4-90f2-472b-8f2c-7473e7c6b2c7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.2 Attributes\n---\n",
      "Content": "References.\n[Figure 15](/\u00A7_Ref81040875) provides examples of symmetric and non-symmetric References and the use of the BrowseName and the InverseName."
    },
    {
      "Id": "08e99e31-3dd5-475e-a655-02916907789f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.2 Attributes\nCaption: Figure 15 - Symmetric and Non-Symmetric References\n---\n",
      "Content": "[image018.png](images/image018.png)"
    },
    {
      "Id": "80b53853-cd1a-42a1-8799-d38745fa7a08",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.2 Attributes\n---\n",
      "Content": "Figure 15 - Symmetric and Non-Symmetric References\nIt might not always be possible for Servers to instantiate both forward and inverse References for non-symmetric ReferenceTypes as shown in[Figure 15](/\u00A7_Ref81040875). When they do, the References are referred to as bidirectional. Although not required, it is recommended that all hierarchical References be instantiated as bidirectional to ensure browse connectivity. A bidirectional Reference is modelled as two separate References.\nAs an example of a unidirectional Reference, it is often the case that a signal sink knows its signal source, but this signal source does not know its signal sink. The signal sink would have a \u0022Sourced By\u0022 Reference to the signal source, without the signal source having the corresponding \u0022Sourced To\u0022 inverse References to its signal sinks.\nThe DisplayName and the InverseName are the only standardised places to indicate the semantic of a ReferenceType. There may be more complex semantics associated with a ReferenceType than can be expressed in those Attributes(e.g. the semantic of HasSubtype). This standard does not specify how this semantic should be exposed. However, the Description Attribute can be used for this purpose. This standard provides a semantic for the ReferenceTypes specified in Clause[7](/\u00A7_Ref192918184).\nA ReferenceType can have constraints restricting its use. For example, it can specify that starting from Node A and only following References of this ReferenceType or one of its subtypes, it shall never be able to return to A, that is, a \u0022No Loop\u0022 constraint.\nThis standard does not specify how those constraints could or should be made available in the AddressSpace. Nevertheless, for the standard ReferenceTypes, some constraints are specified in Clause[7](/\u00A7_Ref192918213)"
    },
    {
      "Id": "e55cc69e-a862-463f-b382-536d4765d073",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.2 Attributes\n---\n",
      "Content": ". This standard does not restrict the kind of constraints valid for a ReferenceType. It can, for example, also affect an ObjectType. The restriction that a ReferenceType can only be used by relating Nodes of some NodeClasses with a defined cardinality is a special constraint of a ReferenceType."
    },
    {
      "Id": "316c8c9c-0016-462c-9b63-0a77ba00276c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3 ReferenceType NodeClass\n---\n",
      "Content": "5.3.3 References"
    },
    {
      "Id": "52f7cc28-0c98-4c36-94cb-940f03677fc0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.3 References\n---\n",
      "Content": "5.3.3.1 General"
    },
    {
      "Id": "442b8cdf-b856-47d4-83b0-c148dbe6b9be",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.3.1 General\n---\n",
      "Content": "HasSubtype References and HasProperty References are the only ReferenceTypes that may be used with ReferenceType Nodes as SourceNode. ReferenceType Nodes shall not be the SourceNode of other types of References."
    },
    {
      "Id": "ae5a5cc0-b902-478b-b0d0-2df100acbb4f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.3 References\n---\n",
      "Content": "5.3.3.2 HasProperty References"
    },
    {
      "Id": "d5f7581b-56c2-4b53-a0a1-ad71e374fb71",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.3.2 HasProperty References\n---\n",
      "Content": "HasProperty References are used to identify the Properties of a ReferenceType and shall only refer to Nodes of the Variable NodeClass.\nThe Property NodeVersion is used to indicate the version of the ReferenceType.\nThere are no additional Properties defined for ReferenceTypes in this standard. Additional parts this series of standards may define additional Properties for ReferenceTypes."
    },
    {
      "Id": "d692a151-2faf-4835-85d4-a25dc1edc126",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.3 References\n---\n",
      "Content": "5.3.3.3 HasSubtype References"
    },
    {
      "Id": "9dc6e6d6-4152-4260-b67f-808c5cb0b761",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.3.3.3 HasSubtype References\n---\n",
      "Content": "HasSubtype References are used to define subtypes of ReferenceTypes. It is not required to provide the HasSubtype Reference for the supertype, but it is required that the subtype provides the inverse Reference to its supertype. The following rules for subtyping apply.\nThe semantic of a ReferenceType(e.g. \u0022spans a hierarchy\u0022) is inherited to its subtypes and can be refined there (e.g. \u0022spans a special hierarchy\u0022). The DisplayName, and also the InverseName for non-symmetric ReferenceTypes, reflect the specialization.\nIf a ReferenceType specifies some constraints (e.g. \u0022allow no loops\u0022) this is inherited and can only be refined (e.g. inheriting \u0022no loops\u0022 could be refined as \u0022shall be a tree - only one parent\u0022) but not lowered (e.g. \u0022allow loops\u0022).\nThe constraints concerning which NodeClasses can be referenced are also inherited and can only be further restricted. That is, if a ReferenceType\u0022A\u0022 is not allowed to relate an Object with an ObjectType, this is also true for its subtypes.\nA ReferenceType shall have exactly one supertype, except for the References ReferenceType defined in[7.2](/\u00A7_Ref190746722) as the root type of the ReferenceType hierarchy. The ReferenceType hierarchy does not support multiple inheritances."
    },
    {
      "Id": "0e820722-5862-4ec0-9b1b-79288901062d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.4 View NodeClass"
    },
    {
      "Id": "96a44ef0-e02a-4c12-9d9e-fc680c0bdce1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.4 View NodeClass\n---\n",
      "Content": "Underlying systems are often large and Clients often have an interest in only a specific subset of the data. They do not need, or want, to be burdened with viewing Nodes in the AddressSpace for which they have no interest.\nTo address this problem, this standard defines the concept of a View. Each View defines a subset of the Nodes in the AddressSpace. The entire AddressSpace is the default View. Each Node in a View may contain only a subset of its References, as defined by the creator of the View. The View Node acts as the root for the Nodes in the View. Views are defined using the View NodeClass, which is specified in[Table 10](/\u00A7_Ref115584961).\nAll Nodes contained in a View shall be accessible starting from the View Node when browsing in the context of the View. It is not expected that all containing Nodes can be browsed directly from the View Node but rather browsed from other Nodes contained in the View.\nA View Node may not only be used as additional entry point into the AddressSpace but as a construct to organize the AddressSpace and thus as the only entry point into a subset of the AddressSpace. Therefore, Clients shall not ignore View Nodes when exposing the AddressSpace. Simple Clients that do not deal with Views for filtering purposes can, for example, handle a View Node like an Object of type FolderType(see[5.5.3](/\u00A7_Ref196606972)).\nTable 10 - View NodeClass"
    },
    {
      "Id": "9cb9e303-bfac-4695-a304-46b5a9d07bac",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.4 View NodeClass\nCaption: Table 10 - View NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nContainsNoLoops\nM\nBoolean\nIf set to TRUE this Attribute indicates that by following the References in the context of the View there are no loops, i.e. starting from a Node\u0022A\u0022 contained in the View and following the forward References in the context of the View Node\u0022A\u0022 will not be reached again. It does not specify that there is only one path starting from the View Node to reach a Node contained in the View.\nIf set to FALSE this Attribute indicates that following References in the context of the View may lead to loops.\nEventNotifier\nM\nEventNotifierType\nThe EventNotifier Attribute is used to indicate if the Node can be used to subscribe to Events or the read / write historic Events.\nThe EventNotifierType is defined in[8.59](/\u00A7_Ref34744539).\n\n\n\n\nReferences\n\n\n\nHierarchicalReferences\n0..*\n\nTop level Nodes in a View are referenced by hierarchical References(see[7.3](/\u00A7_Ref127666975)).\nHasProperty\n0..*\n\nHasProperty References identify the Properties of the View.\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a"
    },
    {
      "Id": "a455f2e7-4ac0-4107-abca-790a5bc51149",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.4 View NodeClass\nCaption: Table 10 - View NodeClass\n---\n",
      "Content": "Node has changed.\nViewVersion\nO\nUInt32\nThe version number for the View. When Nodes are added to or removed from a View, the value of the ViewVersion Property is updated. Clients may detect changes to the composition of a View using this Property. The value of the ViewVersion shall always be greater than 0."
    },
    {
      "Id": "d907eb71-c856-427c-8649-194606e64d51",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.4 View NodeClass\n---\n",
      "Content": "The View NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037). It also defines two additional Attributes.\nThe mandatory ContainsNoLoops Attribute is set to FALSE if the Server is not able to identify if the View contains loops or not.\nThe mandatory EventNotifier Attribute identifies if the View can be used to subscribe to Events that either occur in the content of the View or as ModelChangeEvents(see[9.32](/\u00A7_Ref141746034)) of the content of the View or to read / write the history of the Events. A View that supports Events shall provide all Events that occur in any Object used as EventNotifier that is part of the content of the View. In addition, it shall provide all ModelChangeEvents that occur in the context of the View.\nTo avoid recursion, i.e. getting all Events of the Server, the Server Object defined in[OPC 10000-5](/\u00A7UAPart5) shall never be part of any View since it provides all Events of the Server.\nViews are defined by the Server. The browsing and querying Services defined in[OPC 10000-4](/\u00A7UAPart4) expect the NodeId of a View Node to provide these Services in the context of the View.\nHasProperty References are used to identify the Properties of a View. The Property NodeVersion is used to indicate the version of the View Node. The ViewVersion Property indicates the version of the content of the View. In contrast to the NodeVersion, the ViewVersion Property is updated even if Nodes not directly referenced by the View Node are added to or deleted from the View. This Property is optional because it might not be possible for Servers to detect changes in the View contents. Servers may also generate a"
    },
    {
      "Id": "ba75a0f0-4881-4ffb-a1be-c9411bb29688",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.4 View NodeClass\n---\n",
      "Content": "Servers may also generate a ModelChangeEvent, described in[9.32](/\u00A7_Ref141746034), if Nodes are added to or deleted from the View. There are no additional Properties defined for Views in this document. Additional parts of this series of standards may define additional Properties for Views.\nViews can be the SourceNode of any hierarchical Reference. They shall not be the SourceNode of any NonHierarchical Reference."
    },
    {
      "Id": "47ac0106-2cc4-43f7-b33b-3e294b63abde",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.5 Objects"
    },
    {
      "Id": "0734003c-ce93-44a4-af03-ef966a8be3b7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5 Objects\n---\n",
      "Content": "5.5.1 Object NodeClass"
    },
    {
      "Id": "039d3660-3afb-46e7-897f-69a23f438b49",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.1 Object NodeClass\n---\n",
      "Content": "Objects are used to represent systems, system components, real-world objects and software objects. Objects are defined using the Object NodeClass, specified in[Table 11](/\u00A7_Ref114299173).\nTable 11 - Object NodeClass"
    },
    {
      "Id": "d07496d1-8936-4b93-a024-0f207c6856ba",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.1 Object NodeClass\nCaption: Table 11 - Object NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nEventNotifier\nM\nEventNotifierType\nThe EventNotifier Attribute is used to indicate if the Node can be used to subscribe to Events or the read / write historic Events.\nThe EventNotifierType is defined in[8.59](/\u00A7_Ref34744539).\n\n\n\n\nReferences\n\n\n\nHasComponent\n0..*\n\nHasComponent References identify the DataVariables, the Methods and Objects contained in the Object.\nHasProperty\n0..*\n\nHasProperty References identify the Properties of the Object.\nHasModellingRule\n0..1\n\nObjects can point to at most one ModellingRule Object using a HasModellingRule Reference(see[6.4.4](/\u00A7_Ref128179460) for details on ModellingRules).\nHasTypeDefinition\n1\n\nThe HasTypeDefinition Reference points to the type definition of the Object. Each Object shall have exactly one type definition and therefore be the SourceNode of exactly one HasTypeDefinition Reference pointing to an ObjectType. See[4.6](/\u00A7_Ref115168300) for a description of type definitions.\nHasEventSource\n0..*\n\nThe HasEventSource Reference points to event sources of the Object. References of this type can only be used for Objects having their \u0022SubscribeToEvents\u0022 bit set in the EventNotifier Attribute. See[7.17](/\u00A7_Ref445827938) for details.\nHasNotifier\n0..*\n\nThe HasNotifier Reference points to notifiers of the Object."
    },
    {
      "Id": "d9cef564-f1e7-4dca-ad85-1f3e5dea4498",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.1 Object NodeClass\nCaption: Table 11 - Object NodeClass\n---\n",
      "Content": "Object. References of this type can only be used for Objects having their \u0022SubscribeToEvents\u0022 bit set in the EventNotifier Attribute. See[7.18](/\u00A7_Ref135713552) for details.\nOrganizes\n0..*\n\nThis Reference should be used only for Objects of the ObjectType FolderType(see[5.5.3](/\u00A7_Ref131474245)).\n\u003Cother References\u003E\n0..*\n\nObjects may contain other References.\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node has changed.\nIcon\nO\nImage\nThe Icon Property provides an image that can be used by Clients when displaying the Node. It is expected that the Icon Property contains a relatively small image."
    },
    {
      "Id": "e50c27fa-05ab-444b-abaa-76c7ad4635ee",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.1 Object NodeClass\n---\n",
      "Content": "The Object NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037).\nThe mandatory EventNotifier Attribute identifies whether the Object can be used to subscribe to Events or to read and write the history of the Events.\nThe Object NodeClass uses the HasComponent Reference to define the DataVariables, Objects and Methods of an Object.\nIt uses the HasProperty Reference to define the Properties of an Object. The Property NodeVersion is used to indicate the version of the Object. The Property Icon provides an icon of the Object. There are no additional Properties defined for Objects in this document. Additional parts of this series of standards may define additional Properties for Objects.\nTo specify its ModellingRule, an Object can use at most one HasModellingRule Reference pointing to a ModellingRule Object. ModellingRules are defined in[6.4.4](/\u00A7_Ref128179460).\nHasNotifier and HasEventSource References are used to provide information about eventing and can only be applied to Objects used as event notifiers. Details are defined in[7.16](/\u00A7_Ref135713256) and[7.18](/\u00A7_Ref135713552).\nThe HasTypeDefinition Reference points to the ObjectType used as type definition of the Object.\nObjects may use any additional References to define relationships to other Nodes. No restrictions are placed on the types of References used or on the NodeClasses of the Nodes that may be referenced. However, restrictions may be defined by the ReferenceType excluding its use for Objects. Standard ReferenceTypes are described in Clause[7](/\u00A7_Ref192918241).\nIf the Object is used as an InstanceDeclaration(see[4.6](/\u00A7_Ref131564903)"
    },
    {
      "Id": "743cbe20-0354-4424-85fb-53446db4fe4b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.1 Object NodeClass\n---\n",
      "Content": ") then all Nodes referenced with forward hierarchical References direction shall have unique BrowseNames in the context of this Object.\nIf the Object is created based on an InstanceDeclaration then it shall have the same BrowseName as its InstanceDeclaration."
    },
    {
      "Id": "9490e4d8-2b61-490d-9141-7805c39e6553",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5 Objects\n---\n",
      "Content": "5.5.2 ObjectType NodeClass"
    },
    {
      "Id": "88afd0ab-fbaf-40bf-9c2c-3932936d66dd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.2 ObjectType NodeClass\n---\n",
      "Content": "ObjectTypes provide definitions for Objects. ObjectTypes are defined using the ObjectType NodeClass, which is specified in[Table 12](/\u00A7_Ref114303399).\nTable 12 - ObjectType NodeClass"
    },
    {
      "Id": "d197d05a-e60c-4b0a-b45a-2962823492bf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.2 ObjectType NodeClass\nCaption: Table 12 - ObjectType NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nIsAbstract\nM\nBoolean\nA boolean Attribute with the following values:\nTRUE it is an abstract ObjectType, i.e. no Objects of this type shall exist, only Objects of its subtypes.\nFALSE it is not an abstract ObjectType, i.e. Objects of this type can exist.\n\n\n\n\nReferences\n\n\n\nHasComponent\n0..*\n\nHasComponent References identify the DataVariables, the Methods, and Objects contained in the ObjectType.\nIf and how the referenced Nodes are instantiated when an Object of this type is instantiated, is specified in[6.4](/\u00A7_Ref128009730).\nHasProperty\n0..*\n\nHasProperty References identify the Properties of the ObjectType. If and how the Properties are instantiated when an Object of this type is instantiated, is specified in[6.4](/\u00A7_Ref128009730).\nHasSubtype\n0..*\n\nHasSubtype References identify ObjectTypes that are subtypes of this type. The inverse Reference identifies the parent type of this type.\nGeneratesEvent\n0..*\n\nGeneratesEvent References identify the type of Events instances of this type may generate.\n\u003Cother References\u003E\n0..*\n\nObjectTypes may contain other References that can be instantiated by Objects defined by this ObjectType.\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference"
    },
    {
      "Id": "c50632f6-7b62-45f8-a154-390231f67b5c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.2 ObjectType NodeClass\nCaption: Table 12 - ObjectType NodeClass\n---\n",
      "Content": "Reference is added or deleted to the Node the Property belongs to. Attribute value changes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node has changed.\nIcon\nO\nImage\nThe Icon Property provides an image that can be used by Clients when displaying the Node. It is expected that the Icon Property contains a relatively small image.\nDefaultInstanceBrowseName\nO\nQualifiedName\nAllows the definition of BrowseName on an ObjectType that all instances should use by default.\nThis Property has no ModellingRule. It shall only be on the type Node."
    },
    {
      "Id": "e48b94d1-ef72-4e55-b5ab-5eec3f4a436c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.2 ObjectType NodeClass\n---\n",
      "Content": "The ObjectType NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037). The additional IsAbstract Attribute indicates if the ObjectType is abstract or not.\nThe ObjectType NodeClass uses the HasComponent References to define the DataVariables, Objects, and Methods for it.\nThe HasProperty Reference is used to identify the Properties. The Property NodeVersion is used to indicate the version of the ObjectType. The Property Icon provides an icon of the ObjectType. There are no additional Properties defined for ObjectTypes in this document. Additional parts of this series of standards may define additional Properties for ObjectTypes.\nHasSubtype References are used to subtype ObjectTypes. ObjectType subtypes inherit the general semantics from the parent type. The general rules for subtyping apply as defined in Clause[6](/\u00A7_Ref128473535). It is not required to provide the HasSubtype Reference for the supertype, but it is required that the subtype provides the inverse Reference to its supertype.\nGeneratesEvent References identify the type of Events that instances of the ObjectType may generate. These Objects may be the source of an Event of the specified type or one of its subtypes. Servers should make GeneratesEvent References bidirectional References. However, it is allowed to be unidirectional when the Server is not able to expose the inverse direction pointing from the EventType to each ObjectType supporting the EventType. Note that the EventNotifier Attribute of an Object and the GeneratesEvent References of its ObjectType are completely unrelated. Objects that can generate Events might not be used as Objects to which Clients subscribe to get the corresponding Event notifications.\nGeneratesEvent References are optional, i.e. Objects may generate Events of an EventType that is not exposed by its ObjectType.\nObjectTypes may use any additional References to define relationships to other"
    },
    {
      "Id": "350a6ed3-c6ed-48e5-9251-3418f561d4f0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.2 ObjectType NodeClass\n---\n",
      "Content": "to define relationships to other Nodes. No restrictions are placed on the types of References used or on the NodeClasses of the Nodes that may be referenced. However, restrictions may be defined by the ReferenceType excluding its use for ObjectTypes. Standard ReferenceTypes are described in Clause[7](/\u00A7_Ref192918283).\nAll Nodes referenced with forward hierarchical References shall have unique BrowseNames in the context of an ObjectType(see[4.6](/\u00A7_Ref131564903))."
    },
    {
      "Id": "408835fd-fda8-40ae-9425-a343f67c9fcf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5 Objects\n---\n",
      "Content": "5.5.3 Standard ObjectType FolderType"
    },
    {
      "Id": "2ab2cab2-92fc-4ec7-838c-f9f9e1a9dc26",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.3 Standard ObjectType FolderType\n---\n",
      "Content": "The ObjectType FolderType is formally defined in[OPC 10000-5](/\u00A7UAPart5). Its purpose is to provide Objects that have no other semantic than organizing of the AddressSpace. A special ReferenceType is introduced for those Folder Objects, the Organizes ReferenceType. The SourceNode of such a Reference should always be a View or an Object of the ObjectType FolderType; the TargetNode can be of any NodeClass. Organizes References can be used in any combination with HasChild References( HasComponent, HasProperty, etc.; see[7.5](/\u00A7_Ref131476242)) and do not prevent loops. Thus, they can be used to span multiple hierarchies."
    },
    {
      "Id": "1fc00852-9ce8-4a75-96b2-9b40b3089010",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5 Objects\n---\n",
      "Content": "5.5.4 Client-side creation of Objects of an ObjectType"
    },
    {
      "Id": "a6cfd665-2950-4ffa-bafa-d50d1ea48bc5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.5.4 Client-side creation of Objects of an ObjectType\n---\n",
      "Content": "Objects are always based on an ObjectType, i.e. they have a HasTypeDefinition Reference pointing to its ObjectType.\nClients can create Objects using the AddNodes Service defined in[OPC 10000-4](/\u00A7UAPart4). The Service requires specifying the TypeDefinitionNode of the Object. An Object created by the AddNodes Service contains all components defined by its ObjectType dependent on the ModellingRules specified for the components. However, the Server may add additional components and References to the Object and its components that are not defined by the ObjectType. This behaviour is Server dependent. The ObjectType only specifies the minimum set of components that shall exist for each Object of an ObjectType.\nIn addition to the AddNodes Service ObjectTypes may have a special Method with the BrowseName\u0022 Create\u0022. This Method is used to create an Object of this ObjectType. This Method may be useful for the creation of Objects where the semantic of the creation should differ from the default behaviour expected in the context of the AddNodes Service. For example, the values should directly differ from the default values or additional Objects should be added, etc. The input and output arguments of this Method depend on the ObjectType; the only commonality is the BrowseName identifying that this Method will create an Object based on the ObjectType. Servers should not provide a Method on an ObjectType with the BrowseName\u0022 Create\u0022 for any other purpose than creating Objects of the ObjectType."
    },
    {
      "Id": "b7008575-f8e3-4491-bdb6-662773048a52",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.6 Variables"
    },
    {
      "Id": "f63fd2a4-dcef-4126-bbdf-70b7b0a37014",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6 Variables\n---\n",
      "Content": "5.6.1 General"
    },
    {
      "Id": "56910b96-c8fd-4d7e-ad71-918096afa4fb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.1 General\n---\n",
      "Content": "Two types of Variables are defined, Properties and DataVariables. Although they differ in the way they are used as described in[4.5](/\u00A7_Ref127693305) and have different constraints described in the remainder of[5.6](/\u00A7_Ref389578374) they use the same NodeClass described in[5.6.2](/\u00A7_Ref127693446). The constraints of Properties based on this NodeClass are defined in[5.6.3](/\u00A7_Ref127693460), the constraints of DataVariables in[5.6.4](/\u00A7_Ref127693482)."
    },
    {
      "Id": "ee9a3d05-058e-4cf0-b094-193a406bbf24",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6 Variables\n---\n",
      "Content": "5.6.2 Variable NodeClass"
    },
    {
      "Id": "bb597e0d-6251-41a6-9c69-a9db7899e3fc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\n---\n",
      "Content": "Variables are used to represent values which may be simple or complex. Variables are defined by VariableTypes, as specified in[5.6.5](/\u00A7_Ref115150572).\nVariables are always defined as Properties or DataVariables of other Nodes in the AddressSpace. They are never defined by themselves. A Variable is always part of at least one other Node, but may be related to any number of other Nodes. Variables are defined using the Variable NodeClass, specified in[Table 13](/\u00A7_Ref127836744).\nTable 13 - Variable NodeClass"
    },
    {
      "Id": "ecddc885-1feb-48ed-8707-a4dc34a9762a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nValue\nM\nDefined by the DataType Attribute\nThe most recent value of the Variable that the Server has. Its data type is defined by the DataType Attribute. It is the only Attribute that does not have a data type associated with it. This allows all Variables to have a value defined by the same Value Attribute.\nDataType\nM\nNodeId\nNodeId of the DataType definition for the Value Attribute. The NodeId shall be a valid NodeId of a DataType and shall not be null. Standard DataTypes are defined in Clause[8](/\u00A7_Ref153882735).\nValueRank\nM\nInt32\nThis Attribute indicates whether the Value Attribute of the Variable is an array and how many dimensions the array has.\nIt may have the following values:\nn \u003E 1: the Value is an array with the specified number of dimensions.\nOneDimension (1): The value is an array with one dimension.\nOneOrMoreDimensions (0): The value is an array with one or more dimensions.\nScalar (\u22121): The value is not an array.\nAny (\u22122): The value can be a scalar or an array with any number of dimensions.\nScalarOrOneDimension (\u22123): The value can be a scalar or a one dimensional array.\nAll DataTypes are considered to be scalar, even if they have array-like semantics like ByteString and String.\nArrayDimensions\nO\nUInt32[]\nThis Attribute specifies the maximum supported length of each dimension. If the maximum is unknown the value shall be 0."
    },
    {
      "Id": "0de2e9aa-9423-41a6-8be6-9c3d16b64579",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": "The number of elements shall be equal to the number of dimensions of the Value. This Attribute shall be null if the Value is not an array.\n\nFor example, if a Variable is defined by the following C array:\nInt32 myArray[346];\nthen this Variable\u0027s DataType would be set to Int32, and the Variable\u0027s ValueRank has the value 1. The ArrayDimensions is an array with a length of one where the element has the value 346.\n\nRegardless of the number of dimensions, the maximum number of elements of an array transferred on the wire is 2147483647 (max Int32).\nAccessLevel\nM\nAccessLevelType\nThe AccessLevel Attribute is used to indicate how the Value of a Variable can be accessed (read/write) and if it contains current and/or historic data. The AccessLevel does not take any user access rights into account, i.e. although the Variable is writeable this may be restricted to a certain user / user group.\nThe AccessLevelType is defined in[8.57](/\u00A7_Ref497896703).\n\nUserAccessLevel\nM\nAccessLevelType\nThe UserAccessLevel Attribute is used to indicate how the Value of a Variable can be accessed (read/write) and if it contains current or historic data taking user access rights into account.\nThe AccessLevelType is defined in[8.57](/\u00A7_Ref497896712).\n\nMinimumSamplingInterval\nO\nDuration\nThe MinimumSamplingInterval Attribute indicates how \u0022current\u0022 the Value of the Variable will be kept. It specifies (in milliseconds) how fast the Server can reasonably sample the value for changes (see[OPC 10000-4](/\u00A7UAPart4)"
    },
    {
      "Id": "94de0442-ef20-4eab-ab03-7dc02acce3d7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": "for a detailed description of sampling interval).\nA MinimumSamplingInterval of 0 indicates that the Server is to monitor the item continuously. A MinimumSamplingInterval of \u22121 means indeterminate.\nHistorizing\nM\nBoolean\nThe Historizing Attribute indicates whether the Server is actively collecting data for the history of the Variable. This differs from the AccessLevel Attribute which identifies if the Variable has any historical data. A value of TRUE indicates that the Server is actively collecting data. A value of FALSE indicates the Server is not actively collecting data. Default value is FALSE.\nAccessLevelEx\nO\nAccessLevelExType\n\nThe AccessLevelEx Attribute is used to indicate how the Value of a Variable can be accessed (read/write), if it contains current and/or historic data and its atomicity. The AccessLevelEx does not take any user access rights into account, i.e. although the Variable is writeable this may be restricted to a certain user / user group. The AccessLevelEx is an extended version of the AccessLevel attribute and as such contains the 8 bits of the AccessLevel attribute as the first 8 bits.\nThe AccessLevelEx is a 32-bit unsigned integer with the structure defined in the[8.58](/\u00A7_Ref497896761).\n\nThis Attribute is made mandatory in Profiles starting with version 1.04. Prior to version 1.04 if this Attribute is not provided the information provided by these additional Fields is unknown.\n\n\n\n\nReferences\n\n\n\nHasModellingRule\n0..1\n\nVariables can point to at most one ModellingRule Object using a HasModellingRule Reference(see[6.4.4](/\u00A7_Ref128179460) for details on ModellingRules).\nHasProperty"
    },
    {
      "Id": "de6c35d2-0620-4f67-8411-0278ee0ba26e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": ").\nHasProperty\n0..*\n\nHasProperty References are used to identify the Properties of a DataVariable.\nProperties are not allowed to be the SourceNode of HasProperty References.\nHasComponent\n0..*\n\nHasComponent References are used by complex DataVariables to identify their composed DataVariables.\nProperties are not allowed to use this Reference.\nHasTypeDefinition\n1\n\nThe HasTypeDefinition Reference points to the type definition of the Variable. Each Variable shall have exactly one type definition and therefore be the SourceNode of exactly one HasTypeDefinition Reference pointing to a VariableType. See[4.6](/\u00A7_Ref115168300) for a description of type definitions.\n\u003Cother References\u003E\n0..*\n\nData Variables may be the SourceNode of any other References.\nProperties may only be the SourceNode of any NonHierarchical Reference.\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a DataVariable. It does not apply to Properties.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes except for the DataType, ValueRank and ArrayDimensions Attributes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node has changed.\nAlthough the relationship of a Variable to its DataType, ValueRank and ArrayDimensions is not modelled using References, changes to the DataType, ValueRank or ArrayDimensions Attributes of a Variable lead to an update of the NodeVersion Property.\nLocalTime\nO\nTimeZoneDataType\nThe LocalTime Property is only used for DataVariables. It does not apply to Properties.\nThis"
    },
    {
      "Id": "05319bfa-fa0d-45bf-a97d-27f7fbf026fa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": "Properties.\nThis Property is a structure containing the Offset and the DaylightSavingInOffset flag. The Offset specifies the time difference (in minutes) between the SourceTimestamp (UTC) associated with the value and the time at the location in which the value was obtained. The SourceTimestamp is defined in[OPC 10000-4](/\u00A7UAPart4).\nIf DaylightSavingInOffset is TRUE, then Standard/Daylight savings time (DST) at the originating location is in effect and Offset includes the DST correction. If FALSE then the Offset does not include DST correction and DST may or may not have been in effect.\nAllowNulls\nO\nBoolean\nThe AllowNulls Property is only used for DataVariables. It does not apply to Properties.\nThis Property specifies if a null value is allowed for the Value Attribute of a DataVariable which has a nullable DataType. If it is set to TRUE, the Server may return null values and accept writing of null values. If it is set to FALSE, the Server shall never return a null value and shall reject any request writing a null value.\nIf this Property is not provided, it is Server-specific if null values are allowed or not for nullable DataTypes.\nValueAsText\nO\nLocalizedText\nIt is used for DataVariables with a finite set of LocalizedTexts associated with its value. For example any DataVariables having an Enumeration DataType.\nThis optional Property provides the localized text representation of the value. It can be used by Clients only interested in displaying the text to subscribe to the Property instead of the value attribute.\nMaxStringLength\nO\nUInt32\nOnly used for DataVariables having a String DataType or a LocalizedText DataType (the text field).\nThis optional Property"
    },
    {
      "Id": "eb954797-0b00-4b16-b6fc-206a6def8feb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": ".\nThis optional Property indicates the maximum number of bytes supported by the DataVariable.\nIf the value is an array, this field applies to each element of the array.\nMaxCharacters\nO\nUInt32\nOnly used for DataVariables having a String DataType or a LocalizedText DataType (the text field)\nThis optional Property indicates the maximum number of Unicode characters supported by the DataVariable.\nMaxByteStringLength\nO\nUInt32\nOnly used for DataVariables having a ByteString DataType.\nThis optional Property indicates the maximum number of bytes supported by the DataVariable.\nMaxArrayLength\nO\nUInt32\nOnly used for DataVariables having its ValueRank Attribute not set to scalar.\nThis optional Property indicates the maximum length of an array supported by the DataVariable. In a multidimensional array it indicates the overall length. For example, a three-dimensional array of 2 x 3 x 10 has the array length of 60.\nNOTE In order to expose the length of an array of bytes do not use the DataType ByteString but an array of the DataType Byte. In that case the MaxArrayLength applies.\nEngineeringUnits\nO\nEUInformation\nOnly used for DataVariables having a Number DataType (or a subtype of Number) or a Structure DataType where each field has a DataType of Number (or a subtype of Number) and all share the same EngineeringUnit.\nThis optional Property indicates the engineering units for the value of the DataVariable(e.g. hertz or seconds). Details about the Property and what engineering units should be used are defined in[OPC 10000-8](/\u00A7UAPart8). The DataType EUInformation is also defined in[OPC 10000-8](/\u00A7UAPart8)"
    },
    {
      "Id": "0953c230-d58c-46da-a494-33de93dbefbb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\nCaption: Table 13 - Variable NodeClass\n---\n",
      "Content": ".\nCurrencyUnit\nO\nCurrencyUnitType\nOnly used for DataVariables having a subtype of Number DataType.\nIts contents are based on ISO 4217.\nSee[https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)\nFixedSizeArray\nO\nBoolean\nOnly used for DataVariables having its ValueRank Attribute not set to scalar.\nThis optional Property indicates if the array is a fixed length or a dynamic length. If it is set to TRUE, the array size is fixed to the size defined by the ArrayDimensions Attribute. If it is set to FALSE, the array\u0027s dimensions are dynamic.\nIf this Property is TRUE the optional ArrayDimensions Attribute shall also be provided and shall have a dimension length greater than 0 for each defined dimension.\nIf this Property is not provided, it is Server-specific if the array dimensions are fixed or dynamic."
    },
    {
      "Id": "4ed49eb9-281b-4262-a130-00d03bbcdc80",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\n---\n",
      "Content": "The Variable NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037).\nThe Variable NodeClass also defines a set of Attributes that describe the Variable\u0027s Runtime value. The Value Attribute represents the Variable value. The DataType, ValueRank and ArrayDimensions Attributes provide the capability to describe simple and complex values.\nTo maximize interoperability with Clients, when a Server instantiates Variable Nodes the DataType, ValueRank and ArrayDimension Attributes should be set to the most restrictive values for the instance. For example, if a Variable Node will produce a 1-dimension array of floats with a maximum array length of 10, set DataType = Float, ValueRank = 1, ArrayDimensions = [10]. If the array length has no fixed upper limit, then set ArrayDimensions = [0].\nThe AccessLevel Attribute indicates the accessibility of the Value of a Variable not taking user access rights into account. If the OPC UA Server does not have the ability to get the AccessLevel information from the underlying system then it should state that it is readable and writeable. If a read or write operation is called on the Variable then the Server should transfer this request and return the corresponding StatusCode even if such a request is rejected. StatusCodes are defined in[OPC 10000-4](/\u00A7UAPart4).\nThe SemanticChange flag of the AccessLevel Attribute is used for Properties that may change and define semantic aspects of the parent Node. For example, the EngineeringUnits Property describes the semantic of a DataVariable, whereas the Icon Property does not. In this example, if the EngineeringUnits Property may change while the Server is running, the SemanticChange flag shall be set for it.\nServers that support Event Subscriptions shall generate a SemanticChangeEvent whenever a Property with SemanticChange"
    },
    {
      "Id": "a008ae2b-a944-49ba-a149-7e8fdd7d91c5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\n---\n",
      "Content": "Property with SemanticChange flag set changes.\nIf a Variable having a Property with SemanticChange flag set is used in a Subscription and the Property value changes, then the SemanticsChanged bit of the StatusCode shall be set as defined in[OPC 10000-4](/\u00A7UAPart4). Clients subscribing to a Variable should look at the StatusCode to identify if the semantic has changed and retrieve the relevant Properties before processing the value returned from the Subscription.\nThe UserAccessLevel Attribute indicates the accessibility of the Value of a Variable taking user access rights into account. If the OPC UA Server does not have the ability to get any user access rights related information from the underlying system then it should use the same bit mask as used in the AccessLevel Attribute. The UserAccessLevel Attribute can restrict the accessibility indicated by the AccessLevel Attribute, but not exceed it. Clients should not assume access rights based on the UserAccessLevel Attribute. For example it is possible that the Server returns an error due to some server specific change which was not reflected in the state of this Attribute at the time the Client accessed the Variable.\nThe MinimumSamplingInterval Attribute specifies how fast the Server can reasonably sample the value for changes. The accuracy of this value (the ability of the Server to attain \u0022best case\u0022 performance) can be greatly affected by system load and other factors.\nThe Historizing Attribute indicates whether the Server is actively collecting data for the history of the Variable. See[OPC 10000-11](/\u00A7UAPart11) for details on historizing Variables.\nClients may read or write Variable values, or monitor them for value changes, as specified in[OPC 10000-4](/\u00A7UAPart4).[OPC 10000-8](/\u00A7UAPart8)"
    },
    {
      "Id": "c05d9e57-273f-4d59-a02b-ed63da088b0e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.2 Variable NodeClass\n---\n",
      "Content": "defines additional rules when using the Services for automation data.\nTo specify its ModellingRule, a Variable can use at most one HasModellingRule Reference pointing to a ModellingRule Object. ModellingRules are defined in[6.4.4](/\u00A7_Ref128179460).\nIf the Variable is created based on an InstanceDeclaration(see[4.6](/\u00A7_Ref131564903)) it shall have the same BrowseName as its InstanceDeclaration.\nThe other References are described separately for Properties and DataVariables in the remainder of[5.6](/\u00A7_Ref389578559)."
    },
    {
      "Id": "569fe796-0099-43fe-9ea6-9ec8a26ed43f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6 Variables\n---\n",
      "Content": "5.6.3 Properties"
    },
    {
      "Id": "b45303cd-3dda-4ca8-bbf9-adf5195fb9dd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.3 Properties\n---\n",
      "Content": "Properties are used to define the characteristics of Nodes. Properties are defined using the Variable NodeClass, specified in[Table 13](/\u00A7_Ref127836744). However, they restrict their use.\nProperties are the leaf of any hierarchy; therefore they shall not be the SourceNode of any hierarchical References. This includes the HasComponent or HasProperty Reference, that is, Properties do not contain Properties and cannot expose their complex structure. However, they may be the SourceNode of any NonHierarchical References.\nThe HasTypeDefinition Reference points to the VariableType of the Property. Since Properties are uniquely identified by their BrowseName, all Properties shall point to the PropertyType defined in[OPC 10000-5](/\u00A7UAPart5).\nProperties shall always be defined in the context of another Node and shall be the TargetNode of at least one HasProperty Reference. To distinguish them from DataVariables, they shall not be the TargetNode of any HasComponent Reference. Thus, a HasProperty Reference pointing to a Variable Node defines this Node as a Property.\nThe BrowseName of a Property is always unique in the context of a Node. It is not permitted for a Node to refer to two Variables using HasProperty References having the same BrowseName."
    },
    {
      "Id": "f5a427d9-c3e3-4ad3-a6ec-d733649416bb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6 Variables\n---\n",
      "Content": "5.6.4 DataVariable"
    },
    {
      "Id": "51ca9593-8ccc-447a-8b91-edb9d4cd77eb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.4 DataVariable\n---\n",
      "Content": "DataVariables represent the content of an Object. DataVariables are defined using the Variable NodeClass, specified in[Table 13](/\u00A7_Ref127836744).\nDataVariables identify their Properties using HasProperty References. Complex DataVariables use HasComponent References to expose their component DataVariables.\nThe Property NodeVersion indicates the version of the DataVariable.\nThe Property LocalTime indicates the difference between the SourceTimestamp of the value and the standard time at the location in which the value was obtained.\nThe Property AllowNulls indicates if null values are allowed for the Value Attribute.\nThe Property ValueAsText provides a localized text representation for enumeration values.\nThe Property MaxStringLength indicates the maximum number of bytes of a String or the text field of a LocalizedText value. If a Server does not impose a maximum number of bytes or is not able to determine the maximum number of bytes this Property shall not be provided. If this Property is provided, then the MaxCharacters Property shall not be provided.\nThe Property MaxCharacters indicates the maximum number of Unicode characters of a String or the text field of a LocalizedText value. If a Server does not impose a maximum number of Unicode characters or is not able to determine the maximum number of Unicode characters this Property shall not be provided. If this Property is provided then the MaxStringLength Property shall not be provided.\nThe Property MaxByteStringLength indicates the maximum number of bytes of a ByteString value. If a Server does not impose a maximum number of bytes or is not able to determine the maximum number of bytes this Property shall not be provided.\nThe Property MaxArrayLength indicates the maximum allowed array length of the value.\nThe Property EngineeringUnits indicates the engineering units of the value. There are no additional Properties defined for DataVariables"
    },
    {
      "Id": "1461b121-4c67-4834-83fa-80bbffec314a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.4 DataVariable\n---\n",
      "Content": "Properties defined for DataVariables in this part of this document. Additional parts of this series of standards may define additional Properties for DataVariables.[OPC 10000-8](/\u00A7UAPart8) defines a set of Properties that can be used for DataVariables.\nThe Property CurrencyUnit represents the currency of the value. The information in the structure is designed to be suited for human users and for automated systems.\nDataVariables may use additional References to define relationships to other Nodes. No restrictions are placed on the types of References used or on the NodeClasses of the Nodes that may be referenced. However, restrictions may be defined by the ReferenceType excluding its use for DataVariables. Standard ReferenceTypes are described in Clause[7](/\u00A7_Ref192918315).\nA DataVariable is intended to be defined in the context of an Object. However, complex DataVariables may expose other DataVariables, and ObjectTypes and complex VariableTypes may also contain DataVariables. Therefore each DataVariable shall be the TargetNode of at least one HasComponent Reference coming from an Object, an ObjectType, a DataVariable or a VariableType. DataVariables shall not be the TargetNode of any HasProperty References. Therefore, a HasComponent Reference pointing to a Variable Node identifies it as a DataVariable.\nThe HasTypeDefinition Reference points to the VariableType used as type definition of the DataVariable.\nIf the DataVariable is used as InstanceDeclaration(see[4.6](/\u00A7_Ref131564903)) all Nodes referenced with forward hierarchical References shall have unique BrowseNames in the context of this DataVariable."
    },
    {
      "Id": "adf9ac21-993f-4547-b362-a5f82efef57e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6 Variables\n---\n",
      "Content": "5.6.5 VariableType NodeClass"
    },
    {
      "Id": "9080c43d-598c-4cb9-b7dd-f91007de6161",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.5 VariableType NodeClass\n---\n",
      "Content": "VariableTypes are used to provide type definitions for Variables. VariableTypes are defined using the VariableType NodeClass, as specified in[Table 14](/\u00A7_Ref115253873).\nTable 14 - VariableType NodeClass"
    },
    {
      "Id": "1b450263-e9c3-460c-9a15-79d01dc23443",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.5 VariableType NodeClass\nCaption: Table 14 - VariableType NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037)\nValue\nO\nDefined by the DataType attribute\nThe default Value for instances of this type.\nDataType\nM\nNodeId\nNodeId of the data type definition for instances of this type. The NodeId shall be a valid NodeId of a DataType and shall not be null. Standard DataTypes are defined in Clause[7.23](/\u00A7_Ref132513335)[8](/\u00A7_Ref153882758).\nValueRank\nM\nInt32\nThis Attribute indicates whether the Value Attribute of the VariableType is an array and how many dimensions the array has.\nIt may have the following values:\nn \u003E 1: the Value is an array with the specified number of dimensions.\nOneDimension (1): The value is an array with one dimension.\nOneOrMoreDimensions (0): The value is an array with one or more dimensions.\nScalar (\u22121): The value is not an array.\nAny (\u22122): The value can be a scalar or an array with any number of dimensions.\nScalarOrOneDimension (\u22123): The value can be a scalar or a one dimensional array.\nNOTE All DataTypes are considered to be scalar, even if they have array-like semantics like ByteString and String.\nArrayDimensions\nO\nUInt32[]\nThis Attribute specifies the length of each dimension for an array value. The Attribute specifies the maximum supported length of each dimension. If the maximum is unknown the value is 0.\nThe number of elements shall be equal to the value of the ValueRank Attribute. This"
    },
    {
      "Id": "8db7e512-70f7-4f24-9d44-80de064e6198",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.5 VariableType NodeClass\nCaption: Table 14 - VariableType NodeClass\n---\n",
      "Content": "ValueRank Attribute. This Attribute shall be null if ValueRank \u2264 0.\nFor example, if a VariableType is defined by the following C array:\nInt32 myArray[346];\nthen this VariableType\u0027s DataType would point to an Int32, the VariableType\u0027s ValueRank has the value 1 and the ArrayDimensions is an array with one entry having the value 346.\nIsAbstract\nM\nBoolean\nA boolean Attribute with the following values:\nTRUE it is an abstract VariableType, i.e. no Variable of this type shall exist, only of its subtypes.\nFALSE it is not an abstract VariableType, i.e. Variables of this type can exist.\n\n\n\n\nReferences\n\n\n\nHasProperty\n0..*\n\nHasProperty References are used to identify the Properties of the VariableType. The referenced Nodes may be instantiated by the instances of this type, depending on the ModellingRules defined in[6.4.4](/\u00A7_Ref128179460).\nHasComponent\n0..*\n\nHasComponent References are used for complex VariableTypes to identify their containing DataVariables. Complex VariableTypes can only be used for DataVariables. The referenced Nodes may be instantiated by the instances of this type, depending on the ModellingRules defined in[6.4.4](/\u00A7_Ref128179460).\nHasSubtype\n0..*\n\nHasSubtype References identify VariableTypes that are subtypes of this type. The inverse Reference identifies the parent type of this type.\nGeneratesEvent\n0..*\n\nGeneratesEvent References identify the type of Events instances of this type may generate.\n\u003Cother References\u003E\n0..*\n\nVariableTypes may contain other"
    },
    {
      "Id": "05695869-078d-4ab7-b63e-a6288dfc4791",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.5 VariableType NodeClass\nCaption: Table 14 - VariableType NodeClass\n---\n",
      "Content": "VariableTypes may contain other References that can be instantiated by Variables defined by this VariableType. ModellingRules are defined in[6.4.4](/\u00A7_Ref128179460).\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes except for the DataType, ValueRank and ArrayDimensions Attributes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node has changed.\nAlthough the relationship of a VariableType to its DataType, ValueRank and ArrayDimensions is not modelled using References, changes to the DataType, ValueRank or ArrayDimensions Attributes of a VariableType lead to an update of the NodeVersion Property."
    },
    {
      "Id": "2a8f4746-530b-41e7-94b7-7c8c279ca1fd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.5 VariableType NodeClass\n---\n",
      "Content": "The VariableType NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037). The VariableType NodeClass also defines a set of Attributes that describe the default or initial value of its instance Variables. The Value Attribute represents the default value. The DataType, ValueRank and ArrayDimensions Attributes provide the capability to describe simple and complex values. The IsAbstract Attribute defines if the type can be directly instantiated.\nThe VariableType NodeClass uses HasProperty References to define the Properties and HasComponent References to define DataVariables. Whether they are instantiated depends on the ModellingRules defined in[6.4.4](/\u00A7_Ref128179460).\nThe Property NodeVersion indicates the version of the VariableType. There are no additional Properties defined for VariableTypes in this document. Additional parts of this series of standards may define additional Properties for VariableTypes.[OPC 10000-8](/\u00A7UAPart8) defines a set of Properties that can be used for VariableTypes.\nHasSubtype References are used to subtype VariableTypes. VariableType subtypes inherit the general semantics from the parent type. The general rules for subtyping are defined in Clause[6](/\u00A7_Ref128473535). It is not required to provide the HasSubtype Reference for the supertype, but it is required that the subtype provides the inverse Reference to its supertype.\nGeneratesEvent References identify that Variables of the VariableType may be the source of an Event of the specified EventType or one of its subtypes. Servers should make GeneratesEvent References bidirectional References. However, it is allowed to be unidirectional when the Server is not able to expose the inverse direction pointing from the EventType to each VariableType supporting the EventType.\nGeneratesEvent References"
    },
    {
      "Id": "d2c1de67-b825-4a8d-9db1-c4a051c618c1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.5 VariableType NodeClass\n---\n",
      "Content": "GeneratesEvent References are optional, i.e. Variables may generate Events of an EventType that is not exposed by its VariableType.\nVariableTypes may use any additional References to define relationships to other Nodes. No restrictions are placed on the types of References used or on the NodeClasses of the Nodes that may be referenced. However, restrictions may be defined by the ReferenceType excluding its use for VariableTypes. Standard ReferenceTypes are described in Clause[7](/\u00A7_Ref192918334).\nAll Nodes referenced with forward hierarchical References shall have unique BrowseNames in the context of the VariableType(see[4.6](/\u00A7_Ref131564903))."
    },
    {
      "Id": "6426c45c-f5b0-416c-b27f-ef1481e6e6a8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6 Variables\n---\n",
      "Content": "5.6.6 Client-side creation of Variables of an VariableType"
    },
    {
      "Id": "7b9954a4-e56e-4206-af97-b5d2e25e1b8d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.6.6 Client-side creation of Variables of an VariableType\n---\n",
      "Content": "Variables are always based on a VariableType, i.e. they have a HasTypeDefinition Reference pointing to its VariableType.\nClients can create Variables using the AddNodes Service defined in[OPC 10000-4](/\u00A7UAPart4). The Service requires specifying the TypeDefinitionNode of the Variable. A Variable created by the AddNodes Service contains all components defined by its VariableType dependent on the ModellingRules specified for the components. However, the Server may add additional components and References to the Variable and its components that are not defined by the VariableType. This behaviour is Server dependent. The VariableType only specifies the minimum set of components that shall exist for each Variable of a VariableType."
    },
    {
      "Id": "a4a7786b-e9b9-47cd-b586-35100c955f3d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.7 Methods"
    },
    {
      "Id": "52aa04c3-c831-41bb-95b5-796a349c660e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7 Methods\n---\n",
      "Content": "5.7.1 Method NodeClass"
    },
    {
      "Id": "ebb3a232-5a54-44d5-897c-214839afb65f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\n---\n",
      "Content": "Methods define callable functions. Methods are invoked using the Call Service defined in[OPC 10000-4](/\u00A7UAPart4). Method invocations are not represented in the AddressSpace. Method invocations always run to completion and always return responses when complete. Methods are defined using the Method NodeClass, specified in[Table 15](/\u00A7_Ref115488487).\nTable 15 - Method NodeClass"
    },
    {
      "Id": "8b912822-8824-4e31-a7ec-b84ebe20925b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\nCaption: Table 15 - Method NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nExecutable\nM\nBoolean\nThe Executable Attribute indicates if the Method is currently executable (FALSE means not executable, TRUE means executable).\nThe Executable Attribute does not take any user access rights into account, i.e. although the Method is executable this may be restricted to a certain user / user group.\nUserExecutable\nM\nBoolean\nThe UserExecutable Attribute indicates if the Method is currently executable taking user access rights into account (FALSE means not executable, TRUE means executable).\n\n\n\n\nReferences\n\n\n\nHasProperty\n0..*\n\nHasProperty References identify the Properties for the Method.\nHasModellingRule\n0..1\n\nMethods can point to at most one ModellingRule Object using a HasModellingRule Reference(see[6.4.4](/\u00A7_Ref128179460) for details on ModellingRules).\nGeneratesEvent\n0..*\n\nGeneratesEvent References identify the type of Events that may be generated whenever the Method is called.\nAlwaysGeneratesEvent\n0..*\n\nAlwaysGeneratesEvent References identify the type of Events that shall be generated whenever the Method is called.\nHasArgumentDescription\n0..*\n\nThe HasArgumentDescription References are used to specify argument metadata. If the SourceNode of this Reference is defined on an InstanceDeclaration the TargetNode shall use the Mandatory ModellingRule.\n\u003Cother References\u003E\n0..*\n\nMethods may contain other References.\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe"
    },
    {
      "Id": "e5436306-ef6d-422a-a9b5-2b1173f4e34e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\nCaption: Table 15 - Method NodeClass\n---\n",
      "Content": "O\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node has changed.\nInputArguments\nO\nArgument[]\nThe InputArguments Property is used to specify the arguments that shall be used by a client when calling the Method.\nOutputArguments\nO\nArgument[]\nThe OutputArguments Property specifies the result returned from the Method call."
    },
    {
      "Id": "4ea59083-bb56-4053-b261-f8224676701e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\n---\n",
      "Content": "The Method NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037). The Method NodeClass defines no additional Attributes.\nThe Executable Attribute indicates whether the Method is executable, not taking user access rights into account. If the OPC UA Server cannot get the Executable information from the underlying system, it should state that it is executable. If a Method is called then the Server should transfer this request and return the corresponding StatusCode even if such a request is rejected. StatusCodes are defined in[OPC 10000-4](/\u00A7UAPart4).\nThe UserExecutable Attribute indicates whether the Method is executable, taking user access rights into account. If the OPC UA Server cannot get any user rights related information from the underlying system, it should use the same value as used in the Executable Attribute. The UserExecutable Attribute can be set to FALSE, even if the Executable Attribute is set to TRUE, but it shall be set to FALSE if the Executable Attribute is set to FALSE. Clients cannot assume a Method can be executed based on the UserExecutable Attribute. It is possible that the Server may return an access denied error due to some Server specific change which was not reflected in the state of this Attribute at the time the Client accessed it.\nProperties may be defined for Methods using HasProperty References. The Properties InputArguments and OutputArguments specify the input arguments and output arguments of the Method. Both contain an array of the DataType Argument as specified in[8.6](/\u00A7_Ref128132235). An empty array or a Property that is not provided indicates that there are no input arguments or output arguments for the Method.\nThe Property NodeVersion indicates the version of the Method. There are no additional Properties defined for Methods"
    },
    {
      "Id": "704b05f6-f830-4b45-8660-b305da124edd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\n---\n",
      "Content": "Properties defined for Methods in this document. Additional parts of this series of standards may define additional Properties for Methods.\nTo specify its ModellingRule, a Method can use at most one HasModellingRule Reference pointing to a ModellingRule Object. ModellingRules are defined in[6.4.4](/\u00A7_Ref128179460).\nGeneratesEvent References identify that Methods may generate an Event of the specified EventType or one of its subtypes for every call of the Method. A Server may generate one Event for each referenced EventType when a Method is successfully called.\nAlwaysGeneratesEvent References identify that Methods will generate an Event of the specified EventType or one of its subtypes for every call of the Method. A Server shall always generate one Event for each referenced EventType when a Method is successfully called.\nServers should make GeneratesEvent References bidirectional References. However, it is allowed to be unidirectional when the Server is not able to expose the inverse direction pointing from the EventType to each Method generating the EventType.\nGeneratesEvent References are optional, i.e. the call of a Method may produce Events of an EventType that is not referenced with a GeneratesEvent Reference by the Method.\nMethods may use additional References to define relationships to other Nodes. No restrictions are placed on the types of References used or on the NodeClasses of the Nodes that may be referenced. However, restrictions may be defined by the ReferenceType excluding its use for Methods. Standard ReferenceTypes are described in Clause[7](/\u00A7_Ref192918351).\nA Method shall always be the TargetNode of at least one HasComponent Reference. The SourceNode of these HasComponent References shall be an Object or an ObjectType. If a Method is called, then the NodeId of one of those Nodes shall be put into the Call Service defined in"
    },
    {
      "Id": "3dab6dda-1924-4eca-9f5f-a40b80526970",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\n---\n",
      "Content": "Service defined in[OPC 10000-4](/\u00A7UAPart4) as parameter to detect the context of the Method operation.\nIf the Method is used as InstanceDeclaration(see[4.6](/\u00A7_Ref131564903)) all Nodes referenced with forward hierarchical References shall have unique BrowseNames in the context of this Method.\nThe Variable referenced by a HasArgumentDescription ReferenceType shall use a BrowseName equal to the name of the Argument it describes. The Namespace of the BrowseName shall be ignored by a Client when performing an equality check with an Argument name. For each Argument there shall be at most one Variable referenced by a HasArgumentDescription ReferenceType. The Variable referenced by the HasArgumentDescription ReferenceType shall have the same DataType as the Argument\u0027s DataType.\nArgument names shall be unique within the scope of the Method.\nAn example use of the HasArgumentDescription Reference is illustrated in[Figure 16](/\u00A7_Ref525180799). In this example an ObjectType defines a Method which illustrates the following:\nOutput1 as a discrete output argument with a HasArgumentDescription Reference to a TwoStateDiscreteType Variable which provides descriptions of the states of the output argument.\nInput1 as a numeric input argument with a HasArgumentDescription Reference to a DataVariable Variable which provides the default value 42.\nInput2 as a numeric input argument with a HasArgumentDescription Reference to an AnalogItemType Variable which provides an engineering units range of 0 kPa to 100 kPa.\nInput3 as an optional discrete input argument with a HasOptionalInputArgumentDescription Reference to a TwoStateDiscreteType Variable which provides descriptions of the states of the input argument and a default value of TRUE.\nObject1 as an instance of MyObjectType with an instance specific HasArgumentDescription Reference"
    },
    {
      "Id": "0af12476-c1d2-44ec-96a4-8a7abfb0a875",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\n---\n",
      "Content": "HasArgumentDescription Reference to an instance specific AnalogItemType Variable which provides an instance specific engineering range of 0 kPa to 200 kPa and a default value of 75 kPa for the Input2 argument."
    },
    {
      "Id": "a21bf4d3-48eb-4b3f-9d55-ae14187b11e7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\nCaption: Figure 16 - Method Metadata Example\n---\n",
      "Content": "[image019.png](images/image019.png)"
    },
    {
      "Id": "5cb9184b-9cae-4441-8e00-e6f4244fe319",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.1 Method NodeClass\n---\n",
      "Content": "Figure 16 - Method Metadata Example"
    },
    {
      "Id": "ad9ca4a3-5cc9-4fc7-ae66-0421ad8e2ebf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7 Methods\n---\n",
      "Content": "5.7.2 HasArgumentDescription ReferenceType"
    },
    {
      "Id": "0d831b9b-cd51-48bd-afe9-f808ae15cf6e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.2 HasArgumentDescription ReferenceType\n---\n",
      "Content": "The HasArgumentDescription ReferenceType is a concrete ReferenceType that is a subtype of the HasComponent ReferenceType.\nThe semantic of the HasArgumentDescription ReferenceType- extends the semantic of the HasComponent ReferenceType to reference argument Metadata of a Method NodeClass.\nThe SourceNode of this ReferenceType shall be a Method and the TargetNode of this ReferenceType shall be a Variable."
    },
    {
      "Id": "6cbc90f9-8b5e-449c-be97-ab51e9856c57",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7 Methods\n---\n",
      "Content": "5.7.3 HasOptionalInputArgumentDescription ReferenceType"
    },
    {
      "Id": "4edc318d-c78c-4ef1-916c-6697506b80b0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.7.3 HasOptionalInputArgumentDescription ReferenceType\n---\n",
      "Content": "The HasOptionalInputArgumentDescription ReferenceType is a concrete ReferenceType that can be used directly. It is a subtype of the HasArgumentDescription ReferenceType.\nThe semantic of the HasOptionalInputArgumentDescription ReferenceType- extends the semantic of the HasArgumentDescription ReferenceType to reference optional input arguments of a Method NodeClass. Optional input arguments shall always follow any non-optional input arguments in the InputArguments array. For example, if a method has 3 arguments with 1 being optional then the 3 rd argument shall be the optional one.\nThere are no additional constraints defined for this ReferenceType."
    },
    {
      "Id": "2a0a0fd7-6fc8-4868-b0b3-562f8748308e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.8 DataTypes"
    },
    {
      "Id": "b7ae3f34-3dc7-4f26-b13a-0b256054ced0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8 DataTypes\n---\n",
      "Content": "5.8.1 DataType Model"
    },
    {
      "Id": "63e2ce67-0577-425f-9923-21718be2b569",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.1 DataType Model\n---\n",
      "Content": "The DataType Model is used to define simple and structured data types. Data types are used to describe the structure of the Value Attribute of Variables and their VariableTypes. Therefore each Variable and VariableType is pointing with its DataType Attribute to a Node of the DataType NodeClass as shown in[Figure 17](/\u00A7_Ref100371225)."
    },
    {
      "Id": "a3c3b2b7-5be6-40f8-9f4a-8410ddd1dca4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.1 DataType Model\nCaption: Figure 17 - Variables, VariableTypes and their DataTypes\n---\n",
      "Content": "[image020.png](images/image020.png)"
    },
    {
      "Id": "11afac4e-d8ab-4cae-8337-9343386b53cd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.1 DataType Model\n---\n",
      "Content": "Figure 17 - Variables, VariableTypes and their DataTypes\nIn many cases, the NodeId of the DataType Node- the DataTypeId- will be well-known to Clients and Servers. Clause[8](/\u00A7_Ref153882780) defines DataTypes and[OPC 10000-6](/\u00A7UAPart6) defines their DataTypeIds. In addition, other organizations may define DataTypes that are well-known in the industry. Well-known DataTypeIds provide for commonality across OPC UA Servers and allow Clients to interpret values without having to read the type description from the Server. Therefore, Servers may use well-known DataTypeIds without representing the corresponding DataType Nodes in their AddressSpaces.\nIn other cases, DataTypes and their corresponding DataTypeIds may be vendor-defined. Servers should attempt to expose the DataType Nodes and the information about the structure of those DataTypes for Clients to read, although this information might not always be available to the Server.\n[Figure 18](/\u00A7_Ref136068697) illustrates the Nodes used in the AddressSpace to describe the structure of a DataType. The DataType points to an Object of type DataTypeEncodingType. Each DataType can have several DataTypeEncoding, for example \u0022Default\u0022, \u0022UA Binary\u0022 and \u0022XML\u0022 encoding. Services in[OPC 10000-4](/\u00A7UAPart4) allow Clients to request an encoding or choosing the \u0022Default\u0022 encoding. Each DataTypeEncoding is used by exactly one DataType, that is, it is not permitted for two DataTypes to point to the same DataTypeEncoding."
    },
    {
      "Id": "18ab6ab1-b503-4002-a549-c22d8af4d2a6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.1 DataType Model\nCaption: Figure 18 - DataType Model\n---\n",
      "Content": "[image021.png](images/image021.png)"
    },
    {
      "Id": "5a9cad0b-0a4e-4d65-af31-dc58402bbf9a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.1 DataType Model\n---\n",
      "Content": "Figure 18 - DataType Model\nSince the NodeId of the DataTypeEncoding will be used in some Mappings to identify the DataType and it\u0027s encoding as defined in[OPC 10000-6](/\u00A7UAPart6), those NodeIds may also be well-known for well-known DataTypeIds."
    },
    {
      "Id": "9d0d7995-b161-49bd-8fbb-dcdeb88f5b40",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8 DataTypes\n---\n",
      "Content": "5.8.2 Encoding Rules for different kinds of DataTypes"
    },
    {
      "Id": "9b99ba4c-32e0-412a-a906-65f94b2a9519",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.2 Encoding Rules for different kinds of DataTypes\n---\n",
      "Content": "Different kinds of DataTypes are handled differently regarding their encoding and according to whether this encoding is represented in the AddressSpace.\nBuilt-in DataTypes are a fixed set of DataTypes(see[OPC 10000-6](/\u00A7UAPart6) for a complete list of Built-in DataTypes). They have no encodings visible in the AddressSpace since the encoding should be known to all OPC UA products. Examples of Built-in DataTypes are Int32(see[8.26](/\u00A7_Ref179771135)) and Double(see[8.12](/\u00A7_Ref179771161)).\nSimple DataTypes are subtypes of the Built-in DataTypes, which are handled on the wire like the Built-in DataType, i.e. they cannot be distinguished on the wire from their Built-in supertypes. Since they are handled like Built-in DataTypes regarding the encoding they cannot have encodings defined in the AddressSpace. Clients can read the DataType Attribute of a Variable or VariableType to identify the Simple DataType of the Value Attribute. An example of a Simple DataType is Duration. It is handled on the wire as a Double but the Client can read the DataType Attribute and thus interpret the value as defined by Duration(see[8.13](/\u00A7_Ref179771183)).\nStructured DataTypes are DataTypes that represent structured data and are not defined as Built-in DataTypes. Structured DataTypes inherit directly or indirectly from the DataType Structure defined in[8.32](/\u00A7_Ref181253554). Structured DataTypes may have several encodings and the encodings are exposed in the AddressSpace. How the encoding of Structured DataTypes is handled on the wire is defined in[OPC 10000-6](/\u00A7UAPart6). The encoding of the Structured DataType"
    },
    {
      "Id": "42ad7859-8241-47f9-8a49-f7ac6abf33d4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.2 Encoding Rules for different kinds of DataTypes\n---\n",
      "Content": "Structured DataType is transmitted with each value, thus Clients are aware of the DataType without reading the DataType Attribute. The encoding has to be transmitted so the Client is able to interpret the data. An example of a Structured DataType is Argument(see[8.6](/\u00A7_Ref128132235)).\nEnumeration DataTypes are DataTypes that represent discrete sets of named values. Enumerations are always encoded as Int32 on the wire as defined in[OPC 10000-6](/\u00A7UAPart6). Enumeration DataTypes inherit directly or indirectly from the DataType Enumeration defined in[8.14](/\u00A7_Ref181253584). Enumerations have no encodings exposed in the AddressSpace. To expose the human-readable representation of an enumerated value the DataType Node may have the EnumStrings Property that contains an array of LocalizedText. The Integer representation of the enumeration value points to a position within that array. EnumValues Property can be used instead of the EnumStrings to support integer representation of enumerations that are not zero-based or have gaps. It contains an array of a Structured DataType containing the integer representation as well as the human-readable representation. An example of an enumeration DataType containing a sparse list of Integers is NodeClass which is defined in[8.29](/\u00A7_Ref130971442).\nAn OptionSet can be defined in one of two ways. An OptionSet which is 64 bits or less may be defined as an UInteger DataType and always encoded on the wire as defined in[OPC 10000-6](/\u00A7UAPart6). An OptionSet may be defined as an OptionSet DataType which is defined in[8.40](/\u00A7_Ref401165187) and is encoded on the wire as a Structured DataType"
    },
    {
      "Id": "568e4516-f8ec-410a-b0d9-1946294059e4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.2 Encoding Rules for different kinds of DataTypes\n---\n",
      "Content": "Structured DataType. To expose the human-readable representation of an OptionSet the DataType Node shall have the OptionSetValues Property that contains an array of LocalizedText.\nIn addition to the DataTypes described above, abstract DataTypes are also supported, which do not have any encodings and cannot be exchanged on the wire. Variables and VariableTypes use abstract DataTypes to indicate that their Value may be any one of the subtypes of the abstract DataType. An example of an abstract DataType is Integer which is defined in[8.24](/\u00A7_Ref181253643).\n[OPC 10000-6](/\u00A7UAPart6) defines a number of DataEncodings which specify how to serialize DataTypes. Some of these DataEncodings are text based and make use of Name portion the DataType BrowseName. For this reason, the BrowseName for all DataTypes should be Strings that start with a letter and contain only letters, digits or the underscore (_). If a DataType has a BrowseName that does not meet these requirements it will be transformed using the Name encoding rules defined in[OPC 10000-6](/\u00A7UAPart6) into a String that meets the requirements. This will result in text based DataEncodings with Names that are not friendly to human readers."
    },
    {
      "Id": "195267a5-844f-451f-9772-9d3557f382ef",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8 DataTypes\n---\n",
      "Content": "5.8.3 DataType NodeClass"
    },
    {
      "Id": "199eee75-80c2-41bf-ba97-f2f33f9edb31",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.3 DataType NodeClass\n---\n",
      "Content": "The DataType NodeClass describes the syntax of a Variable Value. DataTypes are defined using the DataType NodeClass, as specified in[Table 16](/\u00A7_Ref115513367).\nTable 16 - DataType NodeClass"
    },
    {
      "Id": "e6f12c3e-0fc7-4f68-ab09-12b15ce7d054",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.3 DataType NodeClass\nCaption: Table 16 - DataType NodeClass\n---\n",
      "Content": "Name\nUse\nData Type\nDescription\nAttributes\n\n\n\nBase NodeClass Attributes\nM\n--\nInherited from the Base NodeClass. See[5.2](/\u00A7_Ref107723037).\nIsAbstract\nM\nBoolean\nA boolean Attribute with the following values:\nTRUE it is an abstract DataType.\nFALSE it is not an abstract DataType.\nDataTypeDefinition\nO\nDataTypeDefinition\nThe DataTypeDefinition Attribute is used to provide the meta data and encoding information for DataTypes. The abstract DataTypeDefinition DataType is defined in[8.47](/\u00A7_Ref433698368).\nStructure and Union DataTypes\nThe Attribute shall be mandatory for DataTypes derived from Structure and Union. For such DataTypes, the Attribute shall contain a structure of the DataType StructureDefinition. The StructureDefinition DataType is defined in[8.48](/\u00A7_Ref434502273). It is a subtype of DataTypeDefinition.\nEnumeration and OptionSet DataTypes\nThe Attribute shall be mandatory for DataTypes derived from Enumeration, OptionSet and subtypes of UInteger representing an OptionSet. For such DataTypes, the Attribute shall contain a structure of the DataType EnumDefinition. The EnumDefinition DataType is defined in[8.49](/\u00A7_Ref434502464). It is a subtype of DataTypeDefinition.\n\n\n\n\nReferences\n\n\n\nHasProperty\n0..*\n\nHasProperty References identify the Properties for the DataType.\nHasSubtype\n0..*\n\nHasSubtype References may be used to span a data type hierarchy. The inverse Reference identifies the parent type of this type.\nHasEncoding\n0..*\n\nHasEncoding References identify the encodings of the DataType represented as Objects of type DataTypeEncodingType.\nOnly concrete"
    },
    {
      "Id": "677e56bc-9743-4378-8b38-88bfa4cf0c25",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.3 DataType NodeClass\nCaption: Table 16 - DataType NodeClass\n---\n",
      "Content": ".\nOnly concrete Structured DataTypes may use HasEncoding References. Abstract, Built-in, Enumeration, and Simple DataTypes are not allowed to be the SourceNode of a HasEncoding Reference.\nEach concrete Structured DataType shall point to at least one DataTypeEncoding Object with the BrowseName\u0022Default Binary\u0022 or \u0022Default XML\u0022 having the NamespaceIndex 0. The BrowseName of the DataTypeEncoding Objects shall be unique in the context of a DataType, i.e. a DataType shall not point to two DataTypeEncodings having the same BrowseName.\n\n\n\n\nStandard Properties\n\n\n\nNodeVersion\nO\nString\nThe NodeVersion Property is used to indicate the version of a Node.\nThe NodeVersion Property is updated each time a Reference is added or deleted to the Node the Property belongs to. Attribute value changes do not cause the NodeVersion to change. Clients may read the NodeVersion Property or subscribe to it to determine when the structure of a Node has changed. Clients shall not use the content for programmatic purposes except for equality comparisons.\nEnumStrings\nO\nLocalizedText[]\nEnumeration DataTypes shall have either an EnumStrings Property or an EnumValues Property. They shall not be applied for other DataTypes.\nEach entry of the array of LocalizedText in this Property represents the human-readable representation of an enumerated value. The Integer representation of the enumeration value points to a position of the array.\nEnumValues\nO\nEnumValueType[]\nEnumeration DataTypes shall have either an EnumStrings Property or an EnumValues Property. They shall not be applied for other DataTypes.\nThe EnumValues Property shall be used to represent Enumerations with integers that are not zero-based or have gaps (e.g. 1, 2, 4, 8, and 16)."
    },
    {
      "Id": "6e8f3918-58f2-4f75-aafe-45f99dab85bf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.3 DataType NodeClass\nCaption: Table 16 - DataType NodeClass\n---\n",
      "Content": "Each entry of the array of EnumValueType in this Property represents one enumeration value with its integer notation, human-readable representation and help information.\nOptionSetValues\nO\nLocalizedText[]\nThe OptionSetValues Property shall be applied to OptionSet DataTypes and UInteger DataTypes representing bit masks.\nAn OptionSet DataType or UInteger DataType is used to represent a bit mask and the OptionSetValues Property contains the human-readable representation for each bit of the bit mask.\nThe OptionSetValues Property shall provide an array of LocalizedText containing the human-readable representation for each bit. The LocalizedText of undefined bits shall be null.\nOptionSetLength\nO\nUInt32\nThe OptionSetLength Property shall only be applied to subtypes of the OptionSet DataType.\nIt optionally provides the length, in bytes, of the OptionSet.\nThe provided length shall at least provide enough bytes that all bits defined in the OptionSetValues can be managed. For example, if 18 bits are defined by the OptionSetValues, the OptionSetLength shall be at least 3 bytes."
    },
    {
      "Id": "e92e407a-2542-40a3-8db3-51098d1f6f9a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.3 DataType NodeClass\n---\n",
      "Content": "The DataType NodeClass inherits the base Attributes from the Base NodeClass defined in[5.2](/\u00A7_Ref107723037). The IsAbstract Attribute specifies if the DataType is abstract or not. Abstract DataTypes can be used in the AddressSpace, i.e. Variables and VariableTypes can point with their DataType Attribute to an abstract DataType. However, concrete values can never be of an abstract DataType and shall always be of a concrete subtype of the abstract DataType.\nHasProperty References are used to identify the Properties of a DataType. The Property NodeVersion is used to indicate the version of the DataType. The Property EnumStrings contains human-readable representations of enumeration values and is only applied to Enumeration DataTypes. Instead of the EnumStrings Property an Enumeration DataType can also use the EnumValues Property to represent Enumerations with integer values that are not zero-based or containing gaps. There are no additional Properties defined for DataTypes in this standard. Additional parts of this series of standards may define additional Properties for DataTypes.\nHasSubtype References may be used to expose a data type hierarchy in the AddressSpace. The semantic of subtyping is only defined to the point, that a Server may provide instances of the subtype instead of the DataType. Clients should not make any assumptions about any other semantic with that information. For example, it might not be possible to cast a value of one data type to its base data type. Servers need not provide HasSubtype References, even if their DataTypes span a type hierarchy, however it is required that the subtype provides the inverse Reference to its supertype. Some restrictions apply for subtyping enumeration DataTypes as defined in[8.14](/\u00A7_Ref181253584).\nHasEncoding References point from the DataType to its DataTypeEncodings. Each concrete Structured DataType can point to many DataTypeEncodings, but each DataTypeEncoding"
    },
    {
      "Id": "bb961518-1cbc-4ff9-b629-f5395b532857",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.3 DataType NodeClass\n---\n",
      "Content": ", but each DataTypeEncoding shall belong to one DataType, that is, it is not permitted for two DataType Nodes to point to the same DataTypeEncoding Object using HasEncoding References. The DataTypeEncoding Node shall provide the inverse HasEncoding Reference to its DataType.\nAn abstract DataType is not the SourceNode of a HasEncoding Reference. The DataTypeEncoding of an abstract DataType is provided by its concrete subtypes.\nDataType Nodes shall not be the SourceNode of other types of References. However, they may be the TargetNode of other References."
    },
    {
      "Id": "1b1b24b4-898f-4074-ab9d-1efe5b76aa11",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8 DataTypes\n---\n",
      "Content": "5.8.4 DataTypeEncoding and Encoding Information"
    },
    {
      "Id": "a7c45b72-725c-4c6c-801c-32684f85cacc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.4 DataTypeEncoding and Encoding Information\n---\n",
      "Content": "If a DataType Node is exposed in the AddressSpace, it shall provide its DataTypeEncodings using HasEncoding References. These References shall be bi-directional.[Figure 19](/\u00A7_Ref136072017) provides an example how DataTypes are modelled in the AddressSpace."
    },
    {
      "Id": "c09db605-988c-4b35-a140-55475aadc45e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.4 DataTypeEncoding and Encoding Information\nCaption: Figure 19 - Example of DataType Modelling\n---\n",
      "Content": "[image022.png](images/image022.png)"
    },
    {
      "Id": "17b44c21-5df6-429c-8437-4e6b32bdff8d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.4 DataTypeEncoding and Encoding Information\n---\n",
      "Content": "Figure 19 - Example of DataType Modelling\nThe information on how to encode the DataType is provided in the Attribute DataTypeDefinition of the DataType Node. The content of this Attribute shall not be changed once it had been provided to Clients since Clients might persistently cache this information. If the encoding of a DataType needs to be changed conceptually a new DataType needs to be provided, meaning that a new NodeId shall be used for the DataType. Since Clients identify the DataType via the DataTypeEncodings, also the NodeIds for the DataTypeEncodings of the DataType shall be changed, when the encoding changes."
    },
    {
      "Id": "6eccd556-4ae0-439c-8927-6f959c975ddf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8 DataTypes\n---\n",
      "Content": "5.8.5 DataTypeRefinement"
    },
    {
      "Id": "531ba100-a674-493f-ad64-a09897eefa97",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5 DataTypeRefinement\n---\n",
      "Content": "5.8.5.1 Overview"
    },
    {
      "Id": "e3c2650b-eae7-472c-b1cd-04dfed32e960",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.1 Overview\n---\n",
      "Content": "A DataTypeRefinement refines the usage of a concrete Structured DataType. It can restrict the usage of fields of the Structured DataType and add meta data to fields of the Structured DataType, like providing the EngineeringUnits or EURange.\nIn order to restrict the usage for each field of a Structured DataType, the following can be defined:\nWhat DataType can be used, including the maximum array length and maximum string length\nIf an optional field shall become mandatory or shall not be provided\nIf a certain subtype of the DataType is allowed or not\nThe general rules for inheritance apply, as defined in[6.3](/\u00A7_Ref192918126), i.e., the DataType of a field can only be restricted to subtypes of the original DataType, mandatory fields cannot become optional, etc. If a concrete maximum array length or maximum string length has already been defined, it shall not be changed. If a field is defined that does not allow subtypes, this shall not be changed. If a field is defined that does allow subtypes, this can be changed to disallow subtypes.\nAny restrictions on the Structured DataType only affect the usage, not the encoding of the DataType. It is still encoded according to the rules of the Structured DataType.\nIn addition to the restrictions, the DataTypeRefinement also allows meta data for fields to be added to a Structured DataType."
    },
    {
      "Id": "2860e318-921c-4da4-b508-1deb9fa0b143",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5 DataTypeRefinement\n---\n",
      "Content": "5.8.5.2 DataTypeRefinement Objects"
    },
    {
      "Id": "146e4d32-757b-4731-8764-74c0ec046751",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\n---\n",
      "Content": "A DataTypeRefinement is represented by an Object of DataTypeRefinementType(see[OPC 10000-5](/\u00A7UAPart5)) or a subtype. A DataTypeRefinement Object shall always be referenced using a HasDataTypeRefinement Reference(see[7.30](/\u00A7_Ref209522665)) or subtype from exactly one DataType Node representing a Structured DataType that is being refined.\nFor each field having a refinement, a Variable of BaseDataVariableType or subtype is referenced using a Reference of HasFieldDescription ReferenceType(see[7.25](/\u00A7_Ref199516610)) or a subtype. The BrowseName of the Variable shall use a BrowseName equal to the name of the field. The Namespace of the BrowseName shall be ignored by a Client when performing an equality check with a field name.\nA DataTypeRefinement Object shall not reference any Node with a HasFieldDescription or subtype which is not representing a field of the DataType it refines and shall reference at most one Variable for each field with a HasFieldDescription or subtype.\nFor the restriction of the field, the rules defined in[5.8.5.1](/\u00A7_Ref199514593) apply. In[Table 17](/\u00A7_Ref53493741), the mapping of the fields in the StructureField of the DataTypeDefinition Attribute to concepts of a Variable is defined.\nTable 17 - Mapping of DataTypeDefinition"
    },
    {
      "Id": "e94c4885-3d94-4a27-a4e6-2e4ab1b0b79d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\nCaption: Table 17 - Mapping of DataTypeDefinition\n---\n",
      "Content": "StructureField\nVariable Concept\nComment\nName\nString part of BrowseName Attribute\nMust match\nDescription\nDescription Attribute\nNo requirements\nDataType\nDataType Attribute\nVariable must have the same DataType or a subtype\nValueRank\nValueRank Attribute\nMust match\nArrayDimensions\nArrayDimensions Attribute\nFor each dimension: If 0, Variable is allowed to be non-zero, otherwise they must match\nMaxStringLength\nMaxStringLength Property\nIf MaxStringLength is 0, Variable is allowed to be non-zero, otherwise must match\nIsOptional and StructureWithOptionalFields\nReference to Variable either using HasFieldDescription (stays optional) HasFieldDescriptionSetMandatory (becomes mandatory) or IsDisabledOptionalField (optional field not used)\nOnly allowed if IsOptional is true. Otherwise IsDisabledOptionalField and HasFieldDescriptionSetMandatory are not allowed.\nIsOptional and StructureWithSubtypedValues or UnionWithSubtypedValues\nAccessLevelEx Attribute, bit NoSubDataTypes\nOnly allowed if IsOptional is true to set the NoSubDataTypes to true.\nIf IsOptional is false, NoSubDataTypes shall be set."
    },
    {
      "Id": "369b5322-eb1e-440d-bba5-4f533cdaebf6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\n---\n",
      "Content": "By using the subtypes HasFieldDescriptionSetMandatory(see[7.26](/\u00A7_Ref201323022)) a field becomes mandatory, and by IsDisabledOptionalField(see[7.27](/\u00A7_Ref199516641)) an optional field shall not be present. In the AccessLevelEx Attribute, the NoSubDataTypes bit can be used to express that a field where subtypes are allowed, no longer allows subtypes.\nDepending on the Structured DataType, some limitations on the DataTypeRefinement occur.\nIf the DataType of a field being refined is BaseDataType, Structure, Number, Integer or UInteger, the DataType of the field can be restricted by using a subtype or SubtypeRestriction(see[5.8.6](/\u00A7_Ref199846837)) on the Variable refining the field. If the StructureType of the DataType being refined is StructureWithSubtypedValues or UnionWithSubtypedValues and IsOptional of the field is set true, the DataType of that field may be restricted by using a subtype or SubtypeRestriction on the Variable refining the field. In all other cases, it is not allowed to use subtypes on the field and therefore restricting the DataType of the field to subtypes is not allowed.\nIf the DataType of a Variable refining a field is BaseDataType, Structure, Number, Integer or UInteger, then the AccessLevelEx bit NoSubDataTypes of the Variable shall be true. If the DataType of a field being refined is BaseDataType, Structure, Number, Integer or UInteger, then the AccessLevelEx bit NoSubDataTypes of the Variable may be true or false. If the StructureType of a DataType is StructureWithSubtypedValues or UnionWithSubtypedValues, and IsOptional of the field is true, the"
    },
    {
      "Id": "a1c5031c-3d91-43f5-a8d5-b92830fb9b8d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\n---\n",
      "Content": "AccessLevelEx bit NoSubDataTypes may be true or false. In all other cases the AccessLevelEx bit NoSubDataTypes of a Variable refining a field of a Structured DataType shall be false, as it is not allowed to use subtypes based on the Structured DataType being refined.\nIf the StructureType of a DataType is Structure or StructureWithSubtypedValues, any refinement of a field of the DataType shall not be referenced with IsDisabledOptionalField or HasFieldDescriptionSetMandatory, as there are no optional fields defined for the DataType. If the StructureType is StructureWithOptionalFields, then the IsDisabledOptionalField or HasFieldDescriptionSetMandatory may be used on a field when IsOptional of that field is true. If the StructureType is Union or UnionWithSubtypedValues then the IsDisabledOptionalField may be used on any field and the HasFieldDescriptionSetMandatory shall not be used. In this case, the semantic of IsDisabledOptionalField implies that the DataType of the field shall not be used in the Union using the DataTypeRefinement.\nIn[Figure 20](/\u00A7_Ref199516920), an example is given. The structure of X:SuperDataType and X:SubDataType is provided in pseudo-code. The Y:Refinement_1 is refining the X:SubDataType and referenced from the DataType with a HasDataTypeRefinement Reference.\nThe field1 is defined in the DataType as Number, the DataTypeRefinement restricts this to an Int32. As meta data, the EngineeringUnits is defined as Kelvin, therefore the AnalogUnitType is used as VariableType.\nThe optional field2 is refined to \u0022not used\u0022 by referencing the corresponding Variable with IsDisabledOptionalField.\nThe field3 is defined in the DataType as Number"
    },
    {
      "Id": "2135649b-eac1-4112-bac3-298c6dfebafa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\n---\n",
      "Content": "DataType as Number and a one-dimensional array without a size limitation. In the DataTypeRefinement it is refined as an array of Int32 with the maximum length of 5.\nThe optional field4, added in the subtype X:SubDataType, of String without a maximum length, becomes in the DataTypeRefinement a mandatory field of String with the MaxStringLength of 50.\nThe field5 is not refined and stays as an Int32."
    },
    {
      "Id": "63303344-31f7-4d96-8ab3-135bc30ef3c8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\nCaption: Figure 20 - Example of a DataTypeRefinement\n---\n",
      "Content": "[image023.png](images/image023.png)"
    },
    {
      "Id": "abf4edb8-ddb9-488b-bfb2-e159f33cb394",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\n---\n",
      "Content": "Figure 20 - Example of a DataTypeRefinement\nAs fields of Structured DataTypes may use Structured DataTypes, it may be desirable to refine fields of those fields as well. This can be done as shown in[Figure 21](/\u00A7_Ref199519035). In this example, the Y:Refinement_2 provides similar refinements as Y:Refinement_1, but makes the optional field4 \u0022not used\u0022.\nThe new optional field6, introduced by X:SubSubDataType, uses the X:SubDataType as DataType. The Y:Refinement_2 makes this optional field mandatory, and by letting the X:field6 Variable reference the Y:Refinement_1 with UsesDataTypeRefinement(see[7.24](/\u00A7_Ref201326071)), this DataTypeRefinement is applied to field6."
    },
    {
      "Id": "86e4dda8-3ce7-4eaa-b66a-75d42c04e847",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\nCaption: Figure 21 - Example of a DataTypeRefinement using a Structured DataType\n---\n",
      "Content": "[image024.png](images/image024.png)"
    },
    {
      "Id": "29b55d12-c937-4d32-bd2b-5f87aa61949e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.2 DataTypeRefinement Objects\n---\n",
      "Content": "Figure 21 - Example of a DataTypeRefinement using a Structured DataType"
    },
    {
      "Id": "8b2d5d70-3d33-4a1d-a9fe-2c4e6936d3bc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5 DataTypeRefinement\n---\n",
      "Content": "5.8.5.3 Usage of DataTypeRefinements"
    },
    {
      "Id": "cb9e2753-9d86-4d7a-a1f4-48b3171d9d6d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.3 Usage of DataTypeRefinements\n---\n",
      "Content": "Each DataTypeRefinement Object shall be referenced from exactly one DataType Node using HasDataTypeRefinement or a subtype.\nDataTypeRefinements are expressed in an OPC UA information model, by using the non-hierarchical Reference UsesDataTypeRefinement(see[7.24](/\u00A7_Ref201326072)) or a subtype. Those References always starts from an instance of a Variable, where the Structured DataType is used. They point to an Object of DataTypeRefinementType or a subtype, which contains the restrictions and meta data of the DataTypeRefinement.\nDataTypeRefinements are only allowed to be used on the concrete occurrence of the usage of the Structured DataType, that is on a Variable.\nDataTypeRefinements shall not be used from any DataType Node, from any VariableType, or any InstanceDeclaration, only from concrete Variables. This does include Variables describing a DataTypeRefinement, as shown in[Figure 21](/\u00A7_Ref199519035).\nNote, that Method Arguments can be further described using Variables referenced with a HasArgumentDescription. If the Method Argument is a Structured DataType, this Variable can be used as SourceNode for the UsesDataTypeRefinement to further refine the Structured DataType."
    },
    {
      "Id": "b0b39910-2392-4cd3-84c4-6c745abcc8b8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5 DataTypeRefinement\n---\n",
      "Content": "5.8.5.4 Example of usage of DataTypeRefinements"
    },
    {
      "Id": "61e75a9b-ed1d-432c-8e67-4902103dcc76",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.4 Example of usage of DataTypeRefinements\n---\n",
      "Content": "An example of DataTypeRefinements is given in[Figure 22](/\u00A7_Ref531777624). The X:SuperDataType has two DataTypeRefinements, its subtype has an additional one. Note that the details of the DataTypeRefinements is not shown in the figure. There are two Objects of Z:SuperObjectType, both using DataTypeRefinements.\nZ:Object1 has the Property Z:Prop1 and the DataVariables Z:Var1 and Z:Var2, as defined on the X:SuperObjectType. Although all three Variables use the same DataType, the Z:Prop1 is refined by Y:Refinement_4 and Z:Var2 by Y:Refinement_3. Z:Var1 is not further refined.\nZ:Object2 has Z:Prop1 and Z:Var1 as defined on the ObjectType, but refines the DataType from Z:Var2 to X:SubDataType and adds another Variable Z:Var3. Like in Z:Object1, the Z:Prop1 is refined by Y:Refinement_4, and both Z:Var2 and Z:Var3 are refined by Y:Refinement_1."
    },
    {
      "Id": "4374a7df-7e7a-40f3-8e75-d0c57b8b67e1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.4 Example of usage of DataTypeRefinements\nCaption: Figure 22 - Example of DataTypeRefinements\n---\n",
      "Content": "[image025.png](images/image025.png)"
    },
    {
      "Id": "83934897-fbb8-441e-9316-4d936eab8f03",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.5.4 Example of usage of DataTypeRefinements\n---\n",
      "Content": "Figure 22 - Example of DataTypeRefinements"
    },
    {
      "Id": "6bfd562b-5845-4eea-9b79-f39c8d17d866",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8 DataTypes\n---\n",
      "Content": "5.8.6 SubtypeRestriction on a DataType"
    },
    {
      "Id": "d141c1a4-08c8-4a77-956e-6fa5a34a3e5d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6 SubtypeRestriction on a DataType\n---\n",
      "Content": "5.8.6.1 Overview"
    },
    {
      "Id": "68838c3c-1896-4d57-a2c5-d9c0bcf79b52",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.1 Overview\n---\n",
      "Content": "When a Variable or VariableType is defined, the DataType of the Value is defined by the DataType, ValueRank and ArrayDimensions Attributes. In general, it is always allowed for the Value to use a subtype of the DataType unless restricted in the NoSubDataTypes bit of the AccessLevelEx Attribute. In fields of a structure, using subtypes is allowed when IsOptional is set and it is a StructureWithOptionalFields or the DataType is an abstract DataType like the BaseDataType. In many cases where it is allowed to use subtypes, not all possible subtypes are allowed, but the DataType hierarchy does not allow to restrict this by one supertype. For example, when an Int16 and Int32 are allowed, their common supertype Integer would also allow SByte and Int64.\nA SubtypeRestriction limits the usage of subtypes to a subset of all subtypes of a DataType. It is represented by an Object of SubtypeRestrictionType defined in[OPC 10000-5](/\u00A7UAPart5). A SubtypeRestriction Object is bound to a DataType by a HasDataTypeRefinement Reference from the DataType to the SubtypeRestriction Object. Each SubtypeRestriction Object shall be referenced from exactly one DataType Node using a HasDataTypeRefinement Reference. A SubtypeRestriction Object is referencing Variables with an AllowedSubtype Reference(see[7.29](/\u00A7_Ref200110438)), and thereby restricting that the DataType including ValueRank and ArrayDimensions of the Variable is allowed to be used as subtype. The general rules of inheritance defined in[6.3](/\u00A7_Ref192918126) apply, i.e., the DataType shall be the same or a subtype of the DataType, the ValueRank can only be changed according to the subtyping rules, etc.\nA"
    },
    {
      "Id": "a1f02b79-7d47-4d40-94de-f6e3cbb40181",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.1 Overview\n---\n",
      "Content": "A SubtypeRestriction Object should have at least two AllowedSubtype References to Variables defining different variations of subtypes. Otherwise, a Variable using the SubtypeRestriction should just use the concrete subtype and does not need a SubtypeRestriction.\nIn[Figure 23](/\u00A7_Ref199843284), an example of a SubtypeRestriction Object is given. The Y:Restriction1 Object is referenced from Number and therefore can be used by any Variable using the Number DataType. It references two Variables, Y:UInt32 with the DataType UInt32, the ValueRank Scalar which does not allow subtypes and X:IntegerArray, of Integer, ValueRank OneDimension that does allow subtypes (which is required since Integer is an abstract DataType). Thereby, any Variable using the SubtypeRestriction is limiting its values to scalar UInt32s or arrays of Integer or any subtypes of Integer."
    },
    {
      "Id": "5ef6b789-bd69-4e57-b986-3e580c44f3e3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.1 Overview\nCaption: Figure 23 - Example of a SubtypeRestriction\n---\n",
      "Content": "[image026.png](images/image026.png)"
    },
    {
      "Id": "30b7052d-0fdf-4e74-b176-8b7e1ffd9998",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.1 Overview\n---\n",
      "Content": "Figure 23 - Example of a SubtypeRestriction\nIn the example, Z:SampleVar is using the Y:Restriction1 by referencing it with UsesSubtypeRestriction. This is allowed since the DataType of Z:SampleVar is Number. The DataTypes always have to match exactly. The NoSubDataTypes is set to true, which is required, since Number is abstract, but would also be required for a concrete DataType, since setting it to true is already restricting it to disallow subtypes.\nIn order to use a SubtypeRestriction, the ValueRank and ArrayDimensions Attribute of the Variable using the SubtypeRestriction shall be compatible to all referenced Variables using AllowedSubtype, i.e., it is required that based on the definitions of the Variable using the SubtypeRestriction a value based on any of the referenced Variables can be used.\nA SubtypeRestriction shall only be used on Variables used as instances, never on InstanceDeclarations or VariableTypes.\nFor Method Arguments, it can be used in combination with the HasArgumentDescription."
    },
    {
      "Id": "4aa35a62-f8b1-4ac8-97d2-331ee37818a0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6 SubtypeRestriction on a DataType\n---\n",
      "Content": "5.8.6.2 SubtypeRestriction on fields of Structured DataTypes"
    },
    {
      "Id": "6f6b1e6c-f849-4247-97f8-1dba999ad35f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.2 SubtypeRestriction on fields of Structured DataTypes\n---\n",
      "Content": "Using a SubtypeRestriction, it is possible to restrict the usage of subtypes on fields of a Structured DataType, by combining it with DataTypeRefinements(see[5.8.5](/\u00A7_Ref199844932)). The Variable used to refine the field in a DataTypeRefinement can be the SourceNode of a UsesSubtypeRestriction, thereby limiting the subtypes that can be used in the field.\nIn[Figure 24](/\u00A7_Ref199848812), an example is given. The X:SuperDataType contains field1 of a scalar Number. The Y:Refinement_3 of X:SuperDataType defines the field1 to either use a scalar UInt32 or Int32 by referencing the Z:Restriction1. No other subtypes of Number are allowed."
    },
    {
      "Id": "d3a99210-0e87-453b-9bf6-ba63e071c3f7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.2 SubtypeRestriction on fields of Structured DataTypes\nCaption: Figure 24 - Example of a SubtypeRestriction used by a DataTypeRefinement\n---\n",
      "Content": "[image027.png](images/image027.png)"
    },
    {
      "Id": "3431e308-7aa9-447c-bfe8-2e88b5283c05",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.8.6.2 SubtypeRestriction on fields of Structured DataTypes\n---\n",
      "Content": "Figure 24 - Example of a SubtypeRestriction used by a DataTypeRefinement"
    },
    {
      "Id": "52d577b8-6606-45ef-a270-135f39c17b47",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5 Standard NodeClasses\n---\n",
      "Content": "5.9 Summary of Attributes of the NodeClasses"
    },
    {
      "Id": "91632896-ea98-4fd7-9170-a716f935e4de",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.9 Summary of Attributes of the NodeClasses\n---\n",
      "Content": "[Table 18](/\u00A7_Ref124912117) summarises all Attributes defined in this document and points out which NodeClasses use them either in an optional (O) or mandatory (M) way.\nTable 18 - Overview of Attributes"
    },
    {
      "Id": "95f43d3c-1ada-497c-942f-46183db5bb79",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.9 Summary of Attributes of the NodeClasses\nCaption: Table 18 - Overview of Attributes\n---\n",
      "Content": "Attribute\nVariable\nVariable Type\nObject\nObject Type\nReference Type\nDataType\nMethod\nView\nAccessLevel\nM\n\n\n\n\n\n\n\nAccessLevelEx\nO\n\n\n\n\n\n\n\nAccessRestrictions\nO\nO\nO\nO\nO\nO\nO\nO\nArrayDimensions\nO\nO\n\n\n\n\n\n\nBrowseName\nM\nM\nM\nM\nM\nM\nM\nM\nContainsNoLoops\n\n\n\n\n\n\n\nM\nDataType\nM\nM\n\n\n\n\n\n\nDataTypeDefinition\n\n\n\n\n\nO\n\n\nDescription\nO\nO\nO\nO\nO\nO\nO\nO\nDisplayName\nM\nM\nM\nM\nM\nM\nM\nM\nEventNotifier\n\n\nM\n\n\n\n\nM\nExecutable\n\n\n\n\n\n\nM\n\nHistorizing\nM\n\n\n\n\n\n\n\nInverseName\n\n\n\n\nO\n\n\n\nIsAbstract\n\nM\n\nM\nM\nM\n\n\nMinimumSamplingInterval\nO\n\n\n\n\n\n\n\nNodeClass\nM\nM\nM\nM\nM\nM\nM\nM\nNodeId\nM\nM\nM\nM\nM\nM\nM\nM\nRolePermissions\nO\nO\nO\nO\nO\nO\nO\nO\nSymmetric\n\n\n\n\nM\n\n\n\nUserAccessLevel\nM\n\n\n\n\n\n\n\nUserExecutable\n\n\n\n\n\n\nM\n\nUserRolePermissions\nO\nO\nO\nO\nO\nO\nO\nO\nUserWriteMask\nO"
    },
    {
      "Id": "c53fbe00-a17f-48ac-a453-8c28861fd64d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.9 Summary of Attributes of the NodeClasses\nCaption: Table 18 - Overview of Attributes\n---\n",
      "Content": "UserWriteMask\nO\nO\nO\nO\nO\nO\nO\nO\nValue\nM\nO\n\n\n\n\n\n\nValueRank\nM\nM\n\n\n\n\n\n\nWriteMask\nO\nO\nO\nO\nO\nO\nO\nO"
    },
    {
      "Id": "05db2ee6-0811-429b-bbb9-51168847acf6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 5.9 Summary of Attributes of the NodeClasses\n---\n",
      "Content": ""
    },
    {
      "Id": "d2fc5112-d14a-4dae-a115-f83f6247fda2",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "6 Type Model for ObjectTypes and VariableTypes"
    },
    {
      "Id": "c01be9c1-024b-415c-92ea-b8650b702c22",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6 Type Model for ObjectTypes and VariableTypes\n---\n",
      "Content": "6.1 Overview"
    },
    {
      "Id": "3a0dcd57-0b2e-49cb-8ed6-b0824f062744",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.1 Overview\n---\n",
      "Content": "In the remainder of Clause[6](/\u00A7_Ref193170844) the type model of ObjectTypes and VariableTypes is defined regarding subtyping and instantiation."
    },
    {
      "Id": "e0edb67f-4b1c-4de2-9a32-69301876ad9c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6 Type Model for ObjectTypes and VariableTypes\n---\n",
      "Content": "6.2 Definitions"
    },
    {
      "Id": "96f84e37-0c39-44ab-8bf1-e33810f1f880",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.1 InstanceDeclaration"
    },
    {
      "Id": "f54c57ac-7031-4218-90ac-d859870427ee",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.1 InstanceDeclaration\n---\n",
      "Content": "An InstanceDeclaration is an Object, Variable or Method that references a ModellingRule with a HasModellingRule Reference and is the TargetNode of a hierarchical Reference from a TypeDefinitionNode or another InstanceDeclaration. There shall be no two TypeDefinitionNodes referencing the same InstanceDeclaration with a hierarchical Reference, either directly or from another InstanceDeclaration of that TypeDefinitionNode, i.e. an InstanceDeclaration belongs to exactly one TypeDefinitionNode.\nThe type of an InstanceDeclaration may be abstract, however the instance must be of a concrete type."
    },
    {
      "Id": "3cae35f2-4cf0-4aa5-a7be-caf6914f784a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.2 Instances without ModellingRules"
    },
    {
      "Id": "9d230f61-811c-4027-91f5-b0b2edd5e79e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.2 Instances without ModellingRules\n---\n",
      "Content": "If no ModellingRule exists then the Node is neither considered for instantiation of a type nor for subtyping.\nIf a Node referenced by a TypeDefinitionNode does not reference a ModellingRule it indicates that this Node only belongs to the TypeDefinitionNode and not to the instances. For example, an ObjectType Node may contain a Property that describes scenarios where the type could be used. This Property would not be considered when creating instances of the type. This is also true for subtyping, that is, subtypes of the type definition would not inherit the referenced Node."
    },
    {
      "Id": "e7dfe369-b1bc-404f-ba24-26b748140bfa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.3 InstanceDeclarationHierarchy"
    },
    {
      "Id": "4e0ee33d-1296-45e0-a301-abb782c3c18f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.3 InstanceDeclarationHierarchy\n---\n",
      "Content": "The InstanceDeclarationHierarchy of a TypeDefinitionNode contains the TypeDefinitionNode and all InstanceDeclarations that are directly or indirectly referenced from the TypeDefinitionNode using forward hierarchical References."
    },
    {
      "Id": "23bea910-47e7-4650-bc55-03422c6faff8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.4 Similar Node of InstanceDeclaration"
    },
    {
      "Id": "3b75ee74-3dac-472a-b93c-5bc76e40da57",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.4 Similar Node of InstanceDeclaration\n---\n",
      "Content": "A similar Node of an InstanceDeclaration is a Node that has the same BrowseName and NodeClass as the InstanceDeclaration and in cases of Variables and Objects the same TypeDefinitionNode or a subtype of it. In the case of a Method a similar Node of an InstanceDeclaration is a Node that also has the same arguments of the InstanceDeclaration, however it may append additional optional arguments and it may specialize the DataType of arguments defined with an abstract DataType to a subtype of the abstract DataType."
    },
    {
      "Id": "d647fd49-0eac-4278-b144-5d3ba86766a8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.5 BrowsePath"
    },
    {
      "Id": "2fd68b74-eebf-4626-be54-393e3b101452",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.5 BrowsePath\n---\n",
      "Content": "A BrowsePath is a sequence of BrowseNames used to describe a path between Nodes related w ith a Reference."
    },
    {
      "Id": "aa9f189e-a860-44aa-bd5d-69fa8b1e5535",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.6 BrowseName within a TypeDefinitionNode"
    },
    {
      "Id": "7d9bcd97-477b-486d-bf0a-76794899a20e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.6 BrowseName within a TypeDefinitionNode\n---\n",
      "Content": "A BrowsePath within a TypeDefinitionNode which include targets of forward hierarchical References shall have a BrowseName that is unique within the TypeDefinitionNode, this same restriction applies to the targets of forward hierarchical References from any InstanceDeclaration. This means that any InstanceDeclaration within the InstanceDeclarationHierarchy can be uniquely identified by a sequence of BrowseName s."
    },
    {
      "Id": "f2139458-3fba-4b39-a908-80ff3f6c0fac",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.7 Attribute Handling of InstanceDeclarations"
    },
    {
      "Id": "62326c1e-873a-4854-b116-2d3552468fd7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.7 Attribute Handling of InstanceDeclarations\n---\n",
      "Content": "Some restrictions exist regarding the Attributes of InstanceDeclarations when the InstanceDeclaration is overridden or instantiated. The BrowseName and the NodeClass shall never change and always be the same as the original InstanceDeclaration.\nIn addition, the rules defined in[6.2.8](/\u00A7_Ref190836501) apply for InstanceDeclarations of the NodeClass Variable."
    },
    {
      "Id": "cfa7e763-53bd-43b2-a674-3663d707f0b0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.8 Attribute Handling of Variable and VariableTypes"
    },
    {
      "Id": "a5486290-5301-4418-94a4-0db780526fc7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.8 Attribute Handling of Variable and VariableTypes\n---\n",
      "Content": "Some restrictions exist regarding the Attributes of a VariableType or a Variable used as an InstanceDeclaration with regard to the data type of the Value Attribute.\nWhen a Variable used as InstanceDeclaration or a VariableType is overridden or instantiated the following rules apply:\nThe DataType Attribute can only be changed to a new DataType if the new DataType is a subtype of the DataType originally used.\nThe ValueRank Attribute may only be further restricted\n\u0027Any\u0027 may be set to any other value;\n\u0027ScalarOrOneDimension\u0027 may be set to \u0027Scalar\u0027 or \u0027OneDimension\u0027;\n\u0027OneOrMoreDimensions\u0027 may be set to a concrete number of dimensions (value \u003E 0).\nAll other values of this Attribute shall not be changed.\nThe ArrayDimensions Attribute may be added if it was not provided or when modifying the value of an entry in the array from 0 to a different value. All other values in the array shall remain the same."
    },
    {
      "Id": "bfb89914-ac41-4f25-b6e6-7e54087c0b5d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2 Definitions\n---\n",
      "Content": "6.2.9 NodeIds of InstanceDeclarations"
    },
    {
      "Id": "cfe1a4da-1768-4c44-8044-cbb97cee7242",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.2.9 NodeIds of InstanceDeclarations\n---\n",
      "Content": "InstanceDeclarations are identified by their BrowsePath. Different Servers might use different NodeIds for the InstanceDeclarations of common TypeDefinitionNodes, unless the definition of the TypeDefinitionNode already defines a NodeId for the InstanceDeclaration. All TypeDefinitionNodes defined in[OPC 10000-5](/\u00A7UAPart5) already define the NodeIds for their InstanceDeclarations and therefore shall be used in all Servers."
    },
    {
      "Id": "67ac0ee9-4b47-4b70-9359-e4e1825f6781",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6 Type Model for ObjectTypes and VariableTypes\n---\n",
      "Content": "6.3 Subtyping of ObjectTypes and VariableTypes"
    },
    {
      "Id": "b4a0a615-268b-4573-9905-4f6faa4a68e3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3 Subtyping of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.3.1 Overview"
    },
    {
      "Id": "5f0f47bb-9cbf-4b15-8d80-87d5b5d6c570",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.1 Overview\n---\n",
      "Content": "The HasSubtype ReferenceType defines subtypes of types. Subtyping can only occur between Nodes of the same NodeClass. Rules for subtyping ReferenceTypes are described in[5.3.3.3](/\u00A7_Ref126749286). There is no common definition for subtyping DataTypes, as described in[5.8.3](/\u00A7_Ref128219564). The remainder of[6.3](/\u00A7_Ref192918126) specify subtyping rules for single inheritance on ObjectTypes and VariableTypes."
    },
    {
      "Id": "c103e8ee-5d9d-4190-9da1-df8d548ff5da",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3 Subtyping of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.3.2 Attributes"
    },
    {
      "Id": "ae5d9a42-c3b7-470f-bf64-ac40b21f3286",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.2 Attributes\n---\n",
      "Content": "Subtypes inherit the parent type\u0027s Attribute values, except for the NodeId. Inherited Attribute values may be overridden by the subtype, the BrowseName and DisplayName values should be overridden. Special rules apply for some Attributes of VariableTypes as defined in[6.2.8](/\u00A7_Ref190836501). Optional Attributes, not provided by the parent type, may be added to the subtype."
    },
    {
      "Id": "9830562c-3c4e-47ac-9d9a-a857db5cd448",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3 Subtyping of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.3.3 InstanceDeclarations"
    },
    {
      "Id": "004d811c-9b97-4c91-92fc-f3eada518c10",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3 InstanceDeclarations\n---\n",
      "Content": "6.3.3.1 Overview"
    },
    {
      "Id": "2f204827-cd0d-4c67-ae7d-f445b161f191",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.1 Overview\n---\n",
      "Content": "Subtypes inherit the fully-inherited parent type\u0027s InstanceDeclarations.\nAs long as those InstanceDeclarations are not overridden they are not referenced by the subtype. InstanceDeclarations can be overridden by adding References, changing References to reference different Nodes, changing References to be subtypes of the original ReferenceType, changing values of the Attributes or adding optional Attributes. In order to get the full information about a subtype, the inherited InstanceDeclarations have to be collected from all types that can be found by recursively following the inverse HasSubtype References from the subtype. This collection of InstanceDeclarations is called the fully-inherited InstanceDeclarationHierarchy of a subtype.\nThe remainder of[6.3.3](/\u00A7_Ref389579416) define how to construct the fully-inherited InstanceDeclarationHierarchy and how InstanceDeclarations can be overridden."
    },
    {
      "Id": "90a1f950-4d78-4c1a-ac81-b288ff7b6f93",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3 InstanceDeclarations\n---\n",
      "Content": "6.3.3.2 Fully-inherited InstanceDeclarationHierarchy"
    },
    {
      "Id": "b83cd5b0-b139-4b60-bf5a-b1b836d92c4d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\n---\n",
      "Content": "An instance of a TypeDefinitionNode is described by the fully-inherited InstanceDeclarationHierarchy of the TypeDefinitionNode. The fully-inherited InstanceDeclarationHierarchy can be created by starting with the InstanceDeclarationHierarchy of the TypeDefinitionNode and merging the fully-inherited InstanceDeclarationHierarchy of its parent type.\nThe process of merging InstanceDeclarationHierarchies is straightforward and can be illustrated with the example shown in[Figure 25](/\u00A7_Ref187078879) which specifies a TypeDefinitionNode\u0022BetaType\u0022 which is a subtype of \u0022AlphaType\u0022. The name in each box is the BrowseName and the number is the NodeId."
    },
    {
      "Id": "c7147a7e-961d-4527-b9ca-997dca9a5900",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\nCaption: Figure 25 - Subtyping TypeDefinitionNodes\n---\n",
      "Content": "[image028.png](images/image028.png)"
    },
    {
      "Id": "f397ed09-4e5d-4765-99c9-352de12c4b43",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\n---\n",
      "Content": "Figure 25 - Subtyping TypeDefinitionNodes\nAn InstanceDeclarationHierarchy can be fully described as a table of Nodes identified by their BrowsePaths with a corresponding table of References. The InstanceDeclarationHierarchy for \u0022BetaType\u0022 is described in[Table 19](/\u00A7_Ref187097046) where the top half of the table is the table of Nodes and the bottom half is the table of References(the HasModellingRule references have been omitted from the table for the sake of clarity; all Nodes except for 1, 6, and 5 have ModellingRules). All InstanceDeclarations of the InstanceDeclarationHierarchy and all Nodes referenced with a NonHierarchical Reference from such an InstanceDeclaration are added to the table. Hierarchical References to Nodes without a ModellingRule are not considered.\nTable 19 - The InstanceDeclarationHierarchy for BetaType"
    },
    {
      "Id": "563a3b83-f3ce-46e5-894e-ae3427c1ff45",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\nCaption: Table 19 - The InstanceDeclarationHierarchy for BetaType\n---\n",
      "Content": "BrowsePath\nNodeId\n\n\n/\n6\n\n\n/F\n7\n\n\n/B\n8\n\n\n/F/H\n9\n\n\n/B/J\n10\n\n\n/B/H\n9\n\n\n\nSourceBrowsePath\nReferenceType\nTargetBrowsePath\nTargetNodeId\n/\nHasComponent\n/F\n-\n/\nHasComponent\n/B\n-\n/\nZ\n/B\n-\n/\nHasTypeDefinition\n-\nBetaType\n/F\nHasComponent\n/F/H\n-\n/F\nHasTypeDefinition\n-\nBaseObjectType\n/B\nHasProperty\n/B/J\n-\n/B\nHasTypeDefinition\n-\nBaseObjectType\n/F/H\nHasTypeDefinition\n-\nPropertyType\n/B/J\nHasTypeDefinition\n-\nPropertyType\n/B\nHasComponent\n/B/H\n-\n/B/H\nHasTypeDefinition\n-\nBaseDataVariableType"
    },
    {
      "Id": "15939a61-13f1-41f6-a02e-705850182f19",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\n---\n",
      "Content": "Multiple BrowsePaths to the same Node shall be treated as separate Nodes. An Instance may provide different Nodes for each BrowsePath.\nThe fully-inherited InstanceDeclarationHierarchy for \u0022BetaType\u0022 can now be constructed by merging the InstanceDeclarationHierarchy for \u0022AlphaType\u0022. The result is shown in[Table 20](/\u00A7_Ref187087761) where the entries added from \u0022AlphaType\u0022 are shaded with grey.\nTable 20 - The Fully-Inherited InstanceDeclarationHierarchy for BetaType"
    },
    {
      "Id": "811948d4-3926-4e5a-ab49-cb9f3a26a752",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\nCaption: Table 20 - The Fully-Inherited InstanceDeclarationHierarchy for BetaType\n---\n",
      "Content": "BrowsePath\nNodeId\n\n\n/\n6\n\n\n/F\n7\n\n\n/B\n8\n\n\n/F/H\n9\n\n\n/B/J\n10\n\n\n/B/H\n9\n\n\n/B/D\n4\n\n\n/C\n3\n\n\n\nSourceBrowsePath\nReferenceType\nTargetBrowsePath\nTargetNodeId\n/\nHasComponent\n/F\n-\n/\nHasComponent\n/B\n-\n/\nZ\n/B\n-\n/\nHasTypeDefinition\n-\nBetaType\n/F\nHasComponent\n/F/H\n-\n/F\nHasTypeDefinition\n-\nBaseObjectType\n/B\nHasProperty\n/B/J\n-\n/B\nHasTypeDefinition\n-\nBaseObjectType\n/F/H\nHasTypeDefinition\n-\nPropertyType\n/B/J\nHasTypeDefinition\n-\nPropertyType\n/B\nHasComponent\n/B/H\n-\n/B/H\nHasTypeDefinition\n-\nBaseDataVariableType\n/\nHasNotifier\n/B\n-\n/B\nHasProperty\n/B/D\n-\n/\nHasComponent\n/C\n-\n/\nY\n/C\n-\n/C\nHasTypeDefinition\n-\nBaseDataVariableType\n/B/D\nHasTypeDefinition\n-\nPropertyType\n/B/D\nX\n/C\n-"
    },
    {
      "Id": "71fa11a2-993d-4712-926b-b32fd20dca92",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\n---\n",
      "Content": "The BrowsePath\u0022/B\u0022 already exists in the table so it does not need to be added. However, the HasNotifier reference from \u0022/\u0022 to \u0022/B\u0022 does not exist and was added.\nThe Nodes and References defined in[Table 20](/\u00A7_Ref187087761) can be used to create the fully-inherited InstanceDeclarationHierarchy shown in[Figure 26](/\u00A7_Ref187087911). The fully-inherited InstanceDeclarationHierarchy contains all necessary information about a TypeDefinitionNode regarding its complex structure without needing any additional information from its supertypes."
    },
    {
      "Id": "e2631952-e6fb-481c-b35d-178a8ee3585e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\nCaption: Figure 26 - The Fully-Inherited InstanceDeclarationHierarchy for BetaType\n---\n",
      "Content": "[image029.png](images/image029.png)"
    },
    {
      "Id": "8607e5a7-d636-4b82-a28a-fc169507f47d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.2 Fully-inherited InstanceDeclarationHierarchy\n---\n",
      "Content": "Figure 26 - The Fully-Inherited InstanceDeclarationHierarchy for BetaType"
    },
    {
      "Id": "38511440-3819-4c33-b732-7099db7f9191",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3 InstanceDeclarations\n---\n",
      "Content": "6.3.3.3 Overriding InstanceDeclarations"
    },
    {
      "Id": "2ee1aac6-5901-4e2d-857f-542c64616cf1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.3 Overriding InstanceDeclarations\n---\n",
      "Content": "A subtype overrides an InstanceDeclaration by specifying an InstanceDeclaration with the same BrowsePath. An overridden InstanceDeclaration shall have the same NodeClass and BrowseName. The TypeDefinitionNode of the overridden InstanceDeclaration shall be the same or a subtype of the TypeDefinitionNode specified in the supertype.\nWhen overriding an InstanceDeclaration it is necessary to provide hierarchical References that link the new Node back to the subtype (the References are used to determine the BrowsePath of the Node).\nIt is only possible to override InstanceDeclarations that are directly referenced from the TypeDefinitionNode. If an indirect referenced InstanceDeclaration, such as \u0022J\u0022 in[Figure 26](/\u00A7_Ref187087911), has to be overridden, then the directly referenced InstanceDeclarations that includes \u0022J\u0022, in that case \u0022B\u0022, have to be overridden first and then \u0022J\u0022 can be overridden in a second step.\nA Reference is replaced if it goes between two overridden Nodes and has the same ReferenceType as a Reference defined in the supertype. The Reference specified in the subtype may be a subtype of the ReferenceType used in the parent type.\nAny NonHierarchical References specified for the overridden InstanceDeclaration are treated as new References unless the ReferenceType only allows a single Reference per SourceNode. If this situation exists the subtype can change the target of the Reference but the new target shall have the same NodeClass and for Objects and Variables also the same type or a subtype of the type specified in the parent.\nThe overriding Node may specify new values for the Node Attributes other than the NodeClass or BrowseName, however, the restrictions on Attributes specified in[6.2.7](/\u00A7_Ref181853444) apply. Any Attribute provided by the overridden InstanceDeclaration has to be provided by the overriding InstanceDeclaration, additional optional Attributes"
    },
    {
      "Id": "4914534d-a7a7-4605-9c22-7220d4195d5e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.3.3.3 Overriding InstanceDeclarations\n---\n",
      "Content": ", additional optional Attributes may be added.\nA subtype shall not override an argument of its supertype\u0027s Method InstanceDeclaration which is defined with a concrete DataType. Method arguments defined with an abstract DataType may be overridden. A subtype shall not remove an argument of its supertype\u0027s Method InstanceDeclaration. A subtype shall not add mandatory additional arguments however it may append optional arguments after all existing arguments of the supertype\u0027s Method InstanceDeclaration.\nThe ModellingRule of the overriding InstanceDeclaration may be changed as defined in[6.4.4.2](/\u00A7_Ref181851883).\nEach overriding InstanceDeclaration needs its own HasModellingRule and HasTypeDefinition References, even if they have not been changed.\nA subtype should not override a Node unless it needs to change it.\nThe semantics of certain TypeDefinitionNodes and ReferenceTypes may impose additional restrictions with regard to overriding Nodes."
    },
    {
      "Id": "5ece04db-35ea-4f38-8aa8-ba0bec1db1e7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6 Type Model for ObjectTypes and VariableTypes\n---\n",
      "Content": "6.4 Instances of ObjectTypes and VariableTypes"
    },
    {
      "Id": "211b16ff-b560-4bbe-88f3-1244cf03c722",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4 Instances of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.4.1 Overview"
    },
    {
      "Id": "fb58797a-ef25-4611-bf77-d6e635159c81",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.1 Overview\n---\n",
      "Content": "Any Instance of a TypeDefinitionNode will be the root of a hierarchy which mirrors the InstanceDeclarationHierarchy for the TypeDefinitionNode. Each Node in the hierarchy of the Instance will have a BrowsePath which may be the same as the BrowsePath for one of the InstanceDeclarations in the hierarchy of the TypeDefinitionNode. The InstanceDeclaration with the same BrowsePath is called the InstanceDeclaration for the Node. If a Node has an InstanceDeclaration then it shall have the same BrowseName and NodeClass as the InstanceDeclaration and, in cases of Variables and Objects, the same TypeDefinitionNode or a subtype of it.\nInstances may reference several Nodes with the same BrowsePath. Clients that need to distinguish between the Nodes based on the InstanceDeclarationHierarchy and the Nodes that are not based on the InstanceDeclarationHierarchy can accomplish this using the TranslateBrowsePathsToNodeIds service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "9846b04d-6d83-4470-901f-c39dd3944ce2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4 Instances of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.4.2 Creating an Instance"
    },
    {
      "Id": "8b969c63-5539-4a01-959c-b20377a36fa9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.2 Creating an Instance\n---\n",
      "Content": "Instances inherit the initial values for the Attributes that they have in common with the TypeDefinitionNode from which they are instantiated, with the exceptions of the NodeClass and NodeId.\nWhen a Server creates an instance of a TypeDefinitionNode it shall create the same hierarchy of Nodes beneath the new Object or Variable depending on the ModellingRule of each InstanceDeclaration. Standard ModellingRules are defined in[6.4.4.4](/\u00A7_Ref181851957). The Nodes within the newly created hierarchy may be copies of the InstanceDeclaration s, the InstanceDeclaration itself or another Node in the AddressSpace that has the same TypeDefinitionNode and BrowseName. If new copies are created, then the Attribute values of the InstanceDeclarations are used as the initial values. An instance shall not be a SourceNode of a hierarchical Reference that has the same BrowsePath as an InstanceDeclaration of its TypeDefinition which has an optional or mandatory ModellingRule except for the one based on the InstanceDeclaration.\n[Figure 27](/\u00A7_Ref187074518) provides a simple example of a TypeDefinitionNode and an Instance. Nodes referenced by the TypeDefinitionNode without a ModellingRule do not appear in the instance. Instances may have children with duplicate BrowseName s; however, only one of those children will correspond to the InstanceDeclaration."
    },
    {
      "Id": "1bcdc147-f8a8-4919-af97-f1e08ab4422b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.2 Creating an Instance\nCaption: Figure 27 - An Instance and its TypeDefinitionNode\n---\n",
      "Content": "[image030.png](images/image030.png)"
    },
    {
      "Id": "2d84ff27-b87f-4097-957c-583766ead99a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.2 Creating an Instance\n---\n",
      "Content": "Figure 27 - An Instance and its TypeDefinitionNode\nIt is up to the Server to decide which InstanceDeclarations appear in any single instance. In some cases, the Server will not define the entire instance and will provide remote references to Nodes in another Server. The ModellingRules described in[6.4.4.4](/\u00A7_Ref181851957) allow Servers to indicate that some Nodes are always present; however, the Client shall be prepared for the case where the Node exists in a different Server.\nA Client can use the information of TypeDefinitionNodes to access Nodes which are in the hierarchy of the instance. It shall pass the NodeId of the instance and the BrowsePath of the child Nodes based on the TypeDefinitionNode to the TranslateBrowsePathsToNodeIds service (see[OPC 10000-4](/\u00A7UAPart4)). This Service returns the NodeId for each of the child Node s. If a child Node exists then the BrowseName and NodeClass shall match the InstanceDeclaration. In the case of Objects or Variables, also the TypeDefinitionNode shall either match or be a subtype of the original TypeDefinitionNode."
    },
    {
      "Id": "5259c223-4c1f-4a59-a411-d6c4d3855d30",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4 Instances of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.4.3 Constraints on an Instance"
    },
    {
      "Id": "cea3b5ac-47ed-436d-a8f7-7f7ab8978f51",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.3 Constraints on an Instance\n---\n",
      "Content": "Objects and Variables may change their Attribute values after being created. Special rules apply for some Attributes as defined in[6.2.7](/\u00A7_Ref181853444).\nAdditional References may be added to the Nodes, and References may be deleted as long as the ModellingRules defined on the InstanceDeclarations of the TypeDefinitionNode are still fulfilled.\nFor Variables and Objects the HasTypeDefinition Reference shall always point to the same TypeDefinitionNode as the InstanceDeclaration or a subtype of it.\nIf two InstanceDeclarations of the fully-inherited InstanceDeclarationHierarchy have been connected directly with several References, all those References shall connect the same Nodes. An example is given in[Figure 28](/\u00A7_Ref190857411). The instances A1 and A2 are allowed since B1 references the same Node with both References, whereas A3 is not allowed since two different Nodes are referenced. Note that this restriction only applies for directly connected Nodes. For example, A2 references a C1 directly and a different C1 via B1."
    },
    {
      "Id": "0afb4c2f-68d0-4ba0-89d4-fd49ce8ec037",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.3 Constraints on an Instance\nCaption: Figure 28 - Example for several References between InstanceDeclarations\n---\n",
      "Content": "[image031.png](images/image031.png)"
    },
    {
      "Id": "6f6fa8c0-74d2-4757-9f20-0104b23b2bee",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.3 Constraints on an Instance\n---\n",
      "Content": "Figure 28 - Example for several References between InstanceDeclarations"
    },
    {
      "Id": "496db671-6da4-4b31-8317-3f43e30804ba",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4 Instances of ObjectTypes and VariableTypes\n---\n",
      "Content": "6.4.4 ModellingRules"
    },
    {
      "Id": "7f90fc04-c8ce-417e-b121-8172f733ac6c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4 ModellingRules\n---\n",
      "Content": "6.4.4.1 General"
    },
    {
      "Id": "81561fa1-6135-46ac-abcc-aa8ccb26e8dd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.1 General\n---\n",
      "Content": "For a definition of ModellingRules, see[6.4.4.4](/\u00A7_Ref181851957). Other parts of this series of standards may define additional ModellingRules. ModellingRules are an extendable concept in OPC UA; therefore, vendors may define their own ModellingRules.\nNote that the ModellingRules defined in this standard do not define how to deal with NonHierarchical References between InstanceDeclarations, i.e. it is Server-specific if those References exist in an instance hierarchy or not. Other ModellingRules may define behaviour for NonHierarchical References between InstanceDeclaration as well.\nModellingRules are represented in the AddressSpace as Objects of the ObjectType ModellingRuleType. There are some Properties defining common semantic of ModellingRules. This edition of this standard only specifies one Property for ModellingRules. Future editions may define additional Properties for ModellingRules.[OPC 10000-5](/\u00A7UAPart5) specifies the representation of the ModellingRule Objects, their Properties and their type in the AddressSpace.\nSubclause[6.4.4.3](/\u00A7_Ref181519301) defines how the ModellingRule may be changed when instantiating InstanceDeclarations with respect to the Properties. Subclause[6.4.4.2](/\u00A7_Ref181851883) defines how the ModellingRule may be changed when overriding InstanceDeclarations in subtypes with respect to the Properties."
    },
    {
      "Id": "522cd371-ceb6-4772-a03c-066862e18279",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4 ModellingRules\n---\n",
      "Content": "6.4.4.2 Subtyping Rules for Properties of ModellingRules"
    },
    {
      "Id": "83880597-bd0c-4a18-9a24-e197e36f2df8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.2 Subtyping Rules for Properties of ModellingRules\n---\n",
      "Content": "It is allowed that subtypes override ModellingRules on their InstanceDeclarations. As a general rule for subtyping, constraints shall only be tightened, not loosened. Therefore, it is not allowed to specify on the supertype that an instance shall exist with the ModellingRule Mandatory and on the subtype make this ModellingRule Optional.[Table 21](/\u00A7_Ref182183906) specifies the allowed changes on the Properties when overriding the ModellingRules in the subtype.\nTable 21 - Rule for ModellingRules Properties when Subtyping"
    },
    {
      "Id": "3feb166a-f0da-4c6b-b81d-2f9c70f1d909",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.2 Subtyping Rules for Properties of ModellingRules\nCaption: Table 21 - Rule for ModellingRules Properties when Subtyping\n---\n",
      "Content": "ModellingRule on supertype\nModellingRule on subtype\nMandatory\nMandatory\nOptional\nMandatory or Optional\nMandatoryPlaceholder\nMandatoryPlaceholder\nOptionalPlaceholder\nMandatoryPlaceholder or OptionalPlaceholder"
    },
    {
      "Id": "7e29b826-c0a1-4ce2-a722-118106ff0d50",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4 ModellingRules\n---\n",
      "Content": "6.4.4.3 Instantiation Rules for Properties of ModellingRules"
    },
    {
      "Id": "aff064eb-9c9f-4b4e-9fba-4ce1c485250b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.3 Instantiation Rules for Properties of ModellingRules\n---\n",
      "Content": "There are two different use cases when creating an instance \u0027A\u0027 based on a TypeDefinitionNode\u0027A_Type\u0027. Either \u0027A\u0027 is used as normal instance or it is used as an InstanceDeclaration of another TypeDefinitionNode.\nIn the first case, it is not required that newly created or referenced instances based on InstanceDeclarations have a ModellingRule, however, it is allowed that they have any ModellingRule independent of the ModellingRule of their InstanceDeclaration.\nIn[Figure 29](/\u00A7_Ref182213130) an example is given. The instances A1, A2, and A3 are all valid instances of Type_A, although B of A1 has no ModellingRule and B of A3 has a different ModellingRule than B of Type_A."
    },
    {
      "Id": "b7dab2f8-6103-4d76-99e4-342c247e6dfc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.3 Instantiation Rules for Properties of ModellingRules\nCaption: Figure 29 - Example on changing instances based on InstanceDeclarations\n---\n",
      "Content": "[image032.png](images/image032.png)"
    },
    {
      "Id": "bef2ca21-9e1d-46be-a832-9b76fe64186d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.3 Instantiation Rules for Properties of ModellingRules\n---\n",
      "Content": "Figure 29 - Example on changing instances based on InstanceDeclarations\nIn the second case, all instances that are referenced directly or indirectly from \u0027A\u0027 based on InstanceDeclarations of \u0027A_Type\u0027 initially maintain the same ModellingRule as their InstanceDeclarations. The ModellingRules may be updated; the allowed changes to the ModellingRules of these Nodes are the same as those defined for subtyping in[6.4.4.2](/\u00A7_Ref181851883).\nIn[Figure 30](/\u00A7_Ref182212624) an example of such a scenario is given. Type_B uses an InstanceDeclaration based on Type_A (upper part of the Figure). Later on the ModellingRule of the InstanceDeclaration A1 is changed (lower part of the Figure). A1 has become the NamingRule of Mandatory(changed from Optional)."
    },
    {
      "Id": "f7df4b73-a771-4938-b004-a41a3e939821",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.3 Instantiation Rules for Properties of ModellingRules\nCaption: Figure 30 - Example on changing InstanceDeclarations based on an InstanceDeclaration\n---\n",
      "Content": "[image033.png](images/image033.png)"
    },
    {
      "Id": "d8e2a999-d4f2-4098-b836-55b594015a88",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.3 Instantiation Rules for Properties of ModellingRules\n---\n",
      "Content": "Figure 30 - Example on changing InstanceDeclarations based on an InstanceDeclaration"
    },
    {
      "Id": "2242ab6a-2fe8-4c00-ac4b-21cddd2c559c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4 ModellingRules\n---\n",
      "Content": "6.4.4.4 Standard ModellingRules"
    },
    {
      "Id": "168cecef-88d6-49b3-9587-9205e52a9215",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4 Standard ModellingRules\n---\n",
      "Content": "6.4.4.4.1 Mandatory"
    },
    {
      "Id": "08418a8a-1bc1-4e97-a968-cbcbc98d3b0b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.1 Mandatory\n---\n",
      "Content": "An InstanceDeclaration marked with the ModellingRule Mandatory means that for each existing BrowsePath on the instance a similar Node shall exist, but it is not defined whether a new Node is created or an existing Node is referenced.\nFor example, the TypeDefinitionNode of a functional block \u0022AI_BLK_TYPE\u0022 will have a setpoint \u0022SP1\u0022. An instance of this type \u0022AI_BLK_1\u0022 will have a newly-created setpoint \u0022SP1\u0022 as a similar Node to the InstanceDeclaration SP1.[Figure 31](/\u00A7_Ref128221087) illustrates the example."
    },
    {
      "Id": "70e74ea7-f5c1-4484-ab0d-8d5b527c620e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.1 Mandatory\nCaption: Figure 31 - Use of the Standard ModellingRule Mandatory\n---\n",
      "Content": "[image034.png](images/image034.png)"
    },
    {
      "Id": "da781427-4703-40e5-800e-83d18e8f3e54",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.1 Mandatory\n---\n",
      "Content": "Figure 31 - Use of the Standard ModellingRule Mandatory\nIn[6.4.4.4.2](/\u00A7_Ref190859372) a complex example combining the Mandatory and Optional ModellingRules is given."
    },
    {
      "Id": "424adb68-fc8b-4871-925c-497c0a6ac803",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4 Standard ModellingRules\n---\n",
      "Content": "6.4.4.4.2 Optional"
    },
    {
      "Id": "10fa5f39-4ab2-42b5-80d5-c60e40a5784d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.2 Optional\n---\n",
      "Content": "An InstanceDeclaration marked with the ModellingRule Optional means that for each existing BrowsePath on the instance a similar Node may exist, but it is not defined whether a new Node is created or an existing Node is referenced.\nIn[Figure 32](/\u00A7_Ref190859404) an example using the ModellingRules Optional and Mandatory is shown. The example contains an ObjectType Type_A and all valid combinations of instances named A1 to A13. Note that if the optional B is provided, the mandatory E has to be provided as well, otherwise not. F is referenced by C and D. On the instance, this can be the same Node or two different Nodes with the same BrowseName(similar Node to InstanceDeclaration F). Not considered in the example is if the instances have ModellingRules or not. It is assumed that each F is similar to the InstanceDeclaration F, etc.\nIf there would be a NonHierarchical Reference between E and F in the InstanceDeclarationHierarchy, it is not specified if it occurs in the instance hierarchy or not. In the case of A10, there could be a reference from E to one F but not to the other F, or to both or none of them."
    },
    {
      "Id": "fb8dd476-18f5-4573-a31c-4a52325d0555",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.2 Optional\nCaption: Figure 32 - Example using the Standard ModellingRules Optional and Mandatory\n---\n",
      "Content": "[image035.png](images/image035.png)"
    },
    {
      "Id": "2f56e733-5fde-4bf0-84f6-d5b1efbad450",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.2 Optional\n---\n",
      "Content": "Figure 32 - Example using the Standard ModellingRules Optional and Mandatory"
    },
    {
      "Id": "7a5646e3-c2fc-4df3-bd6d-4f801c488ea0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4 Standard ModellingRules\n---\n",
      "Content": "6.4.4.4.3 ExposesItsArray"
    },
    {
      "Id": "662ac2d3-ae61-4cb1-afe5-e9022e6336dd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.3 ExposesItsArray\n---\n",
      "Content": "The ExposesItsArray ModellingRule exposes a special semantic on VariableTypes having a single- or multidimensional array as the data type. It indicates that each value of the array will also be exposed as a Variable in the AddressSpace.\nThe ExposesItsArray ModellingRule can only be applied on InstanceDeclarations of NodeClass Variable that are part of a VariableType having a single- or multidimensional array as its data type.\nThe Variable A having this ModellingRule shall be referenced by a forward hierarchical Reference from a VariableType B. B shall have a ValueRank value that is equal to or larger than zero. A should have a data type that reflects at least parts of the data that is managed in the array of B. Each instance of B shall reference one instance of A for each of its array elements. The used Reference shall be of the same type as the hierarchical Reference that connects B with A or a subtype of it. If there are more than one forward hierarchical References between A and B, then all instances based on B shall be referenced with all those References.\n[Figure 33](/\u00A7_Ref182215717) gives an example. A is an instance of Type_A having two entries in its value array. Therefore it references two instances of the same type as the InstanceDeclaration ArrayExpose. The BrowseNames of those instances are not defined by the ModellingRule. In general, it is not possible to get a Variable representing a specific entry in the array (e.g. the second). Clients will typically either get the array or access the Variables directly, so there is no need to provide that information."
    },
    {
      "Id": "9c74f65d-0e24-4c11-9efd-4d62a565e402",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.3 ExposesItsArray\nCaption: Figure 33 - Example on using ExposesItsArray\n---\n",
      "Content": "[image036.png](images/image036.png)"
    },
    {
      "Id": "c2a3ea05-7974-4c8d-aef3-50b6b8db6da2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.3 ExposesItsArray\n---\n",
      "Content": "Figure 33 - Example on using ExposesItsArray\nIt is allowed to reference A by other InstanceDeclarations as well. Those References have to be reflected on each instance based on A.\n[Figure 34](/\u00A7_Ref182215725) gives an example. The Property EUUnit is referenced by ArrayExpose and therefore each instance based on ArrayExpose references the instance based on the InstanceDeclaration EUUnit."
    },
    {
      "Id": "12309890-4d7b-4339-85d3-d7d2c35b0693",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.3 ExposesItsArray\nCaption: Figure 34 - Complex example on using ExposesItsArray\n---\n",
      "Content": "[image037.png](images/image037.png)"
    },
    {
      "Id": "14dd26bc-b081-4aa8-93b7-a52fb004d234",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.3 ExposesItsArray\n---\n",
      "Content": "Figure 34 - Complex example on using ExposesItsArray"
    },
    {
      "Id": "522eb9c5-c2e9-4ecb-85d3-8c77c7b0f220",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4 Standard ModellingRules\n---\n",
      "Content": "6.4.4.4.4 OptionalPlaceholder"
    },
    {
      "Id": "dcab33bb-c161-4c23-b3f0-82a962a7a991",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.4 OptionalPlaceholder\n---\n",
      "Content": "For Object and Variable the intention of the ModellingRule OptionalPlaceholder is to expose the information that a complex TypeDefinition expects from instances of the TypeDefinition to add instances with specific References without defining BrowseNames for the instances. For example, a Device might have a Folder for DeviceParameters, and the DeviceParameters should be connected with a HasComponent Reference. However, the names of the DeviceParameters are specific to the instances. The example is shown in[Figure 35](/\u00A7_Ref313523181), where an instance Device A adds two DeviceParameters in the Folder."
    },
    {
      "Id": "26c6d457-5d0e-47b4-9a50-619b71f0def9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.4 OptionalPlaceholder\nCaption: Figure 35 - Example using OptionalPlaceholder with an Object and Variable\n---\n",
      "Content": "[image038.png](images/image038.png)"
    },
    {
      "Id": "39593d78-79a7-4dbd-9ec7-7a440b7d62d6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.4 OptionalPlaceholder\n---\n",
      "Content": "Figure 35 - Example using OptionalPlaceholder with an Object and Variable\nThe ModellingRule OptionalPlaceholder adds no additional constraints on instances of the TypeDefinition. It just provides useful information when exposing a TypeDefinition. When the InstanceDeclaration is complex, i.e. it references other InstanceDeclarations with hierarchical References, these InstanceDeclarations are not further considered for instantiating the TypeDefinition.\nIt is recommended that the BrowseName and the DisplayName of InstanceDeclarations having the OptionalPlaceholder ModellingRule should be enclosed within angle brackets.\nWhen overriding the InstanceDeclaration, the ModellingRule shall remain OptionalPlaceholder.\nFor Methods, the ModellingRule OptionalPlaceholder is used to define the BrowseName where subtypes and instances provide more information. The Method definition with the OptionalPlaceholder only defines the BrowseName. An instance or subtype defines the InputArguments and OutputArguments. A subtype shall also change the ModellingRule to Optional or Mandatory. The Method is optional for instances. For example, a Device might have a Method to perform calibration however the specific arguments for the Method depend on the instance of the Device. In this example Device A does not implement the Method, Device B implements the Method with no arguments and Device C implements the Method accepting a mode argument to select how the calibration is to be performed. The example is shown in[Figure 36](/\u00A7_Ref482606898)."
    },
    {
      "Id": "4353a750-c081-4dfc-8ac3-35218ed4444a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.4 OptionalPlaceholder\nCaption: Figure 36 - Example using OptionalPlaceholder with a Method\n---\n",
      "Content": "[image039.png](images/image039.png)"
    },
    {
      "Id": "9eedef37-2d01-457b-9fc8-e9fb687cc82b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.4 OptionalPlaceholder\n---\n",
      "Content": "Figure 36 - Example using OptionalPlaceholder with a Method"
    },
    {
      "Id": "9d2fed11-6185-4261-812a-d567fc64bd1e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4 Standard ModellingRules\n---\n",
      "Content": "6.4.4.4.5 MandatoryPlaceholder"
    },
    {
      "Id": "d3807ee0-4937-4c2b-816f-7e93084495c5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.5 MandatoryPlaceholder\n---\n",
      "Content": "For Object and Variable the ModellingRule MandatoryPlaceholder has a similar intention as the ModellingRule OptionalPlaceholder. It exposes the information that a TypeDefinition expects of instances of the TypeDefinition to add instances defined by the InstanceDeclaration. However, MandatoryPlaceholder requires that at least one of those instances shall exist.\nFor example, when the DeviceType requires that at least one DeviceParameter shall exist without specifying the BrowseName for it, it uses MandatoryPlaceholder as shown in[Figure 37](/\u00A7_Ref313524645). Device A is a valid instance as it has the required DeviceParameter. Device B is not valid as it uses the wrong ReferenceType to reference a DeviceParameter ( Organizes instead of HasComponent) and Device C is not valid because it does not provide a DeviceParameter at all."
    },
    {
      "Id": "7ebc4e5d-5256-437d-baad-0509e3b060d4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.5 MandatoryPlaceholder\nCaption: Figure 37 - Example on using MandatoryPlaceholder for Object and Variable\n---\n",
      "Content": "[image040.png](images/image040.png)"
    },
    {
      "Id": "fb9aa0e5-445d-40b9-a7b1-ceedff78b6f7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.4.4.4.5 MandatoryPlaceholder\n---\n",
      "Content": "Figure 37 - Example on using MandatoryPlaceholder for Object and Variable\nThe ModellingRule MandatoryPlaceholder requires that each instance provides at least one instance with the TypeDefinition of the InstanceDeclaration or a subtype, and is referenced with the same ReferenceType or a subtype as the InstanceDeclaration. It does not require a specific BrowseName and thus cannot be used for the TranslateBrowsePathsToNodeIds Service(see[OPC 10000-4](/\u00A7UAPart4)).\nWhen the InstanceDeclaration is complex, i.e. it references other InstanceDeclarations with hierarchical References, these InstanceDeclarations are not further considered for instantiating the TypeDefinition.\nIt is recommended that the BrowseName and the DisplayName of InstanceDeclarations having the MandatoryPlaceholder ModellingRule should be enclosed within angle brackets.\nWhen overriding the InstanceDeclaration, the ModellingRule shall remain MandatoryPlaceholder.\nFor Methods, the ModellingRule MandatoryPlaceholder is used to define the BrowseName where subtypes and instances provide more information. The Method definition with the MandatoryPlaceholder only defines the BrowseName. An instance or subtype defines the InputArguments and OutputArguments. A subtype shall also change the ModellingRule to Mandatory. The Method is mandatory for instances."
    },
    {
      "Id": "4dc10acd-e253-4ee2-9b2b-eafaf4fd57c9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6 Type Model for ObjectTypes and VariableTypes\n---\n",
      "Content": "6.5 Changing Type Definitions that are already used"
    },
    {
      "Id": "b9b5a240-7b31-4b26-bb1f-958fd94f9aa6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 6.5 Changing Type Definitions that are already used\n---\n",
      "Content": "There is no behaviour specified regarding subtypes and instances when changing ObjectTypes and VariableTypes. It is Server-dependent, if those changes are reflected on the subtypes and instances of the types. However, all constraints defined for subtypes and instances shall be fulfilled. For example, it is not allowed to add a Property using the ModellingRule Mandatory on a type if instances of this type exist without the Property. In that case, the Server either has to add the Property to all instances of the type or adding the Property on the type has to be rejected."
    },
    {
      "Id": "f17f2be8-ca10-4833-b302-c78ecac7a89a",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "7 Standard ReferenceTypes"
    },
    {
      "Id": "613f4ab6-4948-4406-b0bb-bfb866a64a21",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.1 General"
    },
    {
      "Id": "ed317790-6bd8-4735-a4d6-3e7d260118c9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.1 General\n---\n",
      "Content": "This standard defines ReferenceTypes as an inherent part of the OPC UA Address Space Model.[Figure 38](/\u00A7_Ref126660523) informally describes the hierarchy of these ReferenceTypes. Other parts of this series of standards may specify additional ReferenceTypes. The remainder of[7](/\u00A7_Ref192918160) defines the ReferenceTypes.[OPC 10000-5](/\u00A7UAPart5) defines their representation in the AddressSpace."
    },
    {
      "Id": "ec5fbe93-35bc-4903-a007-989d5bdca4d2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.1 General\nCaption: Figure 38 - Standard ReferenceType Hierarchy\n---\n",
      "Content": "[image041.png](images/image041.png)"
    },
    {
      "Id": "e22a9422-5e94-4830-a2c4-d2a4ee995a8d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.1 General\n---\n",
      "Content": "Figure 38 - Standard ReferenceType Hierarchy"
    },
    {
      "Id": "72f04f4c-396a-4f35-be3c-6c65da232197",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.2 References ReferenceType"
    },
    {
      "Id": "81e5f474-b25b-4fef-8b8c-f44a5d538d06",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.2 References ReferenceType\n---\n",
      "Content": "The References ReferenceType is an abstract ReferenceType; only concrete subtypes of it shall be used as a Reference between Nodes in an OPC UA AddressSpace.\nThere is no semantic associated with this ReferenceType. This is the base type of all ReferenceTypes. All ReferenceTypes shall be a subtype of this base ReferenceType- either direct or indirect. The main purpose of this ReferenceType is allowing simple filter and queries in the corresponding Services of[OPC 10000-5](/\u00A7UAPart5).\nThere are no constraints defined for this abstract ReferenceType."
    },
    {
      "Id": "ca58dcf0-287c-4bc5-a904-ec7f77e0984b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.3 HierarchicalReferences ReferenceType"
    },
    {
      "Id": "925d3476-8d2b-4d4b-a919-437ff82e3bf7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.3 HierarchicalReferences ReferenceType\n---\n",
      "Content": "The HierarchicalReferences ReferenceType is an abstract ReferenceType; only subtypes of it can be used and they shall be a non-symmetric Reference.\nThe semantic of HierarchicalReferences is to denote that References of HierarchicalReferences span a hierarchy. It means that it may be useful to present Nodes related with References of this type in a hierarchical-like way. HierarchicalReferences does not forbid loops. For example, starting from Node\u0022A\u0022 and following HierarchicalReferences it may be possible to browse to Node\u0022A\u0022, again.\nIt is not permitted to have a Property as SourceNode of a Reference of any subtype of this abstract ReferenceType.\nIt is not allowed that the SourceNode and the TargetNode of a Reference of the ReferenceType HierarchicalReferences are the same, that is, it is not allowed to have self-references using HierarchicalReferences."
    },
    {
      "Id": "79a77acd-3be2-467d-ac16-79120406e25b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.4 NonHierarchicalReferences ReferenceType"
    },
    {
      "Id": "17f568f2-204d-4fdd-8d48-c3373f75e90b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.4 NonHierarchicalReferences ReferenceType\n---\n",
      "Content": "The NonHierarchicalReferences ReferenceType is an abstract ReferenceType; only subtypes of it can be used.\nThe semantic of NonHierarchicalReferences is to denote that its subtypes do not span a hierarchy and should not be followed when trying to present a hierarchy. To distinguish Hierarchical and NonHierarchical References, all concrete ReferenceTypes shall inherit from either hierarchical References or Non-hierarchical References, either direct or indirect.\nThere are no constraints defined for this abstract ReferenceType."
    },
    {
      "Id": "f865fcae-4985-415d-91e0-3cf9c5e07d4e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.5 HasChild ReferenceType"
    },
    {
      "Id": "b5547d8c-bbbc-484e-abf8-b8015cbd0b42",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.5 HasChild ReferenceType\n---\n",
      "Content": "The HasChild ReferenceType is an abstract ReferenceType; only subtypes of it can be used. It is a subtype of HierarchicalReferences.\nThe semantic is to indicate that References of this type span a non-looping hierarchy.\nStarting from Node\u0022A\u0022 and only following References of the subtypes of the HasChild ReferenceType it shall never be possible to return to \u0022A\u0022. But it is allowed that following the References there may be more than one path leading to another Node\u0022B\u0022."
    },
    {
      "Id": "03c1774d-b97d-4b1c-87d0-d388ccf63770",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.6 Aggregates ReferenceType"
    },
    {
      "Id": "3a0f6d9f-a00b-4696-b3a9-2fe3dce5cc60",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.6 Aggregates ReferenceType\n---\n",
      "Content": "The Aggregates ReferenceType is an abstract ReferenceType; only subtypes of it can be used. It is a subtype of HasChild.\nThe semantic is to indicate a part (the TargetNode) belongs to the SourceNode. It does not specify the ownership of the TargetNode.\nThere are no constraints defined for this abstract ReferenceType."
    },
    {
      "Id": "5d94119c-c849-4dbc-8b63-3bce62e13413",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.7 HasComponent ReferenceType"
    },
    {
      "Id": "6433554d-ac82-4a17-a2aa-4a8a692a9b96",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.7 HasComponent ReferenceType\n---\n",
      "Content": "The HasComponent ReferenceType is a concrete ReferenceType that can be used directly. It is a subtype of the Aggregates ReferenceType.\nThe semantic is a part-of relationship. The TargetNode of a Reference of the HasComponent ReferenceType is a part of the SourceNode. This ReferenceType is used to relate Objects or ObjectTypes with their containing Objects, DataVariables, and Methods. This ReferenceType is also used to relate complex Variables or VariableTypes with their DataVariables.\nLike all other ReferenceTypes, this ReferenceType does not specify anything about the ownership of the parts, although it represents a part-of relationship semantic. That is, it is not specified if the TargetNode of a Reference of the HasComponent ReferenceType is deleted when the SourceNode is deleted.\nThe TargetNode of this ReferenceType shall be a Variable, an Object or a Method.\nIf the TargetNode is a Variable, the SourceNode shall be an Object, an ObjectType, a DataVariable or a VariableType. By using the HasComponent Reference, the Variable is defined as DataVariable.\nIf the TargetNode is an Object or a Method, the SourceNode shall be an Object or ObjectType."
    },
    {
      "Id": "6071fd88-953f-45c4-b828-b45136fdae15",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.8 HasProperty ReferenceType"
    },
    {
      "Id": "ae8d52db-afca-4ea6-abc7-ccf901465201",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.8 HasProperty ReferenceType\n---\n",
      "Content": "The HasProperty ReferenceType is a concrete ReferenceType that can be used directly. It is a subtype of the Aggregates ReferenceType.\nThe semantic is to identify the Properties of a Node. Properties are described in[4.5.2](/\u00A7_Ref130228256).\nThe SourceNode of this ReferenceType can be of any NodeClass. The TargetNode shall be a Variable. By using the HasProperty Reference, the Variable is defined as Property. Since Properties shall not have Properties, a Property shall never be the SourceNode of a HasProperty Reference."
    },
    {
      "Id": "5bb7031c-034d-4e04-a2bc-17ad116d89a4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.9 HasOrderedComponent ReferenceType"
    },
    {
      "Id": "cb66fd66-57e9-4f6f-a229-b2620118cde2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.9 HasOrderedComponent ReferenceType\n---\n",
      "Content": "The HasOrderedComponent ReferenceType is a concrete ReferenceType that can be used directly. It is a subtype of the HasComponent ReferenceType.\nThe semantic of the HasOrderedComponent ReferenceType- besides the semantic of the HasComponent ReferenceType- is that when browsing from a Node and following References of this type or its subtype all References are returned in the Browse Service defined in[OPC 10000-4](/\u00A7UAPart4) in a well-defined order. The order is Server-specific, but the Client can assume that the Server always returns them in the same order.\nThere are no additional constraints defined for this ReferenceType."
    },
    {
      "Id": "89806497-f5a9-462b-8232-b2408248ba75",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.10 HasSubtype ReferenceType"
    },
    {
      "Id": "c6568c95-64e6-4ad2-86a7-15d582394a3a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.10 HasSubtype ReferenceType\n---\n",
      "Content": "The HasSubtype ReferenceType is a concrete ReferenceType that can be used directly. It is a subtype of the HasChild ReferenceType.\nThe semantic of this ReferenceType is to express a subtype relationship of types. It is used to span the ReferenceType hierarchy, whose semantic is specified in[5.3.3.3](/\u00A7_Ref126749286); a DataType hierarchy is specified in[5.8.3](/\u00A7_Ref128219564), and other subtype hierarchies are specified in Clause[6](/\u00A7_Ref128887286).\nThe SourceNode of References of this type shall be an ObjectType, a VariableType, a DataType or a ReferenceType and the TargetNode shall be of the same NodeClass as the SourceNode. Each ReferenceType shall be the TargetNode of at most one Reference of type HasSubtype."
    },
    {
      "Id": "d65edd21-a4cc-4e9f-bda0-ad10d848fbf3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.11 Organizes ReferenceType"
    },
    {
      "Id": "23d052dd-09a8-46dd-a727-8a6fe9f2334b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.11 Organizes ReferenceType\n---\n",
      "Content": "The Organizes ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of HierarchicalReferences.\nThe semantic of this ReferenceType is to organise Nodes in the AddressSpace. It can be used to span multiple hierarchies independent of any hierarchy created with the non-looping Aggregates References.\nThe SourceNode of References of this type shall be an Object, ObjectType or a View. If it is an Object then it should be an Object of the ObjectType FolderType or one of its subtypes (see[5.5.3](/\u00A7_Ref131474245)).\nThe TargetNode of this ReferenceType can be of any NodeClass."
    },
    {
      "Id": "0ea94522-64da-4ccc-8563-aa6d859ec309",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.12 HasModellingRule ReferenceType"
    },
    {
      "Id": "082944a8-f38c-44c1-b37b-0eb39e699b31",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.12 HasModellingRule ReferenceType\n---\n",
      "Content": "The HasModellingRule ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of NonHierarchicalReferences.\nThe semantic of this ReferenceType is to bind the ModellingRule to an Object, Variable or Method. The ModellingRule mechanisms are described in[6.4.4](/\u00A7_Ref128179460).\nThe SourceNode of this ReferenceType shall be an Object, Variable or Method. The TargetNode shall be an Object of the ObjectType\u0022ModellingRule\u0022 or one of its subtypes.\nEach Node shall be the SourceNode of at most one HasModellingRule Reference."
    },
    {
      "Id": "ae1057ce-c30b-457c-8416-6c8145356365",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.13 HasTypeDefinition ReferenceType"
    },
    {
      "Id": "0fc95825-c497-486b-954c-3f285a03ba0d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.13 HasTypeDefinition ReferenceType\n---\n",
      "Content": "The HasTypeDefinition ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of NonHierarchicalReferences.\nThe semantic of this ReferenceType is to bind an Object or Variable to its ObjectType or VariableType, respectively. The relationships between types and instances are described in[4.6](/\u00A7_Ref115168300).\nThe SourceNode of this ReferenceType shall be an Object or Variable. If the SourceNode is an Object, then the TargetNode shall be an ObjectType; if the SourceNode is a Variable, then the TargetNode shall be a VariableType.\nEach Variable and each Object shall be the SourceNode of exactly one HasTypeDefinition Reference."
    },
    {
      "Id": "7ce323ca-160d-4e5c-84f5-596462a72a11",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.14 HasEncoding ReferenceType"
    },
    {
      "Id": "923c51b2-6211-4abc-b402-1a1eb2cc199b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.14 HasEncoding ReferenceType\n---\n",
      "Content": "The HasEncoding ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of NonHierarchicalReferences.\nThe semantic of this ReferenceType is to reference DataTypeEncodings of a subtype of the Structure DataType.\nThe SourceNode of References of this type shall be a subtype of the Structure DataType.\nThe TargetNode of this ReferenceType shall be an Object of the ObjectType DataTypeEncodingType or one of its subtypes (see[5.8.4](/\u00A7_Ref131563956))."
    },
    {
      "Id": "d989418d-7e31-453b-8c83-319f657d35ff",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.15 GeneratesEvent"
    },
    {
      "Id": "400c9b68-39d9-490f-8a07-b4df1b6a2f84",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.15 GeneratesEvent\n---\n",
      "Content": "The GeneratesEvent ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of NonHierarchicalReferences.\nThe semantic of this ReferenceType is to identify the types of Events instances of ObjectTypes or VariableTypes may generate and Methods may generate on each Method call.\nThe SourceNode of References of this type shall be an ObjectType, a VariableType or a Method InstanceDeclaration.\nThe TargetNode of this ReferenceType shall be an ObjectType representing EventTypes, that is, the BaseEventType or one of its subtypes."
    },
    {
      "Id": "f691e21f-f400-4d63-9472-ee3c77dde88e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.16 AlwaysGeneratesEvent"
    },
    {
      "Id": "3747eba6-7c06-4e09-8ccd-ceb36d760fa2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.16 AlwaysGeneratesEvent\n---\n",
      "Content": "The AlwaysGeneratesEvent ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of GeneratesEvent.\nThe semantic of this ReferenceType is to identify the types of Events Methods have to generate on each Method call.\nThe SourceNode of References of this type shall be a Method InstanceDeclaration.\nThe TargetNode of this ReferenceType shall be an ObjectType representing EventTypes, that is, the BaseEventType or one of its subtypes."
    },
    {
      "Id": "5fafd256-d71c-4c66-be1b-a023857ae1a5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.17 HasEventSource"
    },
    {
      "Id": "b425e1bd-97d8-4f4c-bd4f-41cd036db3e0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.17 HasEventSource\n---\n",
      "Content": "The HasEventSource ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of HierarchicalReferences.\nThe semantic of this ReferenceType is to relate event sources in a hierarchical, non-looping organization. This ReferenceType and any subtypes are intended to be used for discovery of Event generation in a Server. They are not required to be present for a Server to generate an Event from its source (causing the Event) to its notifying Nodes. In particular, the root notifier of a Server, the Server Object defined in[OPC 10000-5](/\u00A7UAPart5), is always capable of supplying all Events from a Server and as such has implied HasEventSource References to every event source in a Server.\nThe SourceNode of this ReferenceType shall be an Object or View that is a source of Event Subscriptions. A source of Event Subscriptions is an Object or View that has its \u0022SubscribeToEvents\u0022 bit set within the EventNotifier Attribute. The SourceNode may also be an ObjectType when referencing an InstanceDeclaration where an instance of the ObjectType containing the InstanceDeclaration generates events. Note the ObjectType is not considered a source of Event Subscriptions.\nThe TargetNode of this ReferenceType can be a Node of any NodeClass that can generate event notifications via a subscription to the reference source.\nStarting from Node\u0022A\u0022 and only following References of the HasEventSource ReferenceType or of its subtypes it shall never be possible to return to \u0022A\u0022. But it is permitted that, following the References, there may be more than one path leading to another Node\u0022B\u0022."
    },
    {
      "Id": "7f6099e6-85b4-41d3-b160-79712c974322",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.18 HasNotifier"
    },
    {
      "Id": "79c9f701-784b-4e22-ae84-9ac278c3288b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.18 HasNotifier\n---\n",
      "Content": "The HasNotifier ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of HasEventSource.\nThe semantic of this ReferenceType is to relate Object Nodes that are notifiers with other notifier Object Nodes. The ReferenceType is used to establish a hierarchical organization of event notifying Objects. It is a subtype of the HasEventSource ReferenceType defined in[7.16](/\u00A7_Ref135713256).\nThe TargetNode of this ReferenceType shall be Objects that are a source of Event Subscriptions.\nIf the TargetNode of a Reference of this type generates an Event, then this Event shall also be provided in the SourceNode of the Reference.\nAn example of a possible organization of Event References is represented in[Figure 39](/\u00A7_Ref136076337). In this example an unfiltered Event subscription directed to the \u0022Pump\u0022 Object will provide the Event sources \u0022Start\u0022 and \u0022Stop\u0022 to the subscriber. An unfiltered Event subscription directed to the \u0022Area 1\u0022 Object will provide Event sources from \u0022Machine B\u0022, \u0022Tank A\u0022 and all notifier sources below \u0022Tank A\u0022."
    },
    {
      "Id": "b5d680bb-e69e-4f23-8bb9-0d145ba14435",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.18 HasNotifier\nCaption: Figure 39 - Event Reference Example\n---\n",
      "Content": "[image042.png](images/image042.png)"
    },
    {
      "Id": "6ac89f54-7316-4ecd-a606-0f2a797e0428",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.18 HasNotifier\n---\n",
      "Content": "Figure 39 - Event Reference Example\nA second example of a more complex organization of Event References is represented in[Figure 40](/\u00A7_Ref136313494). In this example, explicit References are included from the Server\u0027s Server Object, which is a source of all Server Events. A second Event organization has been introduced to collect the Events related to \u0022Tank Farm 1\u0022. An unfiltered Event subscription directed to the \u0022Tank Farm 1\u0022 Object will provide Event sources from \u0022Tank B\u0022, \u0022Tank A\u0022 and all notifier sources below \u0022Tank B\u0022 and \u0022Tank A\u0022."
    },
    {
      "Id": "de728d9a-9880-4e13-8102-fe9089f23bc3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.18 HasNotifier\nCaption: Figure 40 - Complex Event Reference Example\n---\n",
      "Content": "[image043.png](images/image043.png)"
    },
    {
      "Id": "9f9e063e-9a3a-4729-ab71-329795d8abb9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.18 HasNotifier\n---\n",
      "Content": "Figure 40 - Complex Event Reference Example"
    },
    {
      "Id": "239ef131-9298-419c-9c9e-8a52288733c4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.19 HasInterface ReferenceType"
    },
    {
      "Id": "3efe397c-0d88-4fda-a2f7-305b348c42fd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.19 HasInterface ReferenceType\n---\n",
      "Content": "The HasInterface ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of the NonHierarchical ReferenceType.\nThe semantic of this ReferenceType is to show the availability of the Interface on the SourceNode. The Interface concept is described in[4.10.2](/\u00A7_Ref529101469).\nThe SourceNode of this ReferenceType shall be an Object or ObjectType. Interfaces shall not be a SourceNode. The TargetNode shall be of a subtype of the BaseInterfaceType.\nOne SourceNode can refer to multiple Interfaces."
    },
    {
      "Id": "ab2b8a57-1709-4b77-b630-56101be97587",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.20 HasAddIn ReferenceType"
    },
    {
      "Id": "5e28042f-8aa2-4345-86ef-028f7dd57468",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.20 HasAddIn ReferenceType\n---\n",
      "Content": "The HasAddIn ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of the HasComponent ReferenceType.\nThe semantic of this ReferenceType is to bind an AddIn to another Node that is the source of this Reference. The AddIn concept is described in[4.10.3](/\u00A7_Ref529101481).\nThe SourceNode of this ReferenceType shall be an Object or ObjectType. The TargetNode shall be an Object.\nOne SourceNode can refer to multiple AddIns."
    },
    {
      "Id": "b5c20b2f-a1be-4a22-a067-cddb85c75677",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.21 IsDeprecated ReferenceType"
    },
    {
      "Id": "586f0aed-3ddb-4383-8f1a-44ee5959006e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.21 IsDeprecated ReferenceType\n---\n",
      "Content": "The IsDeprecated ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of the NonHierarchicalReferences ReferenceType.\nThe semantic of this ReferenceType is to indicate that a Node has been deprecated from an information model.\nThe SourceNode of this ReferenceType shall be a Node of any NodeClass. The TargetNode shall be an Object which represents the information model version where the Node was first deprecated. The DisplayName and Description of the TargetNode should suggest the information model version and other suggestions."
    },
    {
      "Id": "a3f00f3e-a914-49be-95b0-4cb5dd78f62c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.22 HasStructuredComponent ReferenceType"
    },
    {
      "Id": "a3ffb52c-7572-4879-8f74-ff05d2243ffe",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.22 HasStructuredComponent ReferenceType\n---\n",
      "Content": "7.22.1 Overview"
    },
    {
      "Id": "271a7cb8-2fdd-493a-990d-61658bafa5bb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.22.1 Overview\n---\n",
      "Content": "The HasStructuredComponent ReferenceType is a concrete ReferenceType and can be used directly. It is a subtype of the HasComponent ReferenceType.\nThe semantic of this ReferenceType is to indicate that a VariableType or Variable also exposes its Structure fields or Array elements as Variables in the information model.\nThe SourceNode of this ReferenceType shall be a VariableType or a Variable having a Structure DataType.\nWhen the Value of the SourceNode is a scalar then the TargetNode shall be a Variable which represents a field of the Structure DataType. The BrowseName of a DataVariable which is exposed shall be the same as the field name of the Structure DataType. The NamespaceIndex of the BrowseName shall be the same as the NamespaceIndex of the Structure DataType which first defines the field. The exposed fields shall be the same DataType and ValueRank as the field in the Structure. The Value is expected to represent the value of the Structure\u0027s field.\nWhen the Value of the SourceNode is an array then the BrowseName of the TargetNode shall be \u003CV[N]\u003E where \u0027V\u0027 is the BrowseName of the Parent Node and \u0027N\u0027 shall be the array index number. The NamespaceIndex of the BrowseName shall be the same as the NamespaceIndex of the DataType which first defines the field. For multidimensional arrays the BrowseName shall be \u003CV[M][N][\u2026]\u003E. The Value is expected to represent the value of the array index which the BrowseName describes. An example of this is shown in[Figure 41](/\u00A7_Ref58484627). In this example \u0027MyStructuredVariable\u0027 has a Structure DataType with 2 fields, \u0027FieldX\u0027 and \u0027FieldY\u0027 and an array size of 2.\n[image044.png](images/image044.png)\nFigure 41- Example of using HasStructuredComponent ReferencyType"
    },
    {
      "Id": "7b5283a3-a9fd-453d-bc44-d0b36c5846c0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.22 HasStructuredComponent ReferenceType\n---\n",
      "Content": "7.22.2 Differences between HasStructuredComponent and ExposesItsArray"
    },
    {
      "Id": "7326a1ba-0e26-41c5-ba38-fcce547dcc14",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.22.2 Differences between HasStructuredComponent and ExposesItsArray\n---\n",
      "Content": "The ReferenceType HasStructuredComponent can be used to expose the entries of a multi-dimensional array of a Variable as subvariables. The same is true for the ModellingRule ExposesItsArray. However, both concepts handle this differently, as described in this section.\nUsing the HasStructuredComponent ReferenceType, the BrowseName of the subvariable is defined and reflects the place in the array. That is, if the order in the array is changing, e.g. by deleting the first entry, the values of the correponding subvariables change, and the subvariable with the highest index is removed. When subscribing to a subvariable, the Client always get the value assigned to the place in the array. The same behaviour can be achieved when subscribing to the corresponding IndexRange on the parent Variable.\nUsing the ExposesItsArray ModellingRule, the BrowseName of the subvariables are not defined and do not reflect the place in the array. That is, if the order in the array is changing, e.g. by deleting the first entry, the values of the corresponding subvariables do not change, and the subvariable containing the first entry is removed. When subscribing to a subvariable, the order of the array is not considered. Even if the order is changing, the Client subscribing to the subvariable will observe the original subscribed content.\nIn[Figure 42](/\u00A7_Ref66218037), an example is given, visualizing the differences. VariableA uses HasStructuredComponent. When the first entry in the array is deleted, the Values of the Variables representing the first and second entry are changed accordingly, and the third Variable is deleted.\nVariableB uses ExposesItsArray. When the first entry in the array is deleted, the values of the Variables"
    },
    {
      "Id": "2f64f05a-48a5-44c3-bc37-05a4c96ea319",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.22.2 Differences between HasStructuredComponent and ExposesItsArray\n---\n",
      "Content": "Variables originally representing the second and third entry of the array do not change, but the Variable representing the first entry is deleted.\n[image045.png](images/image045.png)\nFigure 42- Difference between HasStructuredComponent and ExposesItsArray"
    },
    {
      "Id": "c874b7e9-da21-40b2-aa65-a9b839eb5818",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.23 AssociatedWith ReferenceType"
    },
    {
      "Id": "aafb34f6-99bc-4e5a-a909-b308e0b189c3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.23 AssociatedWith ReferenceType\n---\n",
      "Content": "The AssociatedWith ReferenceType is a concrete ReferenceType that can be used directly. It is a subtype of the NonHierarchicalReferences ReferenceType. The AssociatedWith reference is symmetric and has no InverseName.\nThe semantic of this ReferenceType is to provide some generic association between two Objects.\nThe SourceNode and TargetNode of References of this type shall be Objects."
    },
    {
      "Id": "b3b9f6e5-264a-4d78-9090-f35a43b22c46",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.24 UsesDataTypeRefinement"
    },
    {
      "Id": "7dbf690f-0f0f-49d9-902b-c1ac123b9dbd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.24 UsesDataTypeRefinement\n---\n",
      "Content": "The UsesDataTypeRefinement is a concrete ReferenceType and can be used directly. It is a subtype of NonHierarchicalReferences.\nThe semantic of this ReferenceType is to link from a place where a Structured DataType is used to an Object of DataTypeRefinementType SubtypeRestrictionType(see[OPC 10000-5](/\u00A7UAPart5)), restricting the usage of the Structured DataType and adding meta data.\nThe SourceNode of References of this type shall be a Variable having a Structured DataType. The Variable shall not be used as InstanceDeclaration.\nNote that Method Arguments can be further described using Variables referenced with a HasArgumentDescription. If the Method Argument is a Structured DataType, this Variable can be used as SourceNode for the UsesDataTypeRefinement to further refine the Structured DataType.\nEach Node shall be the SourceNode of at most one UsesDataTypeRefinement Reference.\nThe TargetNode of this ReferenceType shall be an Object of DataTypeRefinementType SubtypeRestrictionType(see[OPC 10000-5](/\u00A7UAPart5)) or a subtype. The DataType of the SourceNode and the DataType refined in the TargetNode shall be identical, no subtypes are allowed."
    },
    {
      "Id": "3c884e6b-5490-4f12-a2a8-53c2bb9cc095",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.25 HasFieldDescription"
    },
    {
      "Id": "4a7d76ac-4f59-47c9-9114-4bf39c49772d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.25 HasFieldDescription\n---\n",
      "Content": "The HasFieldDescription is a concrete ReferenceType and can be used directly. It is a subtype of HierarchicalReferences.\nThe semantic of this ReferenceType is to link from a DataTypeRefinement Object refining a Structured DataType to a Variable representing a field of that Structured DataType, containing additional metadata, that may potentially restrict the usage of the field.\nThe SourceNode of References of this type shall be an Object of DataTypeRefinementType or a subtype.\nThe TargetNode of this ReferenceType shall be a Variable of BaseDataVariableType or a subtype. The BrowseName of the Variable shall have the same name as the field of the Structured DataType that it refines, and the same NamespaceIndex as the DataType, where the field of the Structure is defined. The DataType of the Variable shall follow the rules defined in[5.8.5.2](/\u00A7_Ref199520192), i.e., it can only be further restricted.\nIt is not allowed to reference two Variables with the same BrowseName using the HasFieldDescription ReferenceType or a subtype from the same SourceNode."
    },
    {
      "Id": "060a3388-0171-45e0-95a7-3489e7985726",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.26 HasFieldDescriptionSetMandatory"
    },
    {
      "Id": "e649c045-a51c-4300-b19f-5e52f77dc2ae",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.26 HasFieldDescriptionSetMandatory\n---\n",
      "Content": "The HasFieldDescriptionSetMandatory is a concrete ReferenceType and can be used directly. It is a subtype of HasFieldDescription.\nThe semantic of this ReferenceType is, in addition to the semantic of its supertype, to indicate that the field shall be provided, although it is defined as optional field in the Structured DataType.\nThis ReferenceType shall only be applied to fields declared as optional, i.e., fields having IsOptional set to true of Structured DataTypes with StructureType StructureWithOptionalFields."
    },
    {
      "Id": "9df160c3-0d36-462b-bbc0-2d9cd56dd0ae",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.27 IsDisabledOptionalField"
    },
    {
      "Id": "ded78fa8-893e-4525-9346-eb3138c80e82",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.27 IsDisabledOptionalField\n---\n",
      "Content": "The IsDisabledOptionalField is a concrete ReferenceType and can be used directly. It is a subtype of HasFieldDescription.\nThe semantic of this ReferenceType is, in addition to the semantic of its supertype, to indicate that the field shall not be provided. This indicates to Clients, that the Server will never provide the optional field and that they are not allowed to write a value containing the optional field. For Unions that implies that the DataType of the field shall never be used in the Union.\nThis ReferenceType shall only be applied to fields declared as optional, i.e., either fields having IsOptional set to true on Structured DataTypes where the StructureType is StructureWithOptionalFields; or fields of Structured DataTypes where the StructureType is Union or UnionWithSubtypedValues.\nNote: As the ReferenceType defines that the field shall not be provided, adding additional restrictions or meta data is not helpful and should be avoided."
    },
    {
      "Id": "369ac5d8-a9fc-4c32-a7bc-a63d2b557543",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.28 UsesSubtypeRestriction"
    },
    {
      "Id": "b5fdc3da-523f-411c-b6b3-6141a01b9913",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.28 UsesSubtypeRestriction\n---\n",
      "Content": "The UsesSubtypeRestriction is a concrete ReferenceType and can be used directly. It is a subtype of NonHierarchicalReferences.\nThe semantic of this ReferenceType is to link from a Variable to an Object of SubtypeRestrictionType, restricting the usage of subtypes on values of the Variable.\nThe SourceNode of References of this type shall be a Variable. The Variable shall not be used as InstanceDeclaration.\nNote, that Method Arguments can be further described using Variables referenced with a HasArgumentDescription. This Variable can be used as SourceNode for the UsesSubtypeRestriction to further restrict the DataType.\nEach Node shall be the SourceNode of at most one UsesSubtypeRestriction Reference.\nThe TargetNode of this ReferenceType shall be an Object of SubtypeRestrictionType or a subtype. The DataType of the SourceNode and the DataType restricted in the TargetNode shall be identical."
    },
    {
      "Id": "28817b5a-8ace-4d8c-843b-42334540a192",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.29 AllowedSubtype"
    },
    {
      "Id": "14e31c01-e193-4034-a0f0-18c1f884e931",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.29 AllowedSubtype\n---\n",
      "Content": "The AllowedSubtype is a concrete ReferenceType and can be used directly. It is a subtype of HierarchicalReferences.\nThe semantic of this ReferenceType is to link from a SubtypeRestriction Object to a Variable defining one allowed subtype.\nThe SourceNode of References of this type shall be an Object of SubtypeRestrictionType(see[OPC 10000-5](/\u00A7UAPart5)) or a subtype.\nThe TargetNode of this ReferenceType shall be a Variable of BaseDataVariableType or a subtype. The DataType, ValueRank and ArrayDimensions of the Variable shall follow the rules defined in[5.8.6](/\u00A7_Ref199846837).\nIt is recommended that the BrowseName of the Variable describes the used DataType including its ValueRank. However, it should not use the NamespaceIndex of the DataType NodeId unless it is defined in the same Namespace.\nIt is not allowed to reference two Variables with the same BrowseName using the AllowedSubtype ReferenceType or a subtype from the same SourceNode."
    },
    {
      "Id": "6311862b-3e08-4394-8251-b38f688e3c96",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7 Standard ReferenceTypes\n---\n",
      "Content": "7.30 HasDataTypeRefinement"
    },
    {
      "Id": "928a65cd-fdf8-47a2-bd8e-f1c84ffa9f82",
      "Header": "Document: Part 3 - Address Space Model\nSection: 7.30 HasDataTypeRefinement\n---\n",
      "Content": "The HasDataTypeRefinement is a concrete ReferenceType and can be used directly. It is a subtype of HasChild.\nThe semantic of this ReferenceType is to link from a DataType to a DataTypeRefinement Object that defines the allowed refinements of instances of a DataType.\nThe SourceNode of References of this type shall be a DataType.\nThe TargetNode of this ReferenceType shall be a DataTypeRefinement Object or a subtype."
    },
    {
      "Id": "c0595874-3ffe-4f0f-8d4f-f403c7697c1a",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "8 Standard DataTypes"
    },
    {
      "Id": "27319255-809c-4676-b6c5-1d8300b218ad",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.1 General"
    },
    {
      "Id": "39ecc71a-9a9b-4e68-97af-f1f3177d2a76",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.1 General\n---\n",
      "Content": "The remainder of[8](/\u00A7_Ref153882879) defines DataTypes. Their representation in the AddressSpace and the DataType hierarchy is specified in[OPC 10000-5](/\u00A7UAPart5). Other parts of this series of standards may specify additional DataTypes."
    },
    {
      "Id": "08bba0f4-3b57-4c58-9c4c-2a6b79fa63d0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.2 NodeId"
    },
    {
      "Id": "5e32a890-fd73-4b62-8443-7c62a5e1cd1d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2 NodeId\n---\n",
      "Content": "8.2.1 General"
    },
    {
      "Id": "2c795e50-626b-4a48-a784-c187b6d3e87b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.1 General\n---\n",
      "Content": "This Built-in DataType is composed of three elements that identify a Node within a Server. They are defined in[Table 22](/\u00A7_Ref105731646).\nTable 22 - NodeId Definition"
    },
    {
      "Id": "9b1f4192-6b38-4ded-8875-869d68578b2b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.1 General\nCaption: Table 22 - NodeId Definition\n---\n",
      "Content": "Name\nType\nDescription\nNodeId\nstructure\n\nNamespaceIndex\nUInt16\nThe index for a namespace URI (see[8.2.2](/\u00A7_Ref135813328)).\nIdType\nEnum\nThe format and data type of the identifier (see[8.2.3](/\u00A7_Ref87971654)).\nIdentifier\n*\nThe identifier for a Node in the AddressSpace of an OPC UA Server(see[8.2.4](/\u00A7_Ref89485609))."
    },
    {
      "Id": "595d61ef-8969-44b5-bd77-5551316858e9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.1 General\n---\n",
      "Content": "See[OPC 10000-6](/\u00A7UAPart6) for a description of the encoding of the identifier into OPC UA Messages."
    },
    {
      "Id": "82ee6818-c28f-431d-a980-07806ebec835",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2 NodeId\n---\n",
      "Content": "8.2.2 NamespaceIndex"
    },
    {
      "Id": "fb02edc4-893b-4b89-9b21-6f09ffd0cb19",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.2 NamespaceIndex\n---\n",
      "Content": "The namespace is a URI that identifies the naming authority responsible for assigning the identifier element of the NodeId. Naming authorities include the local Server, the underlying system, standards bodies and consortia. It is expected that most Nodes will use the URI of the Server or of the underlying system.\nUsing a namespace URI allows multiple OPC UA Servers attached to the same underlying system to use the same identifier to identify the same Object. This enables Clients that connect to those Servers to recognise Objects that they have in common.\nNamespace URIs, like Server names, are identified by numeric values in OPC UA Services to permit more efficient transfer and processing (e.g. table lookups). The numeric values used to identify namespaces correspond to the index into the NamespaceArray. The NamespaceArray is a Variable that is part of the Server Object in the AddressSpace(see[OPC 10000-5](/\u00A7UAPart5) for its definition).\nThe URI for the OPC UA namespace is:\n\u0022http://opcfoundation.org/UA/\u0022\nIts corresponding index in the namespace table is 0.\nThe namespace URI is case sensitive."
    },
    {
      "Id": "d22fbeb1-a499-4b0f-821b-36509e3a73c5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2 NodeId\n---\n",
      "Content": "8.2.3 IdType"
    },
    {
      "Id": "9164c52a-c368-4415-aad6-dee203d9d5f3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.3 IdType\n---\n",
      "Content": "The IdType element identifies the type of the NodeId, its format and its scope. Its values are defined in[Table 23](/\u00A7_Ref95797689).\nTable 23 - IdType Values"
    },
    {
      "Id": "1053b669-33e3-46fc-a8f4-d5b427859997",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.3 IdType\nCaption: Table 23 - IdType Values\n---\n",
      "Content": "Name\nValue\nDescription\nNumeric\n0\nNumeric value\nString\n1\nString value\nGuid\n2\nGlobally Unique Identifier\nOpaque\n3\nNamespace specific format"
    },
    {
      "Id": "bf6cdc38-2c03-4487-9272-d889360dd760",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.3 IdType\n---\n",
      "Content": "Normally the scope of NodeIds is the Server in which they are defined. For certain types of NodeIds, NodeIds can uniquely identify a Node within a system, or across systems (e.g. GUIDs). System-wide and globally-unique identifiers allow Clients to track Nodes, such as work orders, as they move between OPC UA Servers as they progress through the system.\nOpaque identifiers are identifiers that are free-format byte strings that might or might not be human interpretable.\nString identifiers are case sensitive. That is, Clients shall consider them case sensitive. Servers are allowed to provide alternative NodeIds(see[5.2.2](/\u00A7_Ref288123649)) and using this mechanism Servers can handle NodeIds as case insensitive."
    },
    {
      "Id": "848d9195-141f-4ce2-ab6a-f77f259ae228",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2 NodeId\n---\n",
      "Content": "8.2.4 Identifier value"
    },
    {
      "Id": "99022001-5ad5-4ad4-8289-628f4b26421f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.4 Identifier value\n---\n",
      "Content": "The Identifier value element is used within the context of the first three elements to identify the Node. Its data type and format is defined by the IdType.\nIdentifier values of IdType String are restricted to 4096 characters and shall not contain Unicode control characters. Unicode control characters are defined by[Unicode C0](/\u00A7UnicodeC0) and[Unicode C1](/\u00A7UnicodeC1). Identifier values of IdType Opaque are restricted to 4096 bytes.\nA Node in the AddressSpace shall not have a null NodeId. However, many services defined in[OPC 10000-4](/\u00A7UAPart4) define special behaviour if a null NodeId is passed as a parameter.\nA canonical null NodeId has an IdType equal to Numeric, a NamespaceIndex equal to 0 and an Identifier equal to 0.\nIn addition to the canonical null NodeId the alternative values defined in[Table 24](/\u00A7_Ref139076802) shall be considered a null NodeId.\nTable 24 - NodeId Alternative Null Values"
    },
    {
      "Id": "d1ed0484-13f1-448d-9c65-9cbc1c8cf841",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.2.4 Identifier value\nCaption: Table 24 - NodeId Alternative Null Values\n---\n",
      "Content": "IdType\nNamespaceIndex\nNull Value\nString\n0\nA null or Empty String (\u0022\u0022)\nGuid\n0\nA Guid initialised with zeros (e.g. 00000000-0000-0000-0000-000000000000)\nOpaque\n0\nA null or Empty ByteString"
    },
    {
      "Id": "3f53b5ec-1d8f-4994-ae68-ff5542314442",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.3 QualifiedName"
    },
    {
      "Id": "1a1ab041-a433-4f39-bb29-17aee4059d66",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.3 QualifiedName\n---\n",
      "Content": "This Built-in DataType contains a qualified name. It is, for example, used as BrowseName. Its elements are defined in[Table 25](/\u00A7_Ref124647947). The name part of the QualifiedName is restricted to 512 characters and shall not contain Unicode control characters. Unicode control characters are defined by[Unicode C0](/\u00A7UnicodeC0) and[Unicode C1](/\u00A7UnicodeC1).\nTable 25 - QualifiedName Definition"
    },
    {
      "Id": "d16d33aa-d10d-4412-bc08-d82486f2e336",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.3 QualifiedName\nCaption: Table 25 - QualifiedName Definition\n---\n",
      "Content": "Name\nType\nDescription\nQualifiedName\nstructure\n\nNamespaceIndex\nUInt16\nIndex that identifies the namespace that defines the name.\nThis index is the index of that namespace in the local Server\u0027s NamespaceArray.\nThe Client may read the NamespaceArray Variable to access the string value of the namespace.\nName\nString\nThe text portion of the QualifiedName."
    },
    {
      "Id": "1163cf77-2045-4ca3-aaa2-3044fbf744c4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.3 QualifiedName\n---\n",
      "Content": ""
    },
    {
      "Id": "fcbcab6b-2982-4a92-a3fb-bcfc6c8fc067",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.4 LocaleId"
    },
    {
      "Id": "43b3ca27-3d90-4431-836b-939e3286de04",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.4 LocaleId\n---\n",
      "Content": "This Simple DataType is specified as a string that is composed of a language component and a country/region component as specified by[RFC 5646](/\u00A7IETF5646). The \u003Ccountry/region\u003E component is always preceded by a hyphen. The format of the LocaleId string is shown below:\n\u003Clanguage\u003E[-\u003Ccountry/region\u003E], where \u003Clanguage\u003E is the two letter[ISO 639](/\u00A7ISO639) code for a language, \u003Ccountry/region\u003E is the two letter[ISO 3166](/\u00A7ISO3166) code for the country/region.\nThe rules for constructing LocaleIds defined by[RFC 5646](/\u00A7IETF5646) are restricted as follows:\nthis specification permits only zero or one \u003Ccountry/region\u003E component to follow the \u003Clanguage\u003E component;\nthis specification also permits the \u0022-CHS\u0022 and \u0022-CHT\u0022 three-letter \u003Ccountry/region\u003E codes for \u0022Simplified\u0022 and \u0022Traditional\u0022 Chinese locales;\nthis specification also allows the use of other \u003Ccountry/region\u003E codes as deemed necessary by the Client or the Server.\nThis specification also allows the use of the \u0022mul\u0022 and \u0022qst\u0022 \u003Ccountry/region\u003E codes for representing multiple languages and substitutable text. When using these locales, a specific format of the String is used. This format is defined in[8.5](/\u00A7_Ref135813271).\n[Table 26](/\u00A7_Ref87759949) shows examples of OPC UA LocaleIds. Clients and Servers always provide LocaleIds that explicitly identify the language and the country/region.\nTable 26 - LocaleId Examples"
    },
    {
      "Id": "0288ab10-39d8-41b5-9eb8-f307e13512e8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.4 LocaleId\nCaption: Table 26 - LocaleId Examples\n---\n",
      "Content": "Locale\nOPC UA LocaleId\nEnglish\nen\nEnglish (US)\nen-US\nGerman\nde\nGerman (Germany)\nde-DE\nGerman (Austrian)\nde-AT"
    },
    {
      "Id": "30cdc613-7f1d-4e0c-a6ff-55fe2135f307",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.4 LocaleId\n---\n",
      "Content": "An empty or null string indicates that the LocaleId is unknown."
    },
    {
      "Id": "9271bc12-f6c2-4caa-a907-d94d53d96bda",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.5 LocalizedText"
    },
    {
      "Id": "2d2c5139-3c73-40de-97ad-01c9b5250ad5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5 LocalizedText\n---\n",
      "Content": "8.5.1 Type Definition"
    },
    {
      "Id": "20fde016-56f7-4fd8-991d-cd6fd8331aba",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.1 Type Definition\n---\n",
      "Content": "This Built-in DataType defines a structure containing a String in a locale-specific translation specified in the identifier for the locale. Its elements are defined in[Table 27](/\u00A7_Ref127968458).\nTable 27 - LocalizedText Definition"
    },
    {
      "Id": "9ca27d25-64da-47a7-a00e-33850c0829e6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.1 Type Definition\nCaption: Table 27 - LocalizedText Definition\n---\n",
      "Content": "Name\nType\nDescription\nLocalizedText\nstructure\n\nLocale\nLocaleId\nThe identifier for the locale (e.g. \u0022en-US\u0022).\nText\nString\nThe localized text."
    },
    {
      "Id": "b5b9ad32-bed1-48c9-b13f-2e7485cff0be",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.1 Type Definition\n---\n",
      "Content": ""
    },
    {
      "Id": "42f34089-cd9d-437a-9813-8b2b3de01333",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5 LocalizedText\n---\n",
      "Content": "8.5.2 Special locales"
    },
    {
      "Id": "50e046d2-a89c-4119-9cc2-29df154a48fa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2 Special locales\n---\n",
      "Content": "8.5.2.1 Type Definition"
    },
    {
      "Id": "d9a98358-1520-4ec5-a02d-413f3011377d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2.1 Type Definition\n---\n",
      "Content": "Two special locales may be used with LocalizedText to support multiple languages and text substitutions. When using the special locales the content of the Text element shall be a JSON encoded object. The JSON Text element should be in the JSON minified form.\nSpecial locales shall never be used as a Server\u0027s default locale."
    },
    {
      "Id": "d91a449a-4926-4736-abfc-9feaac8f2de2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2 Special locales\n---\n",
      "Content": "8.5.2.2 Multiple language locale"
    },
    {
      "Id": "a724bb0f-9023-4211-8998-632294cac4e1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2.2 Multiple language locale\n---\n",
      "Content": "The \u0022mul\u0022 locale is used to provide multiple languages in the Text element. The JSON object shall include a key \u0022t\u0022 which consists of an array of locale and text pairs with the locale being the first element of the pair array.\nAn example which provides 2 languages.\n{\n\u0022t\u0022:[\n[\u0022de-DE\u0022, \u0022Ich bin dein text 1,2345\u0022],\n[\u0022en-US\u0022, \u0022I\u0027m your text 1.2345\u0022]\n]\n}"
    },
    {
      "Id": "4669f637-f41e-4772-8456-65c09d4b06de",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2 Special locales\n---\n",
      "Content": "8.5.2.3 Substitutable text locale"
    },
    {
      "Id": "fb0a3b2d-df68-4d0c-91e9-d8b9fa8c36b9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2.3 Substitutable text locale\n---\n",
      "Content": "The \u0022qst\u0022 locale is used to provide consumer substitutions of the Text element in a single or in multiple languages. This locale extends the \u0022mul\u0022 locale defined in[8.5.2.2](/\u00A7_Ref152770384) and therefore shall include a key \u0022t\u0022 which provides the text that replacements are applied to.\nThe JSON object shall also contain a key \u0022r\u0022 which consists of an array of replacement key and replacement text pairs. These replacements shall be applied by the consumer to the \u0022t\u0022 text strings by replacing any occurrence of the replacement key with the replacement text.\nIf there is only one replacement text, and the text is encoded as a scalar the text isapplied to all languages.\nIf separate languages are provided the replacement texts shall be encoded as an array. In this case the first replacement text shall be applied to the first language, the second to the second language and so on. If there are less replacement texts than languages due to an error, no replacement takes place for the remaining languages, leaving the replacement key. The last example below illustrates these rules.\nA replacement key shall be unique and shall not be a substring of another replacement key. A consumer shall ensure replaced text shall not be replaced again by any subsequent replacement operation.\nAn example of a single language substitution.\n{\n\u0022t\u0022:[\n[\u0022en-US\u0022, \u0022I\u0027m your text @1@\u0022]\n],\n\u0022r\u0022:[\n[\u0022@1@\u0022, 1.2345]\n]\n}\n\n\u0022en-US\u0022 text after substitution\n\u0022I\u0027m your text 1.2345\u0022\n\nAn example which provides 2 languages with a substitution that apply to both languages.\n{\n\u0022t\u0022:[\n[\u0022de-DE\u0022, \u0022Ich bin dein text @1@\u0022],"
    },
    {
      "Id": "a05a1497-0d78-48f2-a4f7-fea7f4bc6bd8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.5.2.3 Substitutable text locale\n---\n",
      "Content": "[\u0022en-US\u0022, \u0022I\u0027m your text @1@\u0022]\n],\n\u0022r\u0022:[\n[\u0022@1@\u0022, 1.2345]\n]\n}\n\n\u0022de-DE\u0022 text after substitution\n\u0022Ich bin dein text 1,2345\u0022\n\u0022en-US\u0022 text after substitution\n\u0022I\u0027m your text 1.2345\u0022\n\nAn example which provides 2 languages with a substitution that apply to both languages and substitutions that apply to specific languages.\n{\n\u0022t\u0022:[\n[\u0022de-DE\u0022, \u0022Dieses@2@ Ist eine @1@ Meldung: /2/ hat das Problem %d6 verursacht!\u0022],\n[\u0022en-US\u0022, \u0022This@2@ is a @1@ Message: Problem %d6 was caused by /2/!\u0022]\n],\n\u0022r\u0022:[\n[\u0022%d6\u0022, 1.2345],\n[\u0022@1@\u0022, [\u0022g\u00FCltige\u0022, \u0022valid\u0022]],\n[\u0022/2/\u0022, 42],\n[\u0022@2@\u0022, [\u0022@\u0022]]\n]\n}\n\n\u0022de-DE\u0022 text after substitution\n\u0022Dieses@ Ist eine g\u00FCltige Meldung: 42 hat das Problem 1,2345 verursacht!\u0022\n\u0022en-US\u0022 text after substitution\n\u0022This@2@ is a valid Message: Problem 1.2345 was caused by 42!\u0022"
    },
    {
      "Id": "8a03c599-4e5d-4db9-94e0-96813d59c5f7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.6 Argument"
    },
    {
      "Id": "9924c700-425e-4688-8a6a-121301c0afef",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.6 Argument\n---\n",
      "Content": "This Structured DataType defines a Method input or output argument specification. It is for example used in the input and output argument Properties for Methods. Its elements are described in[Table 28](/\u00A7_Ref128132106).\nTable 28 - Argument Definition"
    },
    {
      "Id": "ed631351-5cf6-41f2-be5b-f38d02c9abda",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.6 Argument\nCaption: Table 28 - Argument Definition\n---\n",
      "Content": "Name\nType\nDescription\nArgument\nstructure\n\nName\nString\nThe name of the argument.\nDataType\nNodeId\nThe NodeId of the DataType of this argument.\nValueRank\nInt32\nIndicates whether the Datatype is an array and how many dimensions the array has.\nIt may have the following values:\nn \u003E 1: the Datatype is an array with the specified number of dimensions.\nOneDimension (1): The Datatype is an array with one dimension.\nOneOrMoreDimensions (0): The Datatype is an array with one or more dimensions.\nScalar (\u22121): The Datatype is not an array.\nAny (\u22122): The Datatype can be a scalar or an array with any number of dimensions.\nScalarOrOneDimension (\u22123): The Datatype can be a scalar or a one dimensional array.\nNOTE All DataTypes are considered to be scalar, even if they have array-like semantics like ByteString and String.\nArrayDimensions\nUInt32[]\nThis field specifies the maximum supported length of each dimension. If the maximum is unknown the value shall be 0.\nThe number of elements shall be equal to the value of the v alueRank field. This field shall be null if v alueRank \u2264 0.\nThe maximum number of elements of an array transferred on the wire is 2147483647 (max Int32).\nDescription\nLocalizedText\nA localised description of the argument."
    },
    {
      "Id": "c0ebb4b2-24d9-4fb0-852e-6b74c2e9f4d9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.6 Argument\n---\n",
      "Content": ""
    },
    {
      "Id": "3bcdf96e-75a0-4258-a84c-b92e3f91bd8f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.7 BaseDataType"
    },
    {
      "Id": "3d711528-2fd1-4ead-8f1e-3ae0245655d2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.7 BaseDataType\n---\n",
      "Content": "This abstract DataType defines a value that can have any valid DataType.\nIt defines a special value null indicating that a value is not present. This abstract DataType does not have an encoding defined in[OPC 10000-6](/\u00A7UAPart6). Any direct subtype shall only be defined in NamespaceIndex 0.\nA BaseDataType is an abstract DataType which represents any possible value including arrays of values. When an array of BaseDataTypes is specified each element of the array can be a scalar or array of any DataType.\nWhen a BaseDataType is used in conjunction with a ValueRank then the ValueRank specifies whether there is an array of BaseDataType values. The ValueRank does not restrict the content of each element."
    },
    {
      "Id": "6f767b8b-5255-4f6b-b266-9f704602600b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.8 Boolean"
    },
    {
      "Id": "04b45c3e-76ea-484a-b9e6-9142479a5234",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.8 Boolean\n---\n",
      "Content": "This Built-in DataType defines a value that is either TRUE or FALSE."
    },
    {
      "Id": "8ef941c0-1cbe-4f2f-bf03-e09aba0ea072",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.9 Byte"
    },
    {
      "Id": "bf83f2c9-8dd3-42e6-aa30-9c86af376ea5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.9 Byte\n---\n",
      "Content": "This Built-in DataType defines a value in the range of 0 to 255."
    },
    {
      "Id": "722eef27-1559-48f8-95f7-99f2d49e9751",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.10 ByteString"
    },
    {
      "Id": "be15e46f-4235-43b0-b5f7-055920f75fd3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.10 ByteString\n---\n",
      "Content": "This Built-in DataType defines a value that is a sequence of Byte values."
    },
    {
      "Id": "acb0c59e-ee71-425f-a0b2-816737e70986",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.11 DateTime"
    },
    {
      "Id": "c519ee44-2b8b-47a9-b965-643868635a46",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.11 DateTime\n---\n",
      "Content": "This Built-in DataType defines a Gregorian calendar date. Details about this DataType are defined in[OPC 10000-6](/\u00A7UAPart6)."
    },
    {
      "Id": "8948f7de-8d7b-4e47-8ff2-31bc4b3728e0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.12 Double"
    },
    {
      "Id": "dd20cf38-a155-472a-82ea-917aea3da7fd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.12 Double\n---\n",
      "Content": "This Built-in DataType defines a value that adheres to the[ISO/IEC/IEEE 60559:2020](/\u00A7ISO60559) double precision data type definition."
    },
    {
      "Id": "eecf9eee-50c4-4e1c-b667-e9140f0739fd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.13 Duration"
    },
    {
      "Id": "0e327e1e-2116-4320-8a46-388628389b9e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.13 Duration\n---\n",
      "Content": "This Simple DataType is a Double that defines an interval of time in milliseconds (fractions can be used to define sub-millisecond values). Negative values are generally invalid but may have special meanings where the Duration is used."
    },
    {
      "Id": "a571d104-87f1-4ad0-9c7b-813a3042719a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.14 Enumeration"
    },
    {
      "Id": "ac3c0f92-0e45-435c-bccb-9435a26ada03",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.14 Enumeration\n---\n",
      "Content": "This abstract DataType is the base DataType for all enumeration DataTypes like NodeClass defined in[8.29](/\u00A7_Ref130971442). All DataTypes inheriting from this DataType have special handling for the encoding as defined in[OPC 10000-6](/\u00A7UAPart6). All enumeration DataTypes shall inherit from this DataType.\nSome special rules apply when subtyping enumerations. Any enumeration DataType not directly inheriting from the Enumeration DataType can only restrict the enumeration values of its supertype. That is, it shall neither add enumeration values nor change the text associated to the enumeration value. As an example, the enumeration Days having {\u0027Mo\u0027, \u0027Tu\u0027, \u0027We\u0027, \u0027Th\u0027, \u0027Fr\u0027, \u0027Sa\u0027, \u0027Su\u0027} as values can be subtyped to the enumeration Workdays having {\u0027Mo\u0027, \u0027Tu\u0027, \u0027We\u0027, \u0027Th\u0027, \u0027Fr\u0027}. The other direction, subtyping Workdays to Days would not be allowed as Days has values not allowed by Workdays (\u0027Sa\u0027 and \u0027Su\u0027)."
    },
    {
      "Id": "61cd50cd-9676-4ad3-b467-956f638befd2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.15 Float"
    },
    {
      "Id": "d7581d50-ad1c-49f8-835a-7e72728f059f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.15 Float\n---\n",
      "Content": "This Built-in DataType defines a value that adheres to the[ISO/IEC/IEEE 60559:2020](/\u00A7ISO60559) single precision data type definition."
    },
    {
      "Id": "cd444504-0df4-49fb-bc77-43c69ad611ed",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.16 Guid"
    },
    {
      "Id": "91cc668a-26f5-46a4-a4f6-d969922fc0e2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.16 Guid\n---\n",
      "Content": "This Built-in DataType defines a value that is a 128-bit Globally Unique Identifier. Details about this DataType are defined in[OPC 10000-6](/\u00A7UAPart6)."
    },
    {
      "Id": "2875183f-a1a9-46f4-9a4c-5b75d349ff45",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.17 Sbyte"
    },
    {
      "Id": "74124c6c-8750-4264-9a84-a3c67eeace14",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.17 Sbyte\n---\n",
      "Content": "This Built-in DataType defines a value that is a signed integer between \u2212128 and 127 inclusive."
    },
    {
      "Id": "3cc8c8b9-a365-4b02-8803-ca8d78313d8f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.18 IdType"
    },
    {
      "Id": "79dd50b5-3003-45b8-9b39-ef0614125506",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.18 IdType\n---\n",
      "Content": "This DataType is an enumeration that identifies the IdType of a NodeId. Its values are defined in[Table 23](/\u00A7_Ref95797689). See[8.2.3](/\u00A7_Ref87971655) for a description of the use of this DataType in NodeIds."
    },
    {
      "Id": "3bea833b-9bda-457a-8253-28f764ebbe23",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.19 Image"
    },
    {
      "Id": "7963ec38-4679-4122-9d2b-9860bccca933",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.19 Image\n---\n",
      "Content": "This abstract DataType defines a ByteString representing an image."
    },
    {
      "Id": "f99116c0-eda9-43b5-b5e4-f39c054765ec",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.20 ImageBMP"
    },
    {
      "Id": "c8355088-a32c-42a5-be47-6b26b860476d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.20 ImageBMP\n---\n",
      "Content": "This Simple DataType defines a ByteString representing an image in BMP format."
    },
    {
      "Id": "b85acc80-20c2-463a-a405-275cfd3b14eb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.21 ImageGIF"
    },
    {
      "Id": "dbe459e6-26e8-4b5a-94bf-1998f0516278",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.21 ImageGIF\n---\n",
      "Content": "This Simple DataType defines a ByteString representing an image in GIF format."
    },
    {
      "Id": "7d4dcf3d-d397-473e-8c72-53b068074a78",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.22 ImageJPG"
    },
    {
      "Id": "8fb1f2c5-5582-4ec3-a7cd-242339dc0464",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.22 ImageJPG\n---\n",
      "Content": "This Simple DataType defines a ByteString representing an image in JPG format."
    },
    {
      "Id": "275a89c2-1972-4448-84cc-7f8eafafbb6c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.23 ImagePNG"
    },
    {
      "Id": "621109c5-038a-402d-9dff-3f5df26d93cf",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.23 ImagePNG\n---\n",
      "Content": "This Simple DataType defines a ByteString representing an image in PNG format."
    },
    {
      "Id": "9e100827-7830-4071-86b3-c37d1ec94b44",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.24 Integer"
    },
    {
      "Id": "7a04a014-5ab3-488d-b148-a596eb78e9ad",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.24 Integer\n---\n",
      "Content": "This abstract DataType defines an integer whose length is defined by its subtypes. This abstract DataType does not have an encoding defined in[OPC 10000-6](/\u00A7UAPart6). Any direct subtype shall only be defined in NamespaceIndex 0."
    },
    {
      "Id": "d2897d5c-82f0-464f-ba40-631ade2f44ab",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.25 Int16"
    },
    {
      "Id": "95d652c9-1ecb-46d1-81b6-ae461588c3ee",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.25 Int16\n---\n",
      "Content": "This Built-in DataType defines a value that is a signed integer between \u221232 768 and 32 767 inclusive."
    },
    {
      "Id": "ca5d0912-a53c-4365-8b8f-b1573deb40e6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.26 Int32"
    },
    {
      "Id": "7efdbd6a-3d07-4b12-8e27-cef407a7d00f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.26 Int32\n---\n",
      "Content": "This Built-in DataType defines a value that is a signed integer between \u22122 147 483 648 and 2 147 483 647 inclusive."
    },
    {
      "Id": "b0d5b3da-973c-42d3-a18c-8ad2fc22d324",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.27 Int64"
    },
    {
      "Id": "d840912d-b05b-4a6b-a993-49598ce2a8ae",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.27 Int64\n---\n",
      "Content": "This Built-in DataType defines a value that is a signed integer between \u22129 223 372 036 854 775 808 and 9 223 372 036 854 775 807 inclusive."
    },
    {
      "Id": "32899f8e-9a29-4b66-8b4e-8ef053ef0c73",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.28 TimeZoneDataType"
    },
    {
      "Id": "b73b9c46-47de-431a-b6bb-602d18846f95",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.28 TimeZoneDataType\n---\n",
      "Content": "This Structured DataType defines the local time that may or may not take daylight saving time into account. Its elements are described in[Table 29](/\u00A7_Ref361144410).\nTable 29 - TimeZoneDataType Definition"
    },
    {
      "Id": "16c65fcc-2f97-4347-95b1-cc1865af1621",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.28 TimeZoneDataType\nCaption: Table 29 - TimeZoneDataType Definition\n---\n",
      "Content": "Name\nType\nDescription\nTimeZoneDataType\nstructure\n\nOffset\nInt16\nThe offset in minutes from UtcTime\nDaylightSavingInOffset\nBoolean\nIf TRUE, then daylight saving time (DST) is in effect and offset includes the DST correction. If FALSE then the offset does not include the DST correction and DST may or may not have been in effect."
    },
    {
      "Id": "9a5a4cfd-04df-43b8-8a43-7777011200fa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.28 TimeZoneDataType\n---\n",
      "Content": ""
    },
    {
      "Id": "e6c5f4f9-6e37-4831-bdff-b27c32f124c3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.29 NodeClass"
    },
    {
      "Id": "29f4454a-9fb6-475a-a6d3-45471f0dc0ab",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.29 NodeClass\n---\n",
      "Content": "This DataType is an enumeration that identifies a NodeClass. Its values are defined in[Table 30](/\u00A7_Ref131332234).\nTable 30 - NodeClass Values"
    },
    {
      "Id": "10320962-34d5-47a4-bd52-03ef158d078d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.29 NodeClass\nCaption: Table 30 - NodeClass Values\n---\n",
      "Content": "Name\nValue\nDescription\nUnspecified\n0\nNo value is specified.\nObject\n1\nThe Node is an Object.\nVariable\n2\nThe Node is a Variable.\nMethod\n4\nThe Node is a Method.\nObjectType\n8\nThe Node is an ObjectType.\nVariableType\n16\nThe Node is a VariableType.\nReferenceType\n32\nThe Node is a ReferenceType.\nDataType\n64\nThe Node is a DataType.\nView\n128\nThe Node is a View."
    },
    {
      "Id": "b6f9177c-8440-42b0-962e-69ee1db705b0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.29 NodeClass\n---\n",
      "Content": ""
    },
    {
      "Id": "ce78c1ac-fd8e-4678-a0f0-eb641ea0e7ea",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.30 Number"
    },
    {
      "Id": "b39024a1-e3b8-41eb-8f41-183e59c7719e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.30 Number\n---\n",
      "Content": "This abstract DataType defines a number. Details are defined by its subtypes. This abstract DataType does not have an encoding defined in[OPC 10000-6](/\u00A7UAPart6). Any direct subtype shall only be defined in NamespaceIndex 0."
    },
    {
      "Id": "13b5ae70-7ed2-4ef0-b66e-f1565fb5923b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.31 String"
    },
    {
      "Id": "de720d0e-8a9b-4ab7-baac-7e32819311af",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.31 String\n---\n",
      "Content": "This Built-in DataType defines a Unicode character string that should exclude control characters that are not whitespace characters. Unicode control characters are defined by[Unicode C0](/\u00A7UnicodeC0) and[Unicode C1](/\u00A7UnicodeC1). Unicode whitespace characters are defined in the[Unicode Property List](/\u00A7UnicodePropertyList)."
    },
    {
      "Id": "b889397c-0836-4ae3-8798-978f009db817",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.32 Structure"
    },
    {
      "Id": "e45b21e9-82d3-49f5-8883-1e450de0f36d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.32 Structure\n---\n",
      "Content": "This abstract DataType is the base DataType for all Structured DataTypes like Argument defined in[8.6](/\u00A7_Ref128132235). While abstract Structures may be defined with no fields a non-abstract Structure shall have one or more fields defined directly or from a super type. All DataTypes inheriting from this DataType have special handling for the encoding as defined in[OPC 10000-6](/\u00A7UAPart6)."
    },
    {
      "Id": "3d791cc6-140c-4bd7-85d3-c9fbb0f86341",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.33 UInteger"
    },
    {
      "Id": "9fbbba1d-a56c-45af-a04a-0248ab42c138",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.33 UInteger\n---\n",
      "Content": "This abstract DataType defines an unsigned integer whose length is defined by its subtypes. This abstract DataType does not have an encoding defined in[OPC 10000-6](/\u00A7UAPart6). Any direct subtype shall only be defined in NamespaceIndex 0."
    },
    {
      "Id": "f62cdee4-b8a6-4eb5-957b-e7df5420150e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.34 UInt16"
    },
    {
      "Id": "772edd03-c01b-480d-8f16-ad223524d625",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.34 UInt16\n---\n",
      "Content": "This Built-in DataType defines a value that is an unsigned integer between 0 and 65 535 inclusive."
    },
    {
      "Id": "dbe98b2f-6ebb-4c12-bbb1-29c5779bc1ca",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.35 UInt32"
    },
    {
      "Id": "8854c18e-b92e-47f0-bb70-56b672b84763",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.35 UInt32\n---\n",
      "Content": "This Built-in DataType defines a value that is an unsigned integer between 0 and 4 294 967 295 inclusive."
    },
    {
      "Id": "1dfe5644-a704-47a4-ad03-af07495d924d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.36 UInt64"
    },
    {
      "Id": "a35595ee-0272-4ef6-9211-a5a06e8099bd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.36 UInt64\n---\n",
      "Content": "This Built-in DataType defines a value that is an unsigned integer between 0 and 18 446 744 073 709 551 615 inclusive."
    },
    {
      "Id": "02f3f18f-788c-4a74-aed0-368a8fca56df",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.37 UtcTime"
    },
    {
      "Id": "5c3d9102-fc68-423c-84e3-14d408cbf338",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.37 UtcTime\n---\n",
      "Content": "This simple DataType is a DateTime used to define Coordinated Universal Time (UTC) values. All time values conveyed between OPC UA Servers and Clients are UTC values. Clients shall provide any conversions between UTC and local time.\nIt should be noted that the SourceTimestamp (see[OPC 10000-4](/\u00A7UAPart4)) and ServerTimestamp(see[OPC 10000-4](/\u00A7UAPart4)) may originate from different clocks that have no synchronization."
    },
    {
      "Id": "d39b2407-cf68-4bfb-8ef2-f415ed173723",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.38 XmlElement"
    },
    {
      "Id": "f58da262-a9ac-48d9-aa6a-45f41909cd33",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.38 XmlElement\n---\n",
      "Content": "This Built-in DataType is used to define XML elements.[OPC 10000-6](/\u00A7UAPart6) defines details about this DataType.\nXML data can always be modelled as a subtype of the Structure DataType with a single DataTypeEncoding that represents the XML complexType that defines the XML element (it is not necessary to have access to the XML Schema to define a DataTypeEncoding). For this reason a Server should never define Variables that use the XmlElement DataType unless the Server has no information about the XML elements that might be in the Variable Value."
    },
    {
      "Id": "76f81ca5-10bd-451b-b720-72c10e363c85",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.39 EnumValueType"
    },
    {
      "Id": "5e1ed4be-837c-453d-b953-e17fe6984055",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.39 EnumValueType\n---\n",
      "Content": "This Structured DataType is used to represent a human-readable representation of an Enumeration. Its elements are described in[Table 31](/\u00A7_Ref400915477). When this type is used in an array representing human-readable representations of an enumeration, each Value shall be unique in that array.\nTable 31 - EnumValueType Definition"
    },
    {
      "Id": "5a47bc27-a82e-4ec3-950a-48323186fd9a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.39 EnumValueType\nCaption: Table 31 - EnumValueType Definition\n---\n",
      "Content": "Name\nType\nDescription\nEnumValueType\nstructure\n\nValue\nInt64\nThe Integer representation of an Enumeration.\nDisplayName\nLocalizedText\nA human-readable representation of the Value of the Enumeration.\nDescription\nLocalizedText\nA localized description of the enumeration value. This field can contain an empty string if no description is available."
    },
    {
      "Id": "e65bbf6d-5cc7-4c87-9e71-377136ba8bb4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.39 EnumValueType\n---\n",
      "Content": "Note that the EnumValueType has been defined with an Int64 Value to meet a variety of usages. When it is used to define the string representation of an Enumeration DataType, the value range is limited to Int32, because the Enumeration DataType is a subtype of Int32.[OPC 10000-8](/\u00A7UAPart8) specifies other usages where the actual value might be between 8 and 64 Bit."
    },
    {
      "Id": "4bf3cdbe-09d5-4c4e-9831-5b46f74c8f86",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.40 OptionSet"
    },
    {
      "Id": "dbac2c41-bf12-4366-a19d-76faa997df07",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.40 OptionSet\n---\n",
      "Content": "This abstract DataType is the base DataType for all DataTypes representing a bit mask which is larger than 64 bits or where the validity of the bits within the set are to be identified. All OptionSet DataTypes representing bit masks shall inherit from this DataType. Its elements are described in[Table 32](/\u00A7_Ref380093296).\nTable 32 - OptionSet Definition"
    },
    {
      "Id": "347374df-ee81-4122-8eea-7d5aea9d739c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.40 OptionSet\nCaption: Table 32 - OptionSet Definition\n---\n",
      "Content": "Name\nType\nDescription\nOptionSet\nstructure\n\nValue\nByteString\nArray of bytes representing the bits in the option set. The length of the ByteString depends on the number of bits. The number of bytes may be larger than needed for the valid bits in the case of a spare allocation.\nValidBits\nByteString\nArray of bytes shall be the same size as value representing the valid bits in the value parameter. A Server shall return the StatusCode BadOutOfRange if it receives a different array size.\nWhen the Server returns the value to the Client, the validBits provides information of which bits in the bit mask have a meaning. If a bit is 1 then the corresponding bit in the value is used by the Server. If it is set to a 0 it should be ignored as it has no meaning. When the Client passes the OptionSet value to the Server, it sets the bits of validBits to 1 for each bit the Client expects the Server to apply to the value. The Server shall use the following logic when applying the requested change \u0022new value = (value \u0026 validBits) | (current value \u0026 ~validBits)\u0022.\nA Server shall reject any attempt to write to an invalid bit. A Server shall return the StatusCode BadOutOfRange if it receives validBits with a bit set to 1 which it does not consider a valid bit and shall not apply any bit changes."
    },
    {
      "Id": "8399b359-7cd3-421b-a21e-10c05d7a7709",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.40 OptionSet\n---\n",
      "Content": "The DataType Nodes representing concrete subtypes of the OptionSet shall have an OptionSetValues Property defined in[Table 16](/\u00A7_Ref115513367).\nAn OptionSet may be subtyped, however, any subtype shall not add any fields to the OptionSet Structure. The subtype may refine the semantics for the bits which are defined by the supertype and may add additional bits if the length of the OptionSet is not exceeded (see next paragraph). That requires, that each entry of the OptionSetValues Property of the supertype is repeated or refined by each subtype. Refining a bit shall not invalidate the original semantic. New OptionSetValues Properties may also be added to the subtype. For example, changing a bit from \u0022Pump is off\u0022 to \u0022First Pump is off\u0022 is allowed, but changing it to \u0022Motor is on\u0022 is not allowed.\nThe DataType Nodes representing concrete or abstract subtypes of the OptionSet may have an OptionSetLength Property defined in[Table 16](/\u00A7_Ref115513367). This Property defines the length in bytes of the OptionSet. If the Property is not defined, the length of a concrete OptionSet is defined by the number of defined bits (in the OptionSetValues Property) rounded up to whole bytes. For example, if there are two bits defined the length is one byte, if there are 10 bits defined, the length is two bytes. Once, the length has been defined by an OptionSet, subtypes shall not change the length. That is, if a supertype defines the length (either explicitly with OptionSetLength or implicitly by a concrete OptionSet with the OptionSetValues) each subtype shall have the same length. If the correct length is not implicitly provided by the length of the OptionSetValues the subtype shall provide the OptionSetLength Property"
    },
    {
      "Id": "0179b821-b690-40b3-9325-57d6de01fafa",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.40 OptionSet\n---\n",
      "Content": "OptionSetLength Property with the same value as the supertype.\nDefining the length explicitly in the OptionSetLength Property allows to reserve bits that can be used in subtypes of the OptionSet."
    },
    {
      "Id": "660675bf-bfca-4614-8420-082627ab90fc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.41 Union"
    },
    {
      "Id": "a7d801c4-7366-4541-a8fa-b68fe263873e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.41 Union\n---\n",
      "Content": "This abstract DataType is the base DataType for all union DataTypes. The DataType is a subtype of Structure DataType. All DataTypes inheriting from this DataType have special handling for the encoding as defined in[OPC 10000-6](/\u00A7UAPart6). All union DataTypes shall inherit directly from this DataType."
    },
    {
      "Id": "8784db9d-73a7-4800-973d-20e875c6cfac",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.42 DateString"
    },
    {
      "Id": "280857e4-5e07-47c3-abfc-c31ee9ba58a4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.42 DateString\n---\n",
      "Content": "This Simple DataType defines a value which is a day in the Gregorian calendar in string. Lexical representation of the string shall conform to calendar date defined in[ISO 8601-1:2019](/\u00A7ISO8601).\nNOTE: According to ISO 8601-1:2019, \u0027calendar date representations are in the form [YYYY-MM-DD]. [YYYY] indicates a four-digit year, 0000 through 9999. [MM] indicates a two-digit month of the year, 01 through 12. [DD] indicates a two-digit day of that month, 01 through 31. For example, \u0022the 5 th of April 1981\u0022 may be represented as either \u00221981-04-05\u0022 in the extended format or \u002219810405\u0022 in the basic format.\u0027\nNOTE: ISO 8601-1:2019 also allows for calendar dates to be written with reduced precision. For example, one may write \u00221981-04\u0022 to mean \u00221981 April\u0022, and one may simply write \u00221981\u0022 to refer to that year or \u002219\u0022 to refer to the century from 1900 to 1999 inclusive.\nNOTE: Although ISO 8601-1:2019 allows both the YYYY-MM-DD and YYYYMMDD formats for complete calendar date representations, if the day [DD] is omitted then only the YYYY-MM format is allowed. By disallowing dates of the form YYYYMM, ISO 8601-1:2019 avoids confusion with the truncated representation YYMMDD (still often used)."
    },
    {
      "Id": "1555ca7f-39dd-44f3-a6d4-093ac5e9b3fd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.43 DecimalString"
    },
    {
      "Id": "ca9b6110-78aa-45ad-87be-bd36387fd1f4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.43 DecimalString\n---\n",
      "Content": "This Simple DataType defines a value that represents a decimal number as a string. Lexical representation of the string shall conform to decimal type defined in W3C XML Schema Definition Language (XSD) 1.1 Part 2: DataTypes.\nThe DecimalString is a numeric string with an optional sign and decimal point."
    },
    {
      "Id": "8c8b3f18-2bb8-4779-a239-54ccdf35c620",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.44 DurationString"
    },
    {
      "Id": "3860403c-5fb2-413d-8494-86f9b7ea8054",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.44 DurationString\n---\n",
      "Content": "This Simple DataType defines a value that represents a duration of time as a string. It shall conform to duration as defined in[ISO 8601-1:2019](/\u00A7ISO8601).\nNOTE: According to[ISO 8601-1:2019](/\u00A7ISO8601)\u0027Durations are represented by the format P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W as shown to the right. In these representations, the [n] is replaced by the value for each of the date and time elements that follow the [n]. Leading zeros are not required, but the maximum number of digits for each element should be agreed to by the communicating parties. The capital letters P, Y, M, W, D, T, H, M, and S are designators for each of the date and time elements and are not replaced.\nP is the duration designator (historically called \u0022period\u0022) placed at the start of the duration representation.\nY is the year designator that follows the value for the number of years.\nM is the month designator that follows the value for the number of months.\nW is the week designator that follows the value for the number of weeks.\nD is the day designator that follows the value for the number of days.\nT is the time designator that precedes the time components of the representation.\nH is the hour designator that follows the value for the number of hours.\nM is the minute designator that follows the value for the number of minutes.\nS is the second designator that follows the value for the number of seconds."
    },
    {
      "Id": "a7d952e7-5321-4004-8318-61fc225e8924",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.44 DurationString\n---\n",
      "Content": "For example, \u0022P3Y6M4DT12H30M5S\u0022 represents a duration of \u0022three years, six months, four days, twelve hours, thirty minutes, and five seconds\u0022. Date and time elements including their designator may be omitted if their value is zero, and lower order elements may also be omitted for reduced precision. For example, \u0022P23DT23H\u0022 and \u0022P4Y\u0022 are both acceptable duration representations.\u0027"
    },
    {
      "Id": "9761f22c-5438-4960-8284-b01512084b13",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.45 NormalizedString"
    },
    {
      "Id": "0f1fc85e-a9d3-4f50-9e33-a5d340fe8287",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.45 NormalizedString\n---\n",
      "Content": "This Simple DataType defines a string value that shall be normalized according to Unicode Annex 15, Version 7.0.0, Normalization Form C.\nNOTE: Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. Unicode defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. The Win32 and the .NET Framework currently support normalization forms C, D, KC, and KD, as defined in Annex 15 of Unicode. NormalizedString uses Normalization Form C for all content, because this form avoids potential interoperability problems caused by the use of canonically equivalent, yet different, character sequences in document formats."
    },
    {
      "Id": "e9afda4a-e042-4d97-85e8-a9c210418af2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.46 TimeString"
    },
    {
      "Id": "b69dcbdc-bec9-4185-b969-8eca918ab33c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.46 TimeString\n---\n",
      "Content": "This Simple DataType defines a value that represents a time as a string. It shall conform to time of day as defined in[ISO 8601-1:2019](/\u00A7ISO8601).\nNOTE: ISO 8601-1:2019 uses the 24-hour clock system. The basic format is [hh][mm][ss] and the extended format is [hh]:[mm]:[ss].\n[hh] refers to a zero-padded hour between 00 and 24 (where 24 is only used to notate midnight at the end of a calendar day).\n[mm] refers to a zero-padded minute between 00 and 59.\n[ss] refers to a zero-padded second between 00 and 60 (where 60 is only used to notate an added leap second).\nThus a time might appear as either \u0022134730\u0022 in the basic format or \u002213:47:30\u0022 in the extended format.\nIt is also acceptable to omit lower order time elements for reduced accuracy: [hh]:[mm], [hh][mm] and [hh] are all used.\nMidnight is a special case and can be referred to as both \u002200:00\u0022 and \u002224:00\u0022. The notation \u002200:00\u0022 is used at the beginning of a calendar day and is the more frequently used. At the end of a day use \u002224:00\u0022"
    },
    {
      "Id": "6732cae0-e461-42c7-a6d1-64188bf8ad5c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.47 DataTypeDefinition"
    },
    {
      "Id": "2fefd4ab-fd3c-4e5d-a862-e24e9c25a416",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.47 DataTypeDefinition\n---\n",
      "Content": "This abstract DataType is the base type for all DataTypes used to provide the meta data for custom DataTypes like Structures and Enumerations."
    },
    {
      "Id": "0b1b953a-fe70-48d3-8c88-43757d1134bd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.48 StructureDefinition"
    },
    {
      "Id": "f9f6e909-9f7f-41b2-9114-cb8b24380b15",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.48 StructureDefinition\n---\n",
      "Content": "This Structured DataType is used to provide the meta data for a custom Structure DataType. It is derived from the DataType DataTypeDefinition. The StructureDefinition is formally defined in[Table 33](/\u00A7_Ref433696144).\nTable 33 - StructureDefinition Structure"
    },
    {
      "Id": "384f65a8-1628-41aa-92e7-70aaf9609132",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.48 StructureDefinition\nCaption: Table 33 - StructureDefinition Structure\n---\n",
      "Content": "Name\nType\nDescription\nStructureDefinition\nStructure\n\nDefaultEncodingId\nNodeId\nThe NodeId of the default DataTypeEncoding for the DataType.\nIf the DataType is only used inside nested Structures and is not directly contained in an ExtensionObject, the DefaultEncodingId is allowed to be null.\nIf the DataType is abstract the DefaultEncodingId shall be null.\nIn all other cases the DefaultEncodingId in the StructureDefinition shall be the Default Binary encoding for the DataType\nBaseDataType\nNodeId\nThe NodeId of the direct supertype of the DataType. This might be the abstract Structure or the Union DataType.\nStructureType\nStructureType\nAn enumeration that specifies the type of Structure defined by the DataType.\nThe StructureType DataType is defined in[8.49](/\u00A7_Ref50476465).\nOnly one of the fields defined for the data type is encoded into a value if the data type is a Union.\nFields\nStructureField []\nThe list of fields that make up the data type.\nThis definition assumes the structure has a sequential layout.\nThe StructureField DataType is defined in[8.51](/\u00A7_Ref433698626).\nFor Structures derived from another Structure DataType this list shall begin with the fields of the baseDataType followed by the fields of this StructureDefinition."
    },
    {
      "Id": "4b9abb3d-87a1-4864-a4f9-a33e915fc8f8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.48 StructureDefinition\n---\n",
      "Content": ""
    },
    {
      "Id": "73c2ccf4-a2b8-447f-8c88-87d71936cdbc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.49 StructureType"
    },
    {
      "Id": "9218b97b-ae2e-48fa-9878-6150dd013bb9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.49 StructureType\n---\n",
      "Content": "This DataType is an enumeration that specifies type of Structure defined by a StructureDefinition. Its values are defined in[Table 34](/\u00A7_Ref50475895).\nTable 34 - StructureType Values"
    },
    {
      "Id": "dde6cc3c-302f-458a-a25b-3348c32e9a92",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.49 StructureType\nCaption: Table 34 - StructureType Values\n---\n",
      "Content": "Name\nValue\nDescription\nStructure\n0\nA Structure without optional fields where none of the fields allow subtyping\nStructureWithOptionalFields\n1\nA Structure with optional fields where none of the fields allow subtyping\nUnion\n2\nA Union DataType where none of the fields allow subtyping\nStructureWithSubtypedValues\n3\nA Structure without optional fields where one or more of the fields allow subtyping\nUnionWithSubtypedValues\n4\nA Union DataType where one or more of the fields allow subtyping"
    },
    {
      "Id": "1cf280b4-0047-4f64-9aa3-818211cf8711",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.50 EnumDefinition"
    },
    {
      "Id": "56521027-66ba-45db-b11e-c6fdd2c497a0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.50 EnumDefinition\n---\n",
      "Content": "This Structured DataType is used to provide the metadata for a custom Enumeration or OptionSet DataType. It is derived from the DataType DataTypeDefinition. The EnumDefinition is formally defined in[Table 35](/\u00A7_Ref434350708).\nTable 35 - EnumDefinition Structure"
    },
    {
      "Id": "a5650dd0-5ac4-40bd-833c-b8c1536f4ada",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.50 EnumDefinition\nCaption: Table 35 - EnumDefinition Structure\n---\n",
      "Content": "Name\nType\nDescription\nEnumDefinition\nStructure\n\nFields\nEnumField []\nThe list of fields that make up the data type.\nThe EnumField DataType is defined in[8.52](/\u00A7_Ref434351996)."
    },
    {
      "Id": "d99e9ea7-93d4-48a9-b410-35d5b64ca349",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.50 EnumDefinition\n---\n",
      "Content": ""
    },
    {
      "Id": "36c4a4a2-f08a-433d-81b7-f64aa9b1d305",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.51 StructureField"
    },
    {
      "Id": "12c51c6e-2b14-47b9-80a9-d8cf05cdf0a6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.51 StructureField\n---\n",
      "Content": "This Structured DataType is used to provide the metadata for a field of a custom Structure DataType. The StructureField is formally defined in[Table 36](/\u00A7_Ref433696154).\nTable 36 - StructureField Structure"
    },
    {
      "Id": "d7f33305-76f9-485e-b557-965886e81230",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.51 StructureField\nCaption: Table 36 - StructureField Structure\n---\n",
      "Content": "Name\nType\nDescription\nStructureField\nStructure\n\nName\nString\nA name for the field that is unique within the StructureDefinition. The name is restricted to 512 characters and shall not contain Unicode control characters.Unicode control characters are defined by[Unicode C0](/\u00A7UnicodeC0) and[Unicode C1](/\u00A7UnicodeC1).\nDescription\nLocalizedText\nA localized description of the field\nDataType\nNodeId\nThe NodeId of the DataType for the field. When used by a StructureDefinition with a structureType of Structure, StructureWithOptionalFields or Union then the datatype shall be a concrete DataType, BaseDataType DataType or Structure DataType\nIf the structureType is StructureWithSubtypedValues, or UnionWithSubtypedValues and the isOptional field is TRUE then the encoding of the field shall be able to transport any subtype of the DataType.[OPC 10000-6](/\u00A7UAPart6) provides more details of specific encodings.\nValueRank\nInt32\nThe value rank for the field.\nIt shall be Scalar (-1) or a fixed rank Array (\u003E=1).\nArrayDimensions\nUInt32[]\nThis field specifies the maximum supported length of each dimension. If the maximum is unknown the value shall be 0.\nThe number of elements shall be equal to the value of the v alueRank field. This field shall be null if v alueRank \u2264 0.\nThe maximum number of elements of an array transferred on the wire is 2 147 483 647 (max Int32).\nMaxStringLength\nUInt32\nIf the dataType field is a String, LocalizedText (text field) or ByteString then this field specifies the maximum supported length in bytes. If the maximum is unknown the value shall be 0."
    },
    {
      "Id": "f2339257-85f1-4687-9b9b-aba420bdf2ea",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.51 StructureField\nCaption: Table 36 - StructureField Structure\n---\n",
      "Content": "If the dataType field is not a String or ByteString the value shall be 0.\nIf the valueRank is greater than 0 this field applies to each element of the array.\nIsOptional\nBoolean\nIf the structureType is StructureWithOptionalFields this field indicates if a data type field in a Structure is optional. In this case a value of FALSE means the StructureField is always present in all occurances of the Structure DataType and a value of TRUE means the StructureField may be present in an occurance of the Structure DataType.\nIf the structureType is Structure or Union this field shall be FALSE and shall be ignored.\nIf the structureType is StructureWithSubtypedValues, or UnionWithSubtypedValues this field is used to indicate if the data type field allows subtyping. Subtyping is allowed when set to TRUE."
    },
    {
      "Id": "d1e08a5e-fc41-4145-9da0-013511e9638b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.51 StructureField\n---\n",
      "Content": "StructureFields can be exposed as DataVariables that are children of the Variable that contains the Structure Value. In this case the BrowseName of the DataVariable shall be the same as the StructureField name and the NamespaceIndex of the BrowseName shall be the same as the Structure DataType Node NamespaceIndex.\n[OPC 10000-6](/\u00A7UAPart6) defines a number of DataEncodings which specify how to serialize Structure DataTypes. Some of these DataEncodings are text based and make use of Name field. For this reason, the Name should be a String that starts with a letter and contains only letters, digits or the underscore (_). If a StructureField has a Name that does not meet these requirements it will be transformed using the Name encoding rules defined in[OPC 10000-6](/\u00A7UAPart6) into a String that meets the requirements. This will result in text based DataEncodings with Names that are not friendly to human readers."
    },
    {
      "Id": "17b3bfad-46ad-4c7c-932f-7ed230cbc17b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.52 EnumField"
    },
    {
      "Id": "0c2bea57-6955-4882-a639-f756d591704d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.52 EnumField\n---\n",
      "Content": "This Structured DataType is used to provide the metadata for a field of a custom Enumeration or OptionSet DataType. It is derived from the DataType EnumValueType. If used for an OptionSet DataType, the corresponding Value in the base type contains the number of the bit associated with the field. The EnumField is formally defined in[Table 37](/\u00A7_Ref434351967).\nTable 37 - EnumField Structure"
    },
    {
      "Id": "4cd6828b-2555-42bf-a80c-2ee8a6ff5836",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.52 EnumField\nCaption: Table 37 - EnumField Structure\n---\n",
      "Content": "Name\nType\nDescription\nEnumField\nStructure\n\nName\nString\nA name for the field that is unique within the EnumDefinition."
    },
    {
      "Id": "c5353cbe-fd7b-42c1-b19a-c055525a2e6e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.52 EnumField\n---\n",
      "Content": "[OPC 10000-6](/\u00A7UAPart6) defines a number of DataEncodings which specify how to serialize Enumeration DataTypes. Some of these DataEncodings are text based and make use of Name field. For this reason, the Name should be a String that starts with a letter and contain only letters, digits or the underscore (_). If an EnumField has a Name that does not meet these requirements it will be transformed using the Name encoding rules defined in[OPC 10000-6](/\u00A7UAPart6) into a String that meets the requirements. This will result in text based DataEncodings with Names that are not friendly to human readers."
    },
    {
      "Id": "d2775a9b-ee08-4b47-8496-cfcc98ce7636",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.53 AudioDataType"
    },
    {
      "Id": "bd6a4416-f52e-4bd4-a2f4-607f919440b7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.53 AudioDataType\n---\n",
      "Content": "This abstract DataType defines a ByteString representing audio data. The audio stored in the ByteString could be formats like WAV or MP3 or any number of other audio formats. These formats are self-describing as part of the ByteString and are not specified in this specification."
    },
    {
      "Id": "934a34da-4caf-4bbb-97df-4a1a56bfa5bb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.54 Decimal"
    },
    {
      "Id": "5fa40de2-643a-467d-bcd1-0192025d3a6a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.54 Decimal\n---\n",
      "Content": "This Simple DataType, which is treated as a Built-in DataType, defines a high-precision signed number. It consists of an arbitrary precision integer unscaled value and an integer scale. The scale is the inverse power of ten that is applied to the unscaled value."
    },
    {
      "Id": "b5f9d66e-53fe-4845-84f3-04b18e28f8a3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.55 PermissionType"
    },
    {
      "Id": "f81d7bb5-5606-4dad-9e5f-a7572f1136f8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.55 PermissionType\n---\n",
      "Content": "This is a subtype of the UInt32 DataType with the OptionSetValues Property defined. It is used to define the permissions of a Node. The PermissionType is formally defined in[Table 38](/\u00A7_Ref493172527).\nTable 38 - PermissionType Definition"
    },
    {
      "Id": "5888857d-dce4-4bcc-861f-f8c3a6c2ded1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.55 PermissionType\nCaption: Table 38 - PermissionType Definition\n---\n",
      "Content": "Name\nBit\nDescription\nBrowse\n0\nThe Client is allowed to see the references to and from the Node.\nThis implies that the Client is able to Read to Attributes other than the Value or the RolePermissions Attribute.\nThis Permission is valid for all NodeClasses.\nReadRolePermissions\n1\nThe Client is allowed to read the RolePermissions Attribute.\nThis Permission is valid for all NodeClasses.\nWriteAttribute\n2\nThe Client is allowed to write to Attributes other than the Value, Historizing or RolePermissions Attribute if the WriteMask indicates that the Attribute is writeable.\nThis bit affects the value of a UserWriteMask Attribute.\nThis Permission is valid for all NodeClasses.\nWriteRolePermissions\n3\nThe Client is allowed to write to the RolePermissions Attribute if the WriteMask indicates that the Attribute is writeable.\nThis bit affects the value of the UserWriteMask Attribute.\nThis Permission is valid for all NodeClasses.\nWriteHistorizing\n4\nThe Client is allowed to write to the Historizing Attributes if the WriteMask indicates that the Attribute is writeable.\nThis bit affects the value of the UserWriteMask Attribute.\nThis Permission is only valid for Variables.\nRead\n5\nThe Client is allowed to read the Value Attribute.\nThis bit affects the CurrentRead bit of the UserAccessLevel Attribute.\nThis Permission is only valid for Variables.\nWrite\n6\nThe Client is allowed to write the Value Attribute.\nThis bit affects the CurrentWrite bit of the UserAccessLevel Attribute.\nThis Permission is only valid for Variables.\nReadHistory\n7\nThe Client is allowed to read the history associated with a Node.\nFor Variables, this bit affects the HistoryRead bit of the UserAccessLevel Attribute.\nThis Permission"
    },
    {
      "Id": "4b05fb09-bb31-45ef-85c9-1ca8125b1b70",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.55 PermissionType\nCaption: Table 38 - PermissionType Definition\n---\n",
      "Content": "Attribute.\nThis Permission is only valid for Variables(for reading historical values), and Objects or Views(for reading historical events).\nInsertHistory\n8\nThe Client is allowed to insert the history associated with a Node.\nFor Variables, this bit affects the HistoryWrite bit of the UserAccessLevel Attribute.\nThis Permission is only valid for Variables(for inserting historical values), and Objects or Views(for inserting historical events).\nModifyHistory\n9\nThe Client is allowed to modify the history associated with a Node.\nFor Variables, this bit affects the HistoryWrite bit of the UserAccessLevel Attribute.\nThis Permission is only valid for Variables(for modifying historical values), and Objects or Views(for modifying historical events).\nDeleteHistory\n10\nThe Client is allowed to delete the history associated with a Node.\nFor Variables, this bit affects the HistoryWrite bit of the UserAccessLevel Attribute.\nThis Permission is only valid for Variables(for deleting historical values), and Objects or Views(for deleting historical events).\nReceiveEvents\n11\nA Client only receives an Event if this bit is set on the Node identified by the EventTypeId field and on the Node identified by the SourceNode field.\nThis Permission is only valid for EventType Nodes or SourceNodes.\nCall\n12\nThe Client is allowed to call the Method if this bit is set on the Object or ObjectType Node passed in the Call request and the Method Instance associated with that Object or ObjectType.\nThis bit affects the UserExecutable Attribute when set on Method Node.\nThis Permission is only valid for Objects, ObjectType or Methods.\nAddReference\n13\nThe Client is allowed to add references to the Node.\nThis Permission is valid for all NodeClasses.\nRemoveReference\n14\nThe Client is allowed to remove references from the Node.\nThis Permission is valid for all"
    },
    {
      "Id": "b58bc8b7-c21f-42d6-9f17-f4b2c8a1e3c8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.55 PermissionType\nCaption: Table 38 - PermissionType Definition\n---\n",
      "Content": "Permission is valid for all NodeClasses.\nDeleteNode\n15\nThe Client is allowed to delete the Node.\nThis Permission is valid for all NodeClasses.\nAddNode\n16\nThe Client is allowed to add Nodes to the Namespace.\nThis Permission is only used in the DefaultRolePermissions and DefaultUserRolePermissions Properties of a NamespaceMetadata Object\nReserved\n17-31\nThese bits are reserved for use by OPC UA."
    },
    {
      "Id": "d1fedcd5-ec78-4ba9-9da5-b446ec57088b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.55 PermissionType\n---\n",
      "Content": ""
    },
    {
      "Id": "518810aa-7faa-4a37-b0f6-eb8ed3c3d91e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.56 AccessRestrictionType"
    },
    {
      "Id": "6a1c1ca1-6a30-45b0-ab2f-9c70f4f4ac89",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.56 AccessRestrictionType\n---\n",
      "Content": "This is a subtype of the UInt16 DataType with the OptionSetValues Property defined. It is used to define the access restrictions of a Node. The AccessRestrictionType is formally defined in[Table 39](/\u00A7_Ref493239274).\nTable 39 - AccessRestrictionType Definition"
    },
    {
      "Id": "fb516fe8-af5d-44a7-8946-b250a4cf5742",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.56 AccessRestrictionType\nCaption: Table 39 - AccessRestrictionType Definition\n---\n",
      "Content": "Name\nBit\nDescription\nSigningRequired\n0\nThe Client can only access the Node when using a SecureChannel which digitally signs all messages. This does not apply to the Browse permission if the ApplyRestrictionsToBrowse is not set.\nEncryptionRequired\n1\nThe Client can only access the Node when using a SecureChannel which encrypts all messages. This does not apply to the Browse permission if the ApplyRestrictionsToBrowse is not set.\nSessionRequired\n2\nThe Client cannot access the Node when using SessionlessInvoke Service invocation.\nApplyRestrictionsToBrowse\n3\nIf this bit is set, the access restrictions SigningRequired and EncryptionRequired are also applied to the Browse permission defined in[Table 38](/\u00A7_Ref493172527)."
    },
    {
      "Id": "b6860a77-cefb-47f6-ad63-05c91162e2dd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.56 AccessRestrictionType\n---\n",
      "Content": ""
    },
    {
      "Id": "852419aa-a01c-4db3-abcd-5cd94ecca967",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.57 AccessLevelType"
    },
    {
      "Id": "743136f5-0ae6-4a03-bf75-3a3b3ad55075",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.57 AccessLevelType\n---\n",
      "Content": "This is a subtype of the Byte DataType with the OptionSetValues Property defined. It is used to indicate how the Value of a Variable can be accessed (read/write) and if it contains current and/or historic data. The AccessLevelType is formally defined in[Table 40](/\u00A7_Ref494187161).\nTable 40 - AccessLevelType Definition"
    },
    {
      "Id": "c9a1311f-0127-434a-96cf-45da9aea11b6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.57 AccessLevelType\nCaption: Table 40 - AccessLevelType Definition\n---\n",
      "Content": "Name\nBit\nDescription\nCurrentRead\n0\nIndicates if the current value is readable. It also indicates if the current value of the Variable is available.(0 means not readable, 1 means readable).\nCurrentWrite\n1\nIndicates if the current value is writeable. It also indicates if the current value of the Variable is available.(0 means not writeable, 1 means writeable).\nHistoryRead\n2\nIndicates if the history of the value is readable. It also indicates if the history of the Variable is available via the OPC UA Server.(0 means not readable, 1 means readable).\nHistoryWrite\n3\nIndicates if the history of the value is writeable. It also indicates if the history of the Variable is available via the OPC UA Server.\n(0 means not writeable, 1 means writeable).\nSemanticChange\n4\nThis flag is set for Properties that define semantic aspects of the parent Node of the Property and where the Property Value, and thus the semantic, may change during operation.\n(0 means is not a semantic, 1 means is a semantic).\nStatusWrite\n5\nIndicates if the current StatusCode of the value is writeable\n(0 means only StatusCode Good is writeable, 1 means any StatusCode is writeable).\nTimestampWrite\n6\nIndicates if the current SourceTimestamp is writeable\n(0 means only null timestamps are writeable, 1 means any timestamp value is writeable).\nReserved\n7\nReserved for future use. Shall always be zero."
    },
    {
      "Id": "bcc2f09f-c3b0-4ad9-90cd-62a9aec1e8c1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.57 AccessLevelType\n---\n",
      "Content": ""
    },
    {
      "Id": "bdd67473-2a09-4ebb-b375-788a9d63651c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.58 AccessLevelExType"
    },
    {
      "Id": "65d3a78d-eca9-4612-bc4e-25de7e6faea9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\n---\n",
      "Content": "This is a subtype of the UInt32 DataType with the OptionSetValues Property defined. It is used to indicate how the Value of a Variable can be accessed (read/write), if it contains current and/or historic data and its atomicity.\nThe AccessLevelExType DataType is an extended version of the AccessLevelType DataType and as such contains the 8 bits of the AccessLevelType as the first 8 bits.\nThe NonatomicRead, and NonatomicWrite Fields represent the atomicity of a Variable. In general Atomicity is expected of OPC UA read and write operations. These Fields are used by systems, in particular hard-realtime controllers, which can not ensure atomicity.\nThe NoSubDataTypes Field represents the ability of a Variable to accept derived DataTypes. In general Variables are expected to allow the defined DataType or any subtype of that DataType. This Field is used to indicate a Variable restricts the DataType to only what is defined, that is no subtypes are allowed.\nThe NonVolatile Field represents the volatility of the Variable. This Field is used to indicate a Server shall ensure the Value of the Variable is persisted over a restart.\nThe Constant Field represents the changeability of the Variable and if changes in its Value trigger changes to the ConfigurationVersion Property of the NamespaceMetadata Object for the Namespace of the Variable. When this Field is 0 the Value of the Variable may change at any time and Value changes shall not trigger changes in the ConfigurationVersion Property. When this Field is 1 the Value of the Variable changes infrequently (e.g. by configuration change) and each change in Value shall trigger changes to the ConfigurationVersion Property(and the ConfigurationVersion Property shall be provided along with the parent NamespaceMetadata Object for the Namespace of the Variable).\n[Table 41](/\u00A7_Ref86909785) defines the combinations of"
    },
    {
      "Id": "54223cf1-5e46-42d5-aa90-1188417d9e72",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\n---\n",
      "Content": "defines the combinations of Constant and NonVolatile Fields and their use cases.\nTable 41 - Use Cases of Constant and NonVolatile Fields"
    },
    {
      "Id": "c48cd6c6-b8c4-476a-8c58-bc57bcbdf111",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\nCaption: Table 41 - Use Cases of Constant and NonVolatile Fields\n---\n",
      "Content": "Constant\nNonVolatile\nUse Case\n0\n0\nCan not be assumed to be constant or non-volatile\n0\n1\nNot constant and non-volatile\n1\n0\nconstant and volatile. The related ConfigurationVersion shall be changed with each Server restart.\n1\n1\nConstant and non-volatile"
    },
    {
      "Id": "cae9784b-2bfd-42d3-96ef-dc6ebde4b235",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\n---\n",
      "Content": "The AccessLevelExType is formally defined in[Table 42](/\u00A7_Ref494187171).\nTable 42 - AccessLevelExType Definition"
    },
    {
      "Id": "dd1318d5-1c81-4ec6-a284-ab4305bcb16d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\nCaption: Table 42 - AccessLevelExType Definition\n---\n",
      "Content": "Name\nBit\nDescription\nCurrentRead\n0\nSee[8.57](/\u00A7_Ref497896703).\nCurrentWrite\n1\nSee[8.57](/\u00A7_Ref497896703).\nHistoryRead\n2\nSee[8.57](/\u00A7_Ref497896703).\nHistoryWrite\n3\nSee[8.57](/\u00A7_Ref497896703).\nSemanticChange\n4\nSee[8.57](/\u00A7_Ref497896703).\nStatusWrite\n5\nSee[8.57](/\u00A7_Ref497896703).\nTimestampWrite\n6\nSee[8.57](/\u00A7_Ref497896703).\nReserved\n7\nSee[8.57](/\u00A7_Ref497896703).\nNonatomicRead\n8\nIndicates non-atomicity for Read access\n(0 means that atomicity is assured).\nNonatomicWrite\n9\nIndicates non-atomicity for Write access\n(0 means that atomicity is assured).\nWriteFullArrayOnly\n10\nIndicates if Write of IndexRange is supported\n(0 means Write of IndexRange is supported).\nNoSubDataTypes\n11\nIndicates if the Variable doesn\u0027t allow its DataType to be subtyped\n(0 means the Variable accepts the defined DataType and subtypes of that DataType).\nNonVolatile\n12\nIndicates if the Variable is non-volatile\n(0 means it is volatile or not known to be, 1 means non-volatile).\nConstant\n13\nIndicates if the Value of the Variable can be considered constant\n(0 means the Value is not constant, 1 means the Value is constant).\nReserved"
    },
    {
      "Id": "b3c2c36b-4a5e-4f7a-87cf-6494d72c6882",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\nCaption: Table 42 - AccessLevelExType Definition\n---\n",
      "Content": "Reserved\n14:31\nReserved for future use. Shall always be zero."
    },
    {
      "Id": "601ee89d-572e-403b-a1e1-cfbb32de9eed",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.58 AccessLevelExType\n---\n",
      "Content": ""
    },
    {
      "Id": "75a0f1e3-de46-45a4-a52b-2649bb9167de",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.59 EventNotifierType"
    },
    {
      "Id": "a09ae770-e4a2-4086-9743-9abc4702bc5f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.59 EventNotifierType\n---\n",
      "Content": "This is a subtype of the Byte DataType with the OptionSetValues Property defined. It is used to indicate if a Node can be used to subscribe to Events or read / write historic Events.\nThe EventNotifierType is formally defined in[Table 43](/\u00A7_Ref494188527).\nTable 43 - EventNotifierType Definition"
    },
    {
      "Id": "33d6e6ae-1cf8-4638-a3d2-b080a02c81c4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.59 EventNotifierType\nCaption: Table 43 - EventNotifierType Definition\n---\n",
      "Content": "Name\nBit\nDescription\nSubscribeToEvents\n0\nIndicates if it can be used to subscribe to Events\n(0 means cannot be used to subscribe to Events, 1 means can be used to subscribe to Events).\nReserved\n1\nReserved for future use. Shall always be zero.\nHistoryRead\n2\nIndicates if the history of the Events is readable\n(0 means not readable, 1 means readable).\nHistoryWrite\n3\nIndicates if the history of the Events is writeable\n(0 means not writeable, 1 means writeable).\nReserved\n4:7\nReserved for future use. Shall always be zero."
    },
    {
      "Id": "c1b5ec1e-e187-4c8e-ad39-0d3396cf041e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.59 EventNotifierType\n---\n",
      "Content": ""
    },
    {
      "Id": "a8cf50f1-647c-4d2f-b69e-8d7caf84d836",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.60 AttributeWriteMask"
    },
    {
      "Id": "786d5e04-89e4-4909-b83b-be542515d56d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.60 AttributeWriteMask\n---\n",
      "Content": "This is a subtype of the UInt32 DataType with the OptionSetValues Property defined. It is used to define the Attribute access restrictions of a Node. The AttributeWriteMask is formally defined in[Table 44](/\u00A7_Ref494187189).\nIf a bit is set to 0, it means the Attribute is not writeable. If a bit is set to 1, it means it is writeable. If a Node does not support a specific Attribute, the corresponding bit has to be set to 0.\nTable 44 - Bit mask for WriteMask and UserWriteMask"
    },
    {
      "Id": "3c411db8-d306-476f-b5ad-67394512470b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.60 AttributeWriteMask\nCaption: Table 44 - Bit mask for WriteMask and UserWriteMask\n---\n",
      "Content": "Field\nBit\nDescription\nAccessLevel\n0\nIndicates if the AccessLevel Attribute is writeable.\nArrayDimensions\n1\nIndicates if the ArrayDimensions Attribute is writeable.\nBrowseName\n2\nIndicates if the BrowseName Attribute is writeable.\nContainsNoLoops\n3\nIndicates if the ContainsNoLoops Attribute is writeable.\nDataType\n4\nIndicates if the DataType Attribute is writeable.\nDescription\n5\nIndicates if the Description Attribute is writeable.\nDisplayName\n6\nIndicates if the DisplayName Attribute is writeable.\nEventNotifier\n7\nIndicates if the EventNotifier Attribute is writeable.\nExecutable\n8\nIndicates if the Executable Attribute is writeable.\nHistorizing\n9\nIndicates if the Historizing Attribute is writeable.\nInverseName\n10\nIndicates if the InverseName Attribute is writeable.\nIsAbstract\n11\nIndicates if the IsAbstract Attribute is writeable.\nMinimumSamplingInterval\n12\nIndicates if the MinimumSamplingInterval Attribute is writeable.\nNodeClass\n13\nIndicates if the NodeClass Attribute is writeable.\nNodeId\n14\nIndicates if the NodeId Attribute is writeable.\nSymmetric\n15\nIndicates if the Symmetric Attribute is writeable.\nUserAccessLevel\n16\nIndicates if the UserAccessLevel Attribute is writeable.\nUserExecutable\n17\nIndicates if the UserExecutable Attribute is writeable.\nUserWriteMask\n18\nIndicates if the UserWriteMask Attribute is writeable.\nValueRank\n19\nIndicates if the ValueRank Attribute is writeable.\nWriteMask\n20"
    },
    {
      "Id": "b8329457-7e93-49cf-9c9f-194e0eeeeb93",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.60 AttributeWriteMask\nCaption: Table 44 - Bit mask for WriteMask and UserWriteMask\n---\n",
      "Content": "WriteMask\n20\nIndicates if the WriteMask Attribute is writeable.\nValueForVariableType\n21\nIndicates if the Value Attribute is writeable for a VariableType. It does not apply for Variables since this is handled by the AccessLevel and UserAccessLevel Attributes for the Variable. For Variables this bit shall be set to 0.\nDataTypeDefinition\n22\nIndicates if the DataTypeDefinition Attribute is writeable.\nRolePermissions\n23\nIndicates if the RolePermissions Attribute is writeable.\nAccessRestrictions\n24\nIndicates if the AccessRestrictions Attribute is writeable.\nAccessLevelEx\n25\nIndicates if the AccessLevelEx Attribute is writeable.\nReserved\n26:31\nReserved for future use. Shall always be zero."
    },
    {
      "Id": "c2d2b684-afcf-46e0-afe1-aa9c8b85066a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8 Standard DataTypes\n---\n",
      "Content": "8.61 CurrencyUnitType"
    },
    {
      "Id": "8036450f-9501-4f3f-81fb-7cee5a4fcf11",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.61 CurrencyUnitType\n---\n",
      "Content": "This structured DataType is used to represent the currency of a Variable Value based on ISO 4217. Its elements are described in[Table 45](/\u00A7_Ref35427987).\nTable 45 - CurrencyUnitType Definition"
    },
    {
      "Id": "3f326a55-5316-4f63-9a4d-aabacb682683",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.61 CurrencyUnitType\nCaption: Table 45 - CurrencyUnitType Definition\n---\n",
      "Content": "Name\nType\nDescription\nCurrencyUnitType\nstructure\n\nNumericCode\nInt16\nThree-digit code numeric code assigned to each currency in ISO 4217.\nIf unknown or not available this shall be -1.\n\nConverting the number to a string shall always produce a 3 character string with leading zeros when necessary (e.g. the number 36 shall be presented as 036). Non-decimal currencies shall not be supported.\nExponent\nSByte\nNumber of digits after the decimal separator.\nIf unknown or not available this shall be -1.\nexponent expresses the relationship between the major currency unit and its corresponding minor currency unit.\nFor example, USD ([United States dollar](https://en.wikipedia.org/wiki/United_States_dollar)) is equal to 100 of its minor currency unit the \u0022[cent](https://en.wikipedia.org/wiki/Cent_(currency))\u0022. So the exponent is 2 (10 to the power 2 is 100).\nAlphabeticCode\nString\nThree-letter alphabetic code as defined by ISO 4217.\nCurrency\nLocalizedText\nFull name of currency as defined by ISO 4217."
    },
    {
      "Id": "17edf354-d884-4912-b981-bfc3c4bf02b6",
      "Header": "Document: Part 3 - Address Space Model\nSection: 8.61 CurrencyUnitType\n---\n",
      "Content": "Examples:\nnumericCode\nexponent\nalphabeticCode\ncurrency\n036\n2\nAUD\nAustralian Dollar\n978\n2\nEUR\nEuro\n356\n2\nINR\nIndian Rupee\n840\n2\nUSD\nUS Dollar\n826\n2\nGBP\nPound Sterling\n392\n0\nJPY\nYen"
    },
    {
      "Id": "eb6fb320-5707-400f-a724-dd70234a76c8",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "9 Standard EventTypes"
    },
    {
      "Id": "5f1b92af-bfd6-44a0-8df6-414a27119ff1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.1 General"
    },
    {
      "Id": "fad40729-6240-4f49-a11f-48a8e13e5989",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.1 General\n---\n",
      "Content": "The remainder of[8.61](/\u00A7_Ref128437157) defines EventTypes. Their representation in the AddressSpace is specified in[OPC 10000-5](/\u00A7UAPart5). Other parts of this series of standards may specify additional EventTypes.[Figure 43](/\u00A7_Ref128453413) informally describes the hierarchy of these EventTypes."
    },
    {
      "Id": "8f1f1efa-a29c-4ba3-86c4-c4809a958424",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.1 General\nCaption: Figure 43 - Standard EventType Hierarchy\n---\n",
      "Content": "[image046.png](images/image046.png)"
    },
    {
      "Id": "e568b4e7-b9e2-485d-8fe2-e6b757ee9cfe",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.1 General\n---\n",
      "Content": "Figure 43 - Standard EventType Hierarchy"
    },
    {
      "Id": "8eafb180-2b06-4350-99e8-5df9bbffd020",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.2 BaseEventType"
    },
    {
      "Id": "3de16f1c-1fe2-42b8-933f-cf3410e2516c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.2 BaseEventType\n---\n",
      "Content": "The BaseEventType defines all general characteristics of an Event. All other EventTypes derive from it. There is no other semantic associated with this type."
    },
    {
      "Id": "b44947dd-0090-4a38-afce-969477fed833",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.3 SystemEventType"
    },
    {
      "Id": "99aff633-c361-4e08-a2aa-39f43b1e6311",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.3 SystemEventType\n---\n",
      "Content": "SystemEvents are Events of SystemEventType that are generated as a result of some Event that occurs within the Server or by a system that the Server is representing."
    },
    {
      "Id": "76a3a81c-3165-48c7-a832-e120e17e7d7a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.4 ProgressEventType"
    },
    {
      "Id": "6ba883eb-9706-442a-9930-0728397eb4d1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.4 ProgressEventType\n---\n",
      "Content": "ProgressEvents are Events of ProgressEventType that are generated to identify the progress of an operation. An operation can be a service call or something application specific like a program execution."
    },
    {
      "Id": "80310bac-1178-432a-9786-52bb91a5ac6c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.5 AuditEventType"
    },
    {
      "Id": "2a48b9ea-da16-492d-8416-8cdcf48cad79",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.5 AuditEventType\n---\n",
      "Content": "AuditEvents are Events of AuditEventType that are generated as a result of an action taken on the Server by a Client of the Server or as a result of some vendor specific action. For example, in response to a Client issuing a write to a Variable, the Server would generate an AuditEvent describing the Variable as the source and the user and Client session as the initiators of the Event.\n[Figure 44](/\u00A7_Ref128379440) illustrates the defined behaviour of an OPC UA Server in response to an auditable action request. If the action is accepted, then an action AuditEvent is generated and processed by the Server. If the action is not accepted due to security reasons, a security AuditEvent is generated and processed by the Server. The Server may involve the underlying device or system in the process but it is the Server\u0027s responsibility to provide the Event to any interested Clients. Clients are free to subscribe to Events from the Server and will receive the AuditEvents in response to normal Publish requests.\nAll action requests include a human readable AuditEntryId. The AuditEntryId is included in the AuditEvent to allow human readers to correlate an Event with the initiating action. The AuditEntryId typically contains who initiated the action and from where it was initiated.\nThe Server may elect to optionally persist the AuditEvents in addition to the mandatory Event Subscription delivery to Clients."
    },
    {
      "Id": "160e81a9-9c3c-4c08-9b8e-a92bf8d5a93a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.5 AuditEventType\nCaption: Figure 44 - Audit Behaviour of a Server\n---\n",
      "Content": "[image047.png](images/image047.png)"
    },
    {
      "Id": "fc0f7e90-4f8a-4035-a425-4d1efd935a49",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.5 AuditEventType\n---\n",
      "Content": "Figure 44 - Audit Behaviour of a Server\n[Figure 45](/\u00A7_Ref128379508) illustrates the expected behaviour of an aggregating Server in response to an auditable action request. This use case involves the aggregating Server passing on the action to one of its aggregated Servers. The general behaviour described above is extended by this behaviour and not replaced. That is, the request could fail and generate a security AuditEvent within the aggregating Server. The normal process is to pass the action down to an aggregated Server for processing. The aggregated Server will, in turn, follow this behaviour or the general behaviour and generate the appropriate AuditEvents. The aggregating Server periodically issues publish requests to the aggregated Servers. These collected Events are merged with self-generated Events and made available to subscribing Clients. If the aggregating Server supports the optional persisting of AuditEvent, then the collected Events are persisted along with locally-generated Events.\nThe aggregating Server may map the authenticated user account making the request to one of its own accounts when passing on the request to an aggregated Server. It shall, however, preserve the AuditEntryId by passing it on as received. The aggregating Server may also generate its own AuditEvent for the request prior to passing it on to the aggregated Server, in particular, if the aggregating Server needs to break a request into multiple requests that are each directed to separate aggregated Servers or if part of a request is denied due to security on the aggregating Server."
    },
    {
      "Id": "c6047173-256e-469c-befb-75649c590652",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.5 AuditEventType\nCaption: Figure 45 - Audit Behaviour of an Aggregating Server\n---\n",
      "Content": "[image048.png](images/image048.png)"
    },
    {
      "Id": "95b65966-4fdc-43e0-9f50-93b947ed4f45",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.5 AuditEventType\n---\n",
      "Content": "Figure 45 - Audit Behaviour of an Aggregating Server"
    },
    {
      "Id": "55e82341-d25c-4a5d-929f-ca986950edb1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.6 AuditSecurityEventType"
    },
    {
      "Id": "a5bff27a-eae3-43a9-a206-8519e62c481b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.6 AuditSecurityEventType\n---\n",
      "Content": "This is a subtype of AuditEventType and is used only for categorization of security-related Events. This type follows all behaviour of its parent type."
    },
    {
      "Id": "575c2c90-4d70-447b-992d-f9df280f8fcc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.7 AuditChannelEventType"
    },
    {
      "Id": "680c902c-f53b-4c9c-b93b-644c70fe7363",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.7 AuditChannelEventType\n---\n",
      "Content": "This is a subtype of AuditSecurityEventType and is used for categorization of security-related Events from the SecureChannel Service Set defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "0c79eb22-486a-4363-8ee3-e29c99924be8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.8 AuditOpenSecureChannelEventType"
    },
    {
      "Id": "b693b79e-c8ef-4e1d-8e8a-d0f19c813995",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.8 AuditOpenSecureChannelEventType\n---\n",
      "Content": "This is a subtype of AuditChannelEventType and is used for Events generated from calling the OpenSecureChannel Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "f877fa9a-70fa-479c-985a-42730eb8acf0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.9 AuditSessionEventType"
    },
    {
      "Id": "f19013db-8b55-44d6-baaa-19386c5c28c0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.9 AuditSessionEventType\n---\n",
      "Content": "This is a subtype of AuditSecurityEventType and is used for categorization of security-related Events from the Session Service Set defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "e29c6acc-4df0-47cd-8b35-3cd9412cfba3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.10 AuditCreateSessionEventType"
    },
    {
      "Id": "029b1115-611d-435e-8eeb-68db5d3ce786",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.10 AuditCreateSessionEventType\n---\n",
      "Content": "This is a subtype of AuditSessionEventType and is used for Events generated from calling the CreateSession Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "5835cb97-b986-4712-b796-2c7c9f05a046",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.11 AuditUrlMismatchEventType"
    },
    {
      "Id": "86cadc94-7fd3-450c-a3bb-568538a82a7a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.11 AuditUrlMismatchEventType\n---\n",
      "Content": "This is a subtype of AuditCreateSessionEventType and is used for Events generated from calling the CreateSession Service defined in[OPC 10000-4](/\u00A7UAPart4) if the EndpointUrl used in the service call does not match the Server\u0027s HostNames(see[OPC 10000-4](/\u00A7UAPart4) for details). This Type has been deprecated and will be removed in a future version."
    },
    {
      "Id": "3e4cdeed-1479-4c65-ab2f-2ddbd255fd55",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.12 AuditActivateSessionEventType"
    },
    {
      "Id": "a5e51254-557d-4260-a360-8c94a451458b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.12 AuditActivateSessionEventType\n---\n",
      "Content": "This is a subtype of AuditSessionEventType and is used for Events generated from calling the ActivateSession Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "0dccb723-1d2f-44ed-938f-0cd40a45b0f3",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.13 AuditCancelEventType"
    },
    {
      "Id": "08a14c4c-3ad0-4ae3-866d-a346653e88b0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.13 AuditCancelEventType\n---\n",
      "Content": "This is a subtype of AuditSessionEventType and is used for Events generated from calling the Cancel Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "3691e5ff-7ac2-4003-95e1-fbeb5a4b379f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.14 AuditCertificateEventType"
    },
    {
      "Id": "acda7aa1-dd64-4373-99c0-7a663d99a0d7",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.14 AuditCertificateEventType\n---\n",
      "Content": "This is a subtype of AuditSecurityEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. These AuditEvents will be generated for Certificate errors in addition to other AuditEvents related to service calls."
    },
    {
      "Id": "e5b6e79a-e409-4333-923d-1b97549c6a26",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.15 AuditCertificateDataMismatchEventType"
    },
    {
      "Id": "3a1e9b87-b3a9-4639-9515-89e4c899afef",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.15 AuditCertificateDataMismatchEventType\n---\n",
      "Content": "This is a subtype of AuditCertificateEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. This AuditEvent is generated if the HostName in the URL used to connect to the Server is not the same as one of the HostNames specified in the Certificate or if the Application and Software Certificates contain an application or product URI that does not match the URI specified in the ApplicationDescription provided with the Certificate. For more details on Certificates see[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "1013496b-abb2-4cf1-9ba1-bdddd52e160b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.16 AuditCertificateExpiredEventType"
    },
    {
      "Id": "0d7b30de-82e2-409c-9e5b-9660605ce48a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.16 AuditCertificateExpiredEventType\n---\n",
      "Content": "This is a subtype of AuditCertificateEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. This AuditEvent is generated if the current time is outside the validity period\u0027s start date and end date."
    },
    {
      "Id": "539ba414-6745-41fb-b98b-529544c3624e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.17 AuditCertificateInvalidEventType"
    },
    {
      "Id": "1ea362bc-59fe-4452-a9f9-38e553bb6762",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.17 AuditCertificateInvalidEventType\n---\n",
      "Content": "This is a subtype of AuditCertificateEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. This AuditEvent is generated if the certificate structure is invalid or if the Certificate has an invalid signature."
    },
    {
      "Id": "30dbc79c-e1e8-4a19-8915-62afbca1bc83",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.18 AuditCertificateUntrustedEventType"
    },
    {
      "Id": "068bde04-a9f0-4e55-8e8c-d99abc86582a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.18 AuditCertificateUntrustedEventType\n---\n",
      "Content": "This is a subtype of AuditCertificateEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. This AuditEvent is generated if the Certificate is not trusted, that is, if the Issuer Certificate is unknown."
    },
    {
      "Id": "0a18d941-6d49-4f2e-b720-1fc0f9929c9f",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.19 AuditCertificateRevokedEventType"
    },
    {
      "Id": "7e2bf20c-3a91-4698-ae63-a17549aee4fb",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.19 AuditCertificateRevokedEventType\n---\n",
      "Content": "This is a subtype of AuditCertificateEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. This AuditEvent is generated if a Certificate has been revoked or if the revocation list is not available (i.e. a network interruption prevents the Application from accessing the list)."
    },
    {
      "Id": "a9ef66eb-7eb1-4e2c-b37f-5d1fee1dcc09",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.20 AuditCertificateMismatchEventType"
    },
    {
      "Id": "46d65a15-9432-48e1-9142-059ef17d01c8",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.20 AuditCertificateMismatchEventType\n---\n",
      "Content": "This is a subtype of AuditCertificateEventType and is used only for categorization of Certificate related Events. This type follows all behaviours of its parent type. This AuditEvent is generated if a Certificate set of uses does not match the requested use for the Certificate (i.e. Application, Software or Certificate Authority)."
    },
    {
      "Id": "6ff6bf15-5da7-4bc1-8ecf-ef87d2092825",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.21 AuditNodeManagementEventType"
    },
    {
      "Id": "df0fb422-4635-413f-91cb-65b876eebf12",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.21 AuditNodeManagementEventType\n---\n",
      "Content": "This is a subtype of AuditEventType and is used for categorization of node management related Events. This type follows all behaviours of its parent type."
    },
    {
      "Id": "a849fe77-87ad-40ff-ae2a-eb097641edbc",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.22 AuditAddNodesEventType"
    },
    {
      "Id": "4633bb50-3c63-43d2-addf-fe886aad5f12",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.22 AuditAddNodesEventType\n---\n",
      "Content": "This is a subtype of AuditNodeManagementEventType and is used for Events generated from calling the AddNodes Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "623af6c7-0625-41ff-8fb1-9fe83ccacd09",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.23 AuditDeleteNodesEventType"
    },
    {
      "Id": "34c66a86-e7ac-4d36-8e06-da0d42ba8ad5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.23 AuditDeleteNodesEventType\n---\n",
      "Content": "This is a subtype of AuditNodeManagementEventType and is used for Events generated from calling the DeleteNodes Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "17c9aa65-d9d6-4a9b-b560-a0af1f2ade0a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.24 AuditAddReferencesEventType"
    },
    {
      "Id": "da843304-af07-42e5-8f5d-6397827f24f2",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.24 AuditAddReferencesEventType\n---\n",
      "Content": "This is a subtype of AuditNodeManagementEventType and is used for Events generated from calling the AddReferences Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "b5d2a25d-6a48-474e-87f3-fa6f51c358b9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.25 AuditDeleteReferencesEventType"
    },
    {
      "Id": "8f8ec69e-51fc-47d3-935a-20b65829a05c",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.25 AuditDeleteReferencesEventType\n---\n",
      "Content": "This is a subtype of AuditNodeManagementEventType and is used for Events generated from calling the DeleteReferences Service defined in[OPC 10000-4](/\u00A7UAPart4)."
    },
    {
      "Id": "7e0bafcd-c0d8-4a11-b5f5-32cb9de219c1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.26 AuditUpdateEventType"
    },
    {
      "Id": "eccd1bc7-754a-401b-ae28-385fa29d7bc5",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.26 AuditUpdateEventType\n---\n",
      "Content": "This is a subtype of AuditEventType and is used for categorization of update related Events. This type follows all behaviours of its parent type."
    },
    {
      "Id": "30634115-8ce4-44c8-964d-6924b7047bef",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.27 AuditWriteUpdateEventType"
    },
    {
      "Id": "de31b527-c90e-4c1e-a590-ca667f9fd5fd",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.27 AuditWriteUpdateEventType\n---\n",
      "Content": "This is a subtype of AuditUpdateEventType and is used for categorization of write update related Events. This type follows all behaviours of its parent type."
    },
    {
      "Id": "7e88c502-c6e8-4584-869e-cb535165fafe",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.28 AuditHistoryUpdateEventType"
    },
    {
      "Id": "d9bd2416-5aeb-4ce3-8ac0-044651f3896d",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.28 AuditHistoryUpdateEventType\n---\n",
      "Content": "This is a subtype of AuditUpdateEventType and is used for categorization of history update related Events. This type follows all behaviours of its parent type."
    },
    {
      "Id": "8b21caaa-a9d4-4274-bf66-c9d3912f5143",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.29 AuditUpdateMethodEventType"
    },
    {
      "Id": "88006482-0ae2-4cb9-bcbd-7fd5be0605e1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.29 AuditUpdateMethodEventType\n---\n",
      "Content": "This is a subtype of AuditEventType and is used for categorization of Method related Events. This type follows all behaviours of its parent type."
    },
    {
      "Id": "008dea8d-ac5f-429d-a683-e9844f0bad00",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.30 DeviceFailureEventType"
    },
    {
      "Id": "4d7eaa9e-73c2-4c14-adb8-cc87bcd5b1e0",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.30 DeviceFailureEventType\n---\n",
      "Content": "A DeviceFailureEvent is an Event of DeviceFailureEventType that indicates a failure in a device of the underlying system."
    },
    {
      "Id": "73d08b25-adc2-4ae1-b6d1-5d3ab8b62821",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.31 SystemStatusChangeEventType"
    },
    {
      "Id": "7e4a095f-fd05-4607-b24c-f858abe85b38",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.31 SystemStatusChangeEventType\n---\n",
      "Content": "A SystemStatusChangeEvent is an Event of SystemStatusChangeEventType that indicates a status change in a system. For example, if the status indicates an underlying system is not running, then a Client cannot expect any Events from the underlying system. A Server can identify its own status changes using this EventType."
    },
    {
      "Id": "7fdda853-791e-4d7c-8f1a-d5e7ca64b8b4",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.32 ModelChangeEvents"
    },
    {
      "Id": "4edd70a5-563e-4d24-8968-0d0e3f497dd9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.1 General"
    },
    {
      "Id": "14bc3a67-e10c-447a-b964-e88cabcd64be",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.1 General\n---\n",
      "Content": "ModelChangeEvents are generated to indicate a change of the AddressSpace structure. The change may consist of adding or deleting a Node or Reference. Although the relationship of a Variable or VariableType to its DataType is not modelled using References, changes to the DataType Attribute of a Variable or VariableType are also considered as model changes and therefore a ModelChangeEvent is generated if the DataType Attribute changes."
    },
    {
      "Id": "ffe11c7a-2d8d-419d-a56f-bc6ff9dc3675",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.2 NodeVersion Property"
    },
    {
      "Id": "fa944f3f-77c9-4a12-8c7c-1bbf1f0ddc43",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.2 NodeVersion Property\n---\n",
      "Content": "There is a correlation between ModelChangeEvents and the NodeVersion Property of Nodes. Every time a ModelChangeEvent is issued for a Node, its NodeVersion shall be changed, and every time the NodeVersion is changed, a ModelChangeEvent shall be generated. A Server shall support both the ModelChangeEvent and the NodeVersion Property or neither, but never only one of the two mechanisms.\nThis relation also implies that only those Nodes of the AddressSpace having a NodeVersion shall trigger a ModelChangeEvent. Other Nodes shall not trigger a ModelChangeEvent."
    },
    {
      "Id": "768c7342-cc53-4d3f-aa67-1c64b7ed3e49",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.3 Views"
    },
    {
      "Id": "683d05dc-f387-415d-9518-2260e94ee706",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.3 Views\n---\n",
      "Content": "A ModelChangeEvent is always generated in the context of a View, including the default View where the whole AddressSpace is considered. Therefore the only Notifiers which report the ModelChangeEvents are View Nodes and the Server Object representing the default View. Each action generating a ModelChangeEvent may lead to several Events since it may affect different Views. If, for example, a Node was deleted from the AddressSpace, and this Node was also contained in a View \u0022A\u0022, there would be one Event having the AddressSpace as context and another having the View \u0022A\u0022 as context. If a Node would only be removed from View\u0022A\u0022, but still exists in the AddressSpace, it would generate only a ModelChangeEvent for View\u0022A\u0022.\nIf a Client does not want to receive duplicates of changes then it shall use the filter mechanisms of the Event Subscription to filter only for the default View and suppress the ModelChangeEvents having other Views as the context.\nWhen a ModelChangeEvent is issued on a View and the View supports the ViewVersion Property, then the ViewVersion shall be updated."
    },
    {
      "Id": "d250829f-0edc-451f-8b02-8230f8e9e91e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.4 Event compression"
    },
    {
      "Id": "bfcba51d-8eac-4371-9c9b-78287a8d4f05",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.4 Event compression\n---\n",
      "Content": "An implementation is not required to issue an Event for every update as it occurs. An OPC UA Server may be capable of grouping a series of transactions or simple updates into a larger unit. This series may constitute a logical grouping or a temporal grouping of changes. A single ModelChangeEvent may be issued after the last change of the series, to cover all of the changes. This is referred to as Event compression. A change in the NodeVersion and the ViewVersion may thus reflect a group of changes and not a single change."
    },
    {
      "Id": "602cdbd6-01af-47e8-a0ce-b36db834e926",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.5 BaseModelChangeEventType"
    },
    {
      "Id": "5d2c6896-91d0-448b-832a-4032bd956561",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.5 BaseModelChangeEventType\n---\n",
      "Content": "BaseModelChangeEvents are Events of the BaseModelChangeEventType. The BaseModelChangeEventType is the base type for ModelChangeEvents and does not contain information about the changes but only indicates that changes occurred. Therefore the Client shall assume that any or all of the Nodes may have changed."
    },
    {
      "Id": "cabc11fd-416a-4e76-9978-c4718673ec7e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.6 GeneralModelChangeEventType"
    },
    {
      "Id": "b06ae6d7-cab4-4880-8840-18a51beb4cb1",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.6 GeneralModelChangeEventType\n---\n",
      "Content": "GeneralModelChangeEvents are Events of the GeneralModelChangeEventType. The GeneralModelChangeEventType is a subtype of the BaseModelChangeEventType. It contains information about the Node that was changed and the action that occurred to cause the ModelChangeEvent(e.g. add a Node, delete a Node, etc.). If the affected Node is a Variable or Object, then the TypeDefinitionNode is also present.\nTo allow Event compression, a GeneralModelChangeEvent contains an array of changes."
    },
    {
      "Id": "82c73bbe-84d3-4be8-a21b-0f42e2f316e9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32 ModelChangeEvents\n---\n",
      "Content": "9.32.7 Guidelines for ModelChangeEvents"
    },
    {
      "Id": "1fa817d6-e842-4b87-8759-380fda029b8e",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.32.7 Guidelines for ModelChangeEvents\n---\n",
      "Content": "Two types of ModelChangeEvents are defined: the BaseModelChangeEvent that does not contain any information about the changes and the GeneralModelChangeEvent that identifies the changed Nodes via an array. The precision used depends on both the capability of the OPC UA Server and the nature of the update. An OPC UA Server may use either ModelChangeEvent type depending on circumstances. It may also define subtypes of these EventTypes adding additional information.\nTo ensure interoperability, the following guidelines for Events should be observed.\nIf the array of the GeneralModelChangeEvent is present, then it should identify every Node that has changed since the preceding ModelChangeEvent.\nThe OPC UA Server should emit exactly one ModelChangeEvent for an update or series of updates. It should not issue multiple types of ModelChangeEvent for the same update.\nAny Client that responds to ModelChangeEvents should respond to any Event of the BaseModelChangeEventType including its subtypes like the GeneralModelChangeEventType.\nIf a Client is not capable of interpreting additional information of the subtypes of the BaseModelChangeEventType, it should treat Events of these types the same way as Events of the BaseModelChangeEventType."
    },
    {
      "Id": "7cc27401-dd39-4a21-a269-cb771461c41b",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9 Standard EventTypes\n---\n",
      "Content": "9.33 SemanticChangeEventType"
    },
    {
      "Id": "09aa2003-a0f2-4164-be8f-72fdd4cbb58a",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33 SemanticChangeEventType\n---\n",
      "Content": "9.33.1 General"
    },
    {
      "Id": "c4d2c0cc-92d5-4cf5-bf49-8d7bbfef8546",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33.1 General\n---\n",
      "Content": "SemanticChangeEvents are Events of SemanticChangeEventType that are generated to indicate a change of the AddressSpace semantics. The change consists of a change to the Value Attribute of a Property.\nThe SemanticChangeEvent contains information about the Node owning the Property that was changed. If this is a Variable or Object, the TypeDefinitionNode is also present.\nThe SemanticChange bit of the AccessLevel Attribute of a Property indicates whether changes of the Property value are considered for SemanticChangeEvents(see[5.6.2](/\u00A7_Ref127693446))."
    },
    {
      "Id": "1c21aec6-c9f6-46f2-9210-943b1be64cf9",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33 SemanticChangeEventType\n---\n",
      "Content": "9.33.2 ViewVersion and NodeVersion Properties"
    },
    {
      "Id": "0574565a-e5f0-41d4-bba4-ede9f9293606",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33.2 ViewVersion and NodeVersion Properties\n---\n",
      "Content": "The ViewVersion and NodeVersion Properties do not change due to the publication of a SemanticChangeEvent."
    },
    {
      "Id": "047fbf1a-4087-440e-a108-666592e83e29",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33 SemanticChangeEventType\n---\n",
      "Content": "9.33.3 Views"
    },
    {
      "Id": "7e0038f8-783d-40c1-9ec0-562703bf1d98",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33.3 Views\n---\n",
      "Content": "SemanticChangeEvents are handled in the context of a View the same way as ModelChangeEvents. This is defined in[9.32.3](/\u00A7_Ref139956333)."
    },
    {
      "Id": "a047e4d9-e09c-4bb7-b733-709e5105c899",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33 SemanticChangeEventType\n---\n",
      "Content": "9.33.4 Event compression"
    },
    {
      "Id": "b4ab072e-4d89-4fdb-838b-67f39ba4e388",
      "Header": "Document: Part 3 - Address Space Model\nSection: 9.33.4 Event compression\n---\n",
      "Content": "SemanticChangeEvents can be compressed the same way as ModelChangeEvents. This is defined in[9.32.4](/\u00A7_Ref139956352)."
    },
    {
      "Id": "539e7b92-7cd8-4ef0-82ab-982e42f74104",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "Annex\u00A0A(informative)How to use the Address Space Model\nA.1 Overview"
    },
    {
      "Id": "745ede26-c76d-4c9b-a241-260143fe0472",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.1 Overview\n---\n",
      "Content": "Annex A points out some general considerations on how the Address Space Model can be used. Annex A is for information only, that is, each Server vendor can model its data in the appropriate way that fits its needs. However, it gives some hints the Server vendor may consider.\nTypically OPC UA Servers will offer data provided by an underlying system like a device, a configuration database, an OPC COM Server, etc. Therefore the modelling of the data depends on the model of the underlying system as well as the requirements of the Clients accessing the OPC UA Server. It is also expected that companion specifications will be developed on top of OPC UA with additional rules on how to model the data. However, the remainder of Annex A will give some general considerations about the different concepts of OPC UA to model data and when they should be used, and when not.\n[OPC 10000-5](/\u00A7UAPart5): Annex A, provides an overview of the design decisions made when modelling the information about the Server defined in[OPC 10000-5](/\u00A7UAPart5)."
    },
    {
      "Id": "2bc3fa8a-a999-4e8f-b11f-3e1460fae7aa",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.2 Type definitions"
    },
    {
      "Id": "41478f97-0673-4d08-bc95-a4a1410e06f8",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.2 Type definitions\n---\n",
      "Content": "Type definitions should be used whenever it is expected that the type information may be used more than once in the same system or for interoperability between different systems supporting the same type definitions."
    },
    {
      "Id": "a88dc5e8-75ea-4adb-9c37-e63a52de0569",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.3 ObjectTypes"
    },
    {
      "Id": "14575811-50b4-4399-bc6c-f35a16f7c976",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.3 ObjectTypes\n---\n",
      "Content": "Subclause[5.5.1](/\u00A7_Ref138653753) states: \u0022 Objects are used to represent systems, system components, real-world objects, and software objects.\u0022 Therefore ObjectTypes should be used if a type definition of those ObjectTypes is useful (see[A.2](/\u00A7_Ref137887688)).\nFrom a more abstract point of view Objects are used to group Variables and other Objects in the AddressSpace. Therefore ObjectTypes should be used when some common structures/groups of Objects and/or Variables should be described. Clients can use this knowledge to program against the ObjectType structure and use the TranslateBrowsePathsToNodeIds Service defined in[OPC 10000-4](/\u00A7UAPart4) on the instances.\nSimple objects only having one value (e.g. a simple heat sensor) can also be modelled as VariableTypes. However, extensibility mechanisms should be considered (e.g. a complex heat sensor subtype could have several values) and whether that object should be exposed as an object in the Client\u0027s GUI or just as a value. Whenever a modeller is in doubt as to which solution to use the ObjectType having one Variable should be preferred."
    },
    {
      "Id": "67cea96f-bcbd-4c5a-8bda-9cc853b3c8f1",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.4 VariableTypes"
    },
    {
      "Id": "a4db050c-5a03-4302-ac26-de41d9f703b1",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4 VariableTypes\n---\n",
      "Content": "A.4.1 General"
    },
    {
      "Id": "2187d9af-2894-4766-9729-8344c161e24e",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4.1 General\n---\n",
      "Content": "VariableTypes are only used for DataVariables and should be used when there are several Variables having the same semantic (e.g. set point). It is not necessary to define a VariableType that only reflects the DataType of a Variable, e.g. an \u0022Int32VariableType\u0022."
    },
    {
      "Id": "65e69e06-7d16-4cf3-b9bf-b83051c54595",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4 VariableTypes\n---\n",
      "Content": "A.4.2 Properties or DataVariables"
    },
    {
      "Id": "dae65738-bdc1-4ab2-8ecf-2a5ae6315c17",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4.2 Properties or DataVariables\n---\n",
      "Content": "Besides the semantic differences of Properties and DataVariables described in Clause[4](/\u00A7_Ref138653937) there are also syntactical differences. A Property is identified by its BrowseName, that is, if Properties having the same semantic are used several times, they should always have the same BrowseName. The same semantic of DataVariables is captured in the VariableType.\nIf it is not clear which concept to use based on the semantic described in Clause[4](/\u00A7_Ref138653937), then the different syntax can help. The following points identify when it shall be a DataVariable.\nIf it is a complex Variable or it should contain additional information in the form of Properties.\nIf the type definition may be refined (subtyping).\nIf the type definition should be made available so the Client can use the AddNodes Service defined in[OPC 10000-4](/\u00A7UAPart4) to create new instances of the type definition.\nIf it is a component of a complex Variable exposing a part of the value of the complex Variable."
    },
    {
      "Id": "da54d8f6-114b-4527-a030-74320f33f82e",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4 VariableTypes\n---\n",
      "Content": "A.4.3 Many Variables and / or Structured DataTypes"
    },
    {
      "Id": "8f3b8a12-dac6-463b-b30d-1ec4fe4b8504",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4.3 Many Variables and / or Structured DataTypes\n---\n",
      "Content": "When structured data structures should be made available to the Client there are basically three different approaches:\nCreate several simple Variables using simple DataTypes always reflecting parts of the simple structure. Objects are used to group the Variables according to the structure of the data.\nCreate a Structured DataType and a simple Variable using this DataType.\nCreate a Structured DataType and a complex Variable using this DataType and also exposing the structured data structure as Variables of the complex Variable using simple DataTypes.\nThe advantages of the first approach are that the complex structure of the data is visible in the AddressSpace. A generic Client can easily access the data without knowledge of user-defined DataTypes and the Client can access individual parts of the structured data. The disadvantages of the first approach are that accessing the individual data does not provide any transactional context and for a specific Client the Server first has to convert the data and the Client has to convert the data, again, to get the data structure the underlying system provides.\nThe advantages of the second approach are, that the data is accessed in a transactional context and the Structured DataType can be constructed in a way that the Server does not have to convert the data and can pass directly to the specific Client that can directly use them. The disadvantages are that the generic Client might not be able to access and interpret the data or has at least the burden to read the DataTypeDefinition to interpret the data. The structure of the data is not visible in the AddressSpace; additional Properties describing the data structure cannot be added to the adequate places since they do not exist in the AddressSpace. Individual parts of the data cannot be read without accessing the whole data structure.\nThe third approach combines the other two approaches. Therefore a specific Client can access data in its native format in a transactional context, whereas a generic Client can access simple DataTypes"
    },
    {
      "Id": "c4c5dc95-130f-47fd-b7c1-a7cbc55b6913",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.4.3 Many Variables and / or Structured DataTypes\n---\n",
      "Content": "can access simple DataTypes of the components of the complex Variable. The disadvantage is that the Server must be able to provide the native format and also interpret it to be able to provide the information in simple DataTypes.\nIt is recommended to use the first approach. When a transactional context is needed or the Client should be able to get a large amount of data instead of subscribing to several individual values, then the third approach is suitable. However, the Server might not always have the knowledge to interpret the structured data of the underlying system and therefore has to use the second approach just passing the data to the specific Client who is able to interpret the data."
    },
    {
      "Id": "d77c3563-6576-408c-9271-9106b5b9e801",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.5 Views"
    },
    {
      "Id": "d0ede500-e3e8-4b7c-a685-6bb895ecda6f",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.5 Views\n---\n",
      "Content": "Server-defined Views can be used to present an excerpt of the AddressSpace suitable for a special class of Clients, for example maintenance Clients, engineering Clients, etc. The View only provides the information needed for the purpose of the Client and hides unnecessary information."
    },
    {
      "Id": "a7a0e25d-721f-4f17-979d-728462cd784f",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.6 Methods"
    },
    {
      "Id": "c6fdd070-c613-44e5-9292-1ec6f6e7cf89",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.6 Methods\n---\n",
      "Content": "Methods should be used whenever some input is expected and the Server delivers a result. One should avoid using Variables to write the input values and other Variables to get the output results as it was necessary to do in OPC COM since there was no concept of a Method available. However, a simple OPC COM wrapper might not be able to do this.\nMethods can also be used to trigger some execution in the Server that does not require input and / or output parameters.\nGlobal Methods, that is, Methods that cannot directly be assigned to a special Object, should be assigned to the Server Object defined in[OPC 10000-5](/\u00A7UAPart5)."
    },
    {
      "Id": "b7d47683-5d5c-45a7-a82f-17055d1455c9",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.7 Defining ReferenceTypes"
    },
    {
      "Id": "6c80f860-5de5-4943-8607-8a9dcbc94c44",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.7 Defining ReferenceTypes\n---\n",
      "Content": "Defining new ReferenceTypes should only be done if the predefined ReferenceTypes are not suitable. Whenever a new ReferenceType is defined, the most appropriate ReferenceType should be used as its supertype.\nIt is expected that Servers will have new defined hierarchical ReferenceTypes to expose different hierarchies, and new Nonhierarchical ReferenceTypes to expose relationships between Nodes in the AddressSpace."
    },
    {
      "Id": "5c913add-ffa1-410a-8a77-a6bc974a4546",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "A.8 Defining ModellingRules"
    },
    {
      "Id": "a20cd657-13f7-400d-805a-e4ff97006f93",
      "Header": "Document: Part 3 - Address Space Model\nSection: A.8 Defining ModellingRules\n---\n",
      "Content": "New ModellingRules have to be defined if the predefined ModellingRules are not appropriate for the model exposed by the Server.\nDepending on the model used by the underlying system the Server may need to define new ModellingRules, since the OPC UA Server may only pass the data to the underlying system and this system may use its own internal rules for instantiation, subtyping, etc.\nBeside this, the predefined ModellingRules might not be sufficient to specify the required behaviour for instantiation and subtyping."
    },
    {
      "Id": "b72d8b12-0303-4552-806a-a03a79f31df6",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "Annex\u00A0B(informative)OPC UA Meta Model in UML\nB.1 Background"
    },
    {
      "Id": "d26525ae-6ac9-432a-a702-be4ac7d5d075",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.1 Background\n---\n",
      "Content": "The OPC UA Meta Model (the OPC UA Address Space Model) is represented by UML classes and UML objects marked with the stereotype \u003C\u003CTypeExtension\u003E\u003E. Those stereotyped UML objects represent DataTypes or ReferenceTypes. The domain model can contain user-defined ReferenceTypes and DataTypes, also marked as \u003C\u003CTypeExtension\u003E\u003E. In addition, the domain model contains ObjectTypes, VariableTypes etc. represented as UML objects (see[Figure B.1](/\u00A7_Ref103570798)).\nThe OPC Foundation specifies not only the OPC UA Meta Model, but also defines some Nodes to organise the AddressSpace and to provide information about the Server as specified in[OPC 10000-5](/\u00A7UAPart5)."
    },
    {
      "Id": "d206936b-be3c-4965-881a-49b93c92ac14",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.1 Background\nCaption: Figure B. 1 - Background of OPC UA Meta Model\n---\n",
      "Content": "[image049.png](images/image049.png)"
    },
    {
      "Id": "35ad44c1-3f80-4680-9731-e9f92441a10b",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.1 Background\n---\n",
      "Content": "Figure B. 1 - Background of OPC UA Meta Model"
    },
    {
      "Id": "2dc8e7f4-47c6-47b9-b596-76815bf10bda",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "B.2 Notation"
    },
    {
      "Id": "be43a339-d62d-486e-a34c-88b9e191cca5",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.2 Notation\n---\n",
      "Content": "An example of a UML class representing the OPC UA concept Base is given in the UML class diagram in[Figure B.2](/\u00A7_Ref205601044). OPC Attributes inherit from the abstract class Attribute and have a value identifying their data type. They are composed of a Node which is either optional (0..1) or required (1), such as BrowseName to Base in[Figure B.2](/\u00A7_Ref205601044)."
    },
    {
      "Id": "beaa7052-fa1b-433f-a401-810c6dfe4e60",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.2 Notation\nCaption: Figure B. 2 - Notation (I)\n---\n",
      "Content": "[image050.png](images/image050.png)"
    },
    {
      "Id": "824a2eba-eb7c-406f-b5d7-c8359ac0f62b",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.2 Notation\n---\n",
      "Content": "Figure B. 2 - Notation (I)\nUML object diagrams are used to display \u003C\u003CTypeExtension\u003E\u003E objects (e.g. HasComponent in[Figure B.3](/\u00A7_Ref120337857)). In object diagrams, OPC Attributes are represented as UML attributes without data types and marked with the stereotype \u003C\u003CAttribute\u003E\u003E, like InverseName in the UML object HasComponent. They have values, like InverseName =ComponentOf for HasComponent. To keep the object diagrams simple, not all Attributes are shown (e.g. the NodeId of HasComponent)."
    },
    {
      "Id": "427c0d05-128f-4ebe-a261-8cabd4c0f0e9",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.2 Notation\nCaption: Figure B. 3 - Notation (II)\n---\n",
      "Content": "[image051.png](images/image051.png)"
    },
    {
      "Id": "82f5661e-0105-47f2-b88b-2ae68b57935d",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.2 Notation\n---\n",
      "Content": "Figure B. 3 - Notation (II)\nOPC References are represented as UML associations marked with the stereotype \u003C\u003CReference\u003E\u003E. If a particular ReferenceType is used, its name is used as the role name, identifying the direction of the Reference(e.g. Aggregates has the subtype HasComponent). For simplicity, the inverse role name is not shown (in the example SubtypeOf). When no role name is provided, it means that any ReferenceType can be used (only valid for class diagrams).\nThere are some special Attributes in OPC UA containing a NodeId and thereby referencing another Node. Those Attributes are represented as associations marked with the stereotype \u003C\u003CAttribute\u003E\u003E. The name of the Attribute is displayed as the role name of the TargetNode.\nThe value of the OPC Attribute BrowseName is represented by the UML object name, for example the BrowseName of the UML object HasComponent in[Figure B.3](/\u00A7_Ref120337857) is \u0022HasComponent\u0022.\nTo highlight the classes explained in a class diagram, they are marked in grey (e.g. Base in[Figure B.2](/\u00A7_Ref205601044)). Only those classes have all of their relationships to other classes and attributes shown in the diagram. For the other classes, we provide only those attributes and relationships needed to understand the main classes of the diagram."
    },
    {
      "Id": "8ef19986-6df5-409a-ad01-66484977027e",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "B.3 Meta Model"
    },
    {
      "Id": "dd74b6d5-d5af-4477-99f4-1f964c1d3361",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "NOTE: Other parts of this series of standards can extend the OPC UA Meta Model by adding Attributes and defining new ReferenceTypes. The figures in the following clauses are not intended to be complete and therefore may not include all referenced Nodes defined in this and other parts.\nB.3.1 Base"
    },
    {
      "Id": "d4b12ea0-fbd3-411b-ba8d-4c4713b05d38",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.1 Base\n---\n",
      "Content": "Base is shown in[Figure B.4](/\u00A7_Ref389585424)."
    },
    {
      "Id": "436fe952-d99a-4e2f-b249-93a88dc2cb37",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.1 Base\nCaption: Figure B. 4 - Base\n---\n",
      "Content": "[image052.png](images/image052.png)"
    },
    {
      "Id": "5f58abf6-8f6c-412c-928d-35cb326d1c95",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.1 Base\n---\n",
      "Content": "Figure B. 4 - Base"
    },
    {
      "Id": "2ef2adb3-1cf2-4e43-93db-ff138adf0fa1",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.2 ReferenceType"
    },
    {
      "Id": "6ef3b64a-7e2c-439c-88f0-be2d8fc2eb29",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.2 ReferenceType\n---\n",
      "Content": "ReferenceType is shown in[Figure B.5](/\u00A7_Ref389585536) and predefined ReferenceTypes in[Figure B.6](/\u00A7_Ref389585583)."
    },
    {
      "Id": "be389a40-c074-4b1a-9431-11f9459aa5e9",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.2 ReferenceType\nCaption: Figure B. 5 - Reference and ReferenceType\n---\n",
      "Content": "[image053.png](images/image053.png)"
    },
    {
      "Id": "01f33d29-5f03-40e1-a9b3-bdbd0d4ff7b9",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.2 ReferenceType\n---\n",
      "Content": "Figure B. 5 - Reference and ReferenceType\nIf Symmetric is \u0022false\u0022 an InverseName shall be provided."
    },
    {
      "Id": "260fc66e-b408-4e38-85ba-73f44b668c3b",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.2 ReferenceType\nCaption: Figure B. 6 - Predefined ReferenceTypes\n---\n",
      "Content": "[image054.png](images/image054.png) Predefined ReferenceTypes[image055.png](images/image055.png)"
    },
    {
      "Id": "6bb1f524-7d52-487b-8b5d-38dd8a012274",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.2 ReferenceType\n---\n",
      "Content": "Figure B. 6 - Predefined ReferenceTypes"
    },
    {
      "Id": "41820f44-f667-4936-b21c-28b596398f1f",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.3 Attributes"
    },
    {
      "Id": "2824e825-d491-4b93-bbf4-6af9ccbcd355",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.3 Attributes\n---\n",
      "Content": "Attributes are shown in[Figure B.7](/\u00A7_Ref389585633)."
    },
    {
      "Id": "e27addf3-fe57-4625-a0a5-6e11b7a3f488",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.3 Attributes\nCaption: Figure B. 7 - Attributes\n---\n",
      "Content": "[image056.jpg](images/image056.jpg)"
    },
    {
      "Id": "f6c5f4a5-957b-431b-acfe-979258b98e66",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.3 Attributes\n---\n",
      "Content": "Figure B. 7 - Attributes\nThere may be more Attributes defined in other parts of this series of standards.\nAttributes used for references, which have a NodeId as DataType, are not shown in this diagram but are shown as stereotyped associations in the other diagrams."
    },
    {
      "Id": "a5db8866-781f-4c22-ad00-4981dfcd516c",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\nCaption: Figure B. 8 - Object and ObjectType\n---\n",
      "Content": "B.3.4 Object and ObjectType"
    },
    {
      "Id": "9cac9e7d-bd15-4a02-940b-3c209a62740e",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.4 Object and ObjectType\n---\n",
      "Content": "Objects and ObjectTypes are shown in[Figure B.8](/\u00A7_Ref389585665).\n\nFigure B. 8 - Object and ObjectType"
    },
    {
      "Id": "3a4f19c7-4bb4-4706-8c79-2ce55fd1dd95",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.5 EventNotifier"
    },
    {
      "Id": "34142859-61d7-4d07-97da-dfd7a4360f5e",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.5 EventNotifier\n---\n",
      "Content": "EventNotifier are shown in[Figure B.9](/\u00A7_Ref389585697)."
    },
    {
      "Id": "7eaff31e-c259-4373-8b4f-5b7a0b3496cc",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.5 EventNotifier\nCaption: Figure B. 9 - EventNotifier\n---\n",
      "Content": "[image057.png](images/image057.png)"
    },
    {
      "Id": "11957b8e-a1d6-4673-8817-706e96bb0aac",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.5 EventNotifier\n---\n",
      "Content": "Figure B. 9 - EventNotifier"
    },
    {
      "Id": "b925dd58-5fa4-4c8c-829c-da41699bca68",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.6 Variable and VariableType"
    },
    {
      "Id": "e79cd91c-ec7e-499f-ace8-8419d91be939",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.6 Variable and VariableType\n---\n",
      "Content": "Variable and VariableType are shown in[Figure B.10](/\u00A7_Ref389585719)."
    },
    {
      "Id": "98a9607b-acbe-4a62-94f9-b75af7b19d8b",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.6 Variable and VariableType\nCaption: Figure B. 10 - Variable and VariableType\n---\n",
      "Content": "[image058.png](images/image058.png)"
    },
    {
      "Id": "1922ff73-3db8-4aaa-98d6-5e4538b17274",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.6 Variable and VariableType\n---\n",
      "Content": "Figure B. 10 - Variable and VariableType\nThe DataType of a Variable shall be the same as or a subtype of the DataType of its VariableType(referred with HasTypeDefinition).\nIf a HasProperty points to a Variable from a Base\u0022A\u0022 then the following constraints apply:\nThe Variable shall not be the SourceNode of a HasProperty or any other HierarchicalReferences Reference.\nAll Variables having \u0022A\u0022 as the SourceNode of a HasProperty Reference shall have a unique BrowseName in the context of \u0022A\u0022."
    },
    {
      "Id": "9cad3e55-6e4a-43f6-a905-1648deb76e42",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.7 Method"
    },
    {
      "Id": "00102a73-057b-4822-8535-328819a15333",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.7 Method\n---\n",
      "Content": "Method is shown in[Figure B.11](/\u00A7_Ref389585757)."
    },
    {
      "Id": "90891364-94fd-45f4-bee3-d4240a395fcc",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.7 Method\nCaption: Figure B. 11 - Method\n---\n",
      "Content": "[image059.png](images/image059.png)"
    },
    {
      "Id": "8f3af858-c735-4567-8799-db2abae455e2",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.7 Method\n---\n",
      "Content": "Figure B. 11 - Method"
    },
    {
      "Id": "cabb4e34-81e7-4cc0-a2cd-d55f3307e892",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.8 DataType"
    },
    {
      "Id": "003af38f-ed2d-4954-9303-15aeabdb6343",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.8 DataType\n---\n",
      "Content": "DataType is shown in[Figure B.12](/\u00A7_Ref389585790)."
    },
    {
      "Id": "308fbc04-f149-4977-996a-af1da5746c58",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.8 DataType\nCaption: Figure B. 12 - DataType\n---\n",
      "Content": "[image060.png](images/image060.png)"
    },
    {
      "Id": "1fb558a8-56d0-46e4-8d05-6e4292a1f39d",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.8 DataType\n---\n",
      "Content": "Figure B. 12 - DataType"
    },
    {
      "Id": "0736454b-681f-4550-ac84-af12594bbdbb",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3 Meta Model\n---\n",
      "Content": "B.3.9 View"
    },
    {
      "Id": "fddbe1ff-091e-436c-946c-b11c373adb25",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.9 View\n---\n",
      "Content": "View is shown in[Figure B.13](/\u00A7_Ref389585807)."
    },
    {
      "Id": "4c74bd58-fb1e-4d20-8068-179611026414",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.9 View\nCaption: Figure B. 13 - View\n---\n",
      "Content": "[image061.png](images/image061.png)"
    },
    {
      "Id": "6b304804-f62e-42f8-888a-a54a0b9fe924",
      "Header": "Document: Part 3 - Address Space Model\nSection: B.3.9 View\n---\n",
      "Content": "Figure B. 13 - View"
    },
    {
      "Id": "2f855bed-a9d3-4bc5-abee-02d46fbc2691",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "Annex\u00A0C(normative)Graphical notation\nC.1 General"
    },
    {
      "Id": "b737e70b-f820-42f0-8bd1-6acd24314c24",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.1 General\n---\n",
      "Content": "[Annex C](/\u00A7_Ref47431658) defines a graphical notation for OPC UA data.[Annex C](/\u00A7_Ref47431677) is normative, that is, the notation is used in this document to expose examples of OPC UA data. However, it is not required to use this notation to expose OPC UA data.\nThe graphical notation is able to expose all structural data of OPC UA. Nodes, their Attributes including their current value and References between the Nodes including the ReferenceType can be exposed. The graphical notation provides no mechanism to expose events or historical data."
    },
    {
      "Id": "754065f1-bcfd-437b-82ee-0f28d8be9787",
      "Header": "Document: Part 3 - Address Space Model\n---\n",
      "Content": "C.2 Notation"
    },
    {
      "Id": "bd581f01-abfe-45ad-964d-86b2f02f7e0a",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2 Notation\n---\n",
      "Content": "C.2.1 Overview"
    },
    {
      "Id": "00ef0984-d7bf-4184-9771-ee15e700d037",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.1 Overview\n---\n",
      "Content": "The notation is divided into two parts. The simple notation only provides a simplified view on the data hiding some details like Attributes. The extended notation allows exposing all structure information of OPC UA, including Attribute values. The simple and the extended notation can be combined to expose OPC UA data in one figure.\nCommon to both notations is that neither any colour nor the thickness or style of lines is relevant for the notation. Those effects can be used to highlight certain aspects of a figure."
    },
    {
      "Id": "2442c08d-ef38-4863-8cb0-040fe16590b6",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2 Notation\n---\n",
      "Content": "C.2.2 Simple notation"
    },
    {
      "Id": "f7944b6b-07c3-4b0b-a00c-6a2b8241250e",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\n---\n",
      "Content": "Depending on their NodeClass Nodes are represented by different graphical forms as defined in[Table C.1](/\u00A7_Ref205601224).\nTable C. 1 - Notation of Nodes depending on the NodeClass"
    },
    {
      "Id": "5eab7d62-7abf-4db4-b504-6749110b27e4",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\nCaption: Table C. 1 - Notation of Nodes depending on the NodeClass\n---\n",
      "Content": "NodeClass\nGraphical Representation\nComment\nObject\n[image062.png](images/image062.png)\nRectangle including text representing the string-part of the DisplayName of the Object. The font shall not be set to italic.\nObjectType\n[image063.png](images/image063.png)\nShadowed rectangle including text representing the string-part of the DisplayName of the ObjectType. The font shall be set in italic.\nVariable\n[image064.png](images/image064.png)\nRectangle with rounded corners including text representing the string-part of the DisplayName of the Variable. The font shall not be set in italic.\nVariableType\n[image065.png](images/image065.png)\nShadowed rectangle with rounded corners including text representing the string-part of the DisplayName of the VariableType. The font shall be set in italic.\nDataType\n[image066.png](images/image066.png)\nShadowed hexagon including text representing the string-part of the DisplayName of the DataType. The font shall be set in italic.\nReferenceType\n[image067.png](images/image067.png)\nShadowed six-sided polygon including text representing the string-part of the DisplayName of the ReferenceType. The font shall be set in italic.\nMethod\n[image068.png](images/image068.png)\nOval including text representing the string-part of the DisplayName of the Method. The font shall not be set to italic.\nView\n[image069.png](images/image069.png)\nTrapezium including text representing the string-part of the DisplayName of the View. The font shall not be set to italic."
    },
    {
      "Id": "0eb1eb78-decd-46a0-b2a9-066bd2f20ec2",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\n---\n",
      "Content": "References are represented as lines between Nodes as exemplified in[Figure C.1](/\u00A7_Ref246082533). Those lines can vary in their form. They do not have to connect the Nodes with a straight line; they can have angles, arches, etc."
    },
    {
      "Id": "b678af9f-1324-4776-adca-761ab0f197d2",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\nCaption: Figure C. 1 - Example of a Reference connecting two Nodes\n---\n",
      "Content": "[image070.png](images/image070.png)"
    },
    {
      "Id": "41b894f5-cd4b-4f83-aad2-a6965312fe5a",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\n---\n",
      "Content": "Figure C. 1 - Example of a Reference connecting two Nodes\n[Table C.2](/\u00A7_Ref205602357) defines how symmetric and asymmetric References are represented in general, and also defines shortcuts for some ReferenceTypes. Although it is recommended to use those shortcuts, it is not required. Thus, instead of using the shortcut, the generic solution can also be used.\nTable C. 2 - Simple Notation of Nodes depending on the NodeClass"
    },
    {
      "Id": "d166bf5b-db77-4319-964b-bfd5798734b1",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\nCaption: Table C. 2 - Simple Notation of Nodes depending on the NodeClass\n---\n",
      "Content": "ReferenceType\nGraphical Representation\nComment\nAny symmetric ReferenceType\n[image071.png](images/image071.png)\nSymmetric ReferenceTypes are represented as lines between Nodes with closed and filled arrows on both sides pointing to the connected Nodes. Near the line has to be a text containing the string-part of the BrowseName of the ReferenceType.\nAny asymmetric ReferenceType\n[image072.png](images/image072.png)\nAsymmetric ReferenceTypes are represented as lines between Nodes with a closed and filled arrow on the side pointing to the TargetNode. Near the line has to be a text containing the string-part of the BrowseName of the ReferenceType.\nAny hierarchical ReferenceType\n[image073.png](images/image073.png)\nAsymmetric ReferenceTypes that are subtypes of HierarchicalReferences should be exposed the same way as asymmetric ReferenceTypes except that an open arrow is used.\nHasComponent\n[image074.png](images/image074.png)\nThe notation provides a shortcut for HasComponent References shown on the left. The single hashed line has to be near the TargetNode.\nHasProperty\n[image075.png](images/image075.png)\nThe notation provides a shortcut for HasProperty References shown on the left. The double hashed lines have to be near the TargetNode.\nHasTypeDefinition\n[image076.png](images/image076.png)\nThe notation provides a shortcut for HasTypeDefinition References shown on the left. The double closed and filled arrows have to point to the TargetNode.\nHasSubtype\n[image077.png](images/image077.png)\nThe notation provides a shortcut for HasSubtype References shown on the left. The double closed arrows have to point to the SourceNode.\nHasEventSource\n[image078.png](images/image078.png)"
    },
    {
      "Id": "b8e6e62a-9e8c-4517-965d-5436e437f9a7",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\nCaption: Table C. 2 - Simple Notation of Nodes depending on the NodeClass\n---\n",
      "Content": "The notation provides a shortcut for HasEventSource References shown on the left. The closed arrow has to point to the TargetNode.\nHasInterface\n[image079.png](images/image079.png)\nThe notation provides a shortcut for the HasInterface References shown on the left. The closed arrow shall point to the TargetNode."
    },
    {
      "Id": "0134a126-0a9d-4288-8439-545bbe15847f",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.2 Simple notation\n---\n",
      "Content": ""
    },
    {
      "Id": "6e20acf7-b9b3-4a04-ae41-129705e5097e",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2 Notation\n---\n",
      "Content": "C.2.3 Extended notation"
    },
    {
      "Id": "115ee897-e946-47e4-b548-7a9999c5b074",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\n---\n",
      "Content": "In the extended notation some additional concepts are introduced. It is allowed only to use some of those concepts on elements of a figure.\nThe following rules define some special handling of structures.\nIn general, values of all DataTypes should be represented by an appropriate string representation. Whenever a NamespaceIndex or LocaleId is used in those structures they can be omitted.\nThe DisplayName contains a LocaleId and a String. Such a structure can be exposed as [\u003CLocaleId\u003E:]\u003CString\u003E where the LocaleId is optional. For example, a DisplayName can be \u0022en:MyName\u0022. Instead of that, \u0022MyName\u0022 can also be used. This rule applies whenever a DisplayName is shown, including the text used in the graphical representation of a Node.\nThe BrowseName contains the NamespaceIndex and a String. Such a structure can be exposed as [\u003CNamespaceIndex\u003E:]\u003CString\u003E where the NamespaceIndex is optional. For example, a BrowseName can be \u00221:MyName\u0022. Instead of that, \u0022MyName\u0022 can also be used. This rule applies whenever a BrowseName is shown, including the text used in the graphical representation of a Node.\nInstead of using the HasTypeDefinition reference to point from an Object or Variable to its ObjectType or VariableType the name of the TypeDefinition can be added to the text used in the Node. The TypeDefinition shall either be prefixed with \u0022::\u0022 or it is put in italic as the top line.[Figure C.2](/\u00A7_Ref205601252) gives an example, where \u0022Node1\u0022 uses a Reference and \u0022Node2\u0022 the shortcut in both notation variants. A figure can contain HasTypeDefinition References for some Nodes and the shortcut for other Nodes. It is not allowed that a Node uses the shortcut and additionally is the SourceNode of a HasTypeDefinition."
    },
    {
      "Id": "81e9b460-0d9f-4d5c-af42-154e0bfe0d30",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\nCaption: Figure C. 2 - Example of using a TypeDefinition inside a Node\n---\n",
      "Content": "[image080.png](images/image080.png)"
    },
    {
      "Id": "a9a77238-e2a5-4767-a933-46eab133f379",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\n---\n",
      "Content": "Figure C. 2 - Example of using a TypeDefinition inside a Node\nTo display Attributes of a Node additional text can be put inside the form representing the Node under the text representing the DisplayName. The DisplayName and the text describing the Attributes have to be separated using a horizontal line. Each Attribute has to be set into a new text line. Each text line shall contain the Attribute name followed by an \u0022=\u0022 and the value of the Attribute. On top of the first text line containing an Attribute shall be a text line containing the underlined text \u0022Attribute\u0022. It is not required to expose all Attributes of a Node. It is allowed to show only a subset of Attributes. If an optional Attribute is not provided, the Attribute can be marked by a strike-through line, for example \u0022Description\u0022. Examples of exposing Attributes are shown in[Figure C.3](/\u00A7_Ref205601271)."
    },
    {
      "Id": "a68733f9-2c87-4b61-befc-69f2771f3edc",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\nCaption: Figure C. 3 - Example of exposing Attributes\n---\n",
      "Content": "[image081.png](images/image081.png)"
    },
    {
      "Id": "7b0a5513-4fcb-4c8f-95ed-7c69a27c7176",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\n---\n",
      "Content": "Figure C. 3 - Example of exposing Attributes\nTo avoid too many Nodes in a figure it is allowed to expose Properties inside a Node, similar to Attributes. Therefore, the text field used for exposing Attributes is extended. Under the last text line containing an Attribute a new text line containing the underlined text \u0022Property\u0022 has to be added. If no Attribute is provided, the text has to start with this text line. After this text line, each new text line shall contain a Property, starting with the BrowseName of the Property followed by \u0022=\u0022 and the value of the Value Attribute of the Property.[Figure C.4](/\u00A7_Ref205601301) shows some examples exposing Properties inline. It is allowed to expose some Properties of a Node inline, and other Properties as Nodes. It is not allowed to show a Property inline as well as an additional Node."
    },
    {
      "Id": "f9b1022c-7d46-45e3-81dd-cb0694fb1f03",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\nCaption: Figure C. 4 - Example of exposing Properties inline\n---\n",
      "Content": "[image082.png](images/image082.png)"
    },
    {
      "Id": "11438a76-22b9-494d-9e50-7bb88da92eaa",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\n---\n",
      "Content": "Figure C. 4 - Example of exposing Properties inline\nAdding additional information to a figure using the graphical representation, for example callouts, is permitted.\n[Table C.3](/\u00A7_Ref36471433) defines how cardinality of Components with modelling rule are indicated on References.\nTable C. 3 - Extended Notation of Reference Cardinality"
    },
    {
      "Id": "47c67c33-f02c-4ec3-ad6e-77bb4ff73580",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\nCaption: Table C. 3 - Extended Notation of Reference Cardinality\n---\n",
      "Content": "Representation\nCardinality\nModelling Rule\nExample\n\nNot Specified\nNot Specified\n[image083.png](images/image083.png)\n1\nExactly 1\nMandatory\n[image084.png](images/image084.png)\n0..1\nZero or 1\nOptional\n[image085.png](images/image085.png)\n0..n\nZero to Many\nOptionalPlaceholder\n[image086.png](images/image086.png)\n1..n\nOne to Many\nMandatoryPlaceholder\n[image087.png](images/image087.png)\nx\nExactly x where x is greater than 1\nMandatoryPlaceholder\n[image088.png](images/image088.png)\n0..y\nMinimum of 0 to a maximum of y\nOptionalPlaceholder\n[image089.png](images/image089.png)\nx..y\nMinimum of x to a maximum of y where x and y are greater than 0 and y is greater than x\nMandatoryPlaceholder\n[image090.png](images/image090.png)"
    },
    {
      "Id": "096da673-fdb4-4f57-9e63-18e92100e30d",
      "Header": "Document: Part 3 - Address Space Model\nSection: C.2.3 Extended notation\n---\n",
      "Content": "Bibliography\n[GH95] Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, Design Patterns - Elements of Reusable Object-Oriented Software, Addison-Wesley 1995\n[https://www.oreilly.com/library/view/design-patterns-elements/0201633612/](https://www.oreilly.com/library/view/design-patterns-elements/0201633612/)\n\n[FF04] Eric Freeman, Elisabeth Freeman, Kathy Sierra, Bert Bates, Head First Design Patterns, O\u0027Reilly, 2004\n[https://www.oreilly.com/library/view/head-first-design/0596007124/](https://www.oreilly.com/library/view/head-first-design/0596007124/)\n\n______________"
    }
  ]
}
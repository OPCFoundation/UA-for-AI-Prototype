{
  "Title": "Part 6 - Mappings",
  "Chunks": [
    {
      "Id": "3c0beee2-0ded-4cb3-ab51-5f602f38690d",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "1 Scope"
    },
    {
      "Id": "5befffb8-2709-4b9e-a9d1-f1efd8604ca6",
      "Header": "Document: Part 6 - Mappings\nSection: 1 Scope\n---\n",
      "Content": "This part of OPC Unified Architecture (OPC UA) specifies the mapping between the security model described in[OPC 10000-2](/\u00A7UAPart2), the abstract service definitions specified in[OPC 10000-4](/\u00A7UAPart4), the data structures defined in[OPC 10000-5](/\u00A7UAPart5) and the physical network protocols that can be used to implement the OPC UA specification."
    },
    {
      "Id": "888d87c6-3c26-4702-8410-52f07d717697",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "2 Normative references"
    },
    {
      "Id": "16fae8fb-609e-4040-a1b9-66fa6ae940f9",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "The following documents, in whole or in part, are normatively referenced in this document and are indispensable for its application. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.\nOPC 10000-1, OPC Unified Architecture - Part 1: Overview and Concepts\n[http://www.opcfoundation.org/UA/Part1/](http://www.opcfoundation.org/UA/Part1/)\nOPC 10000-2, OPC Unified Architecture - Part 2: Security Model\n[http://www.opcfoundation.org/UA/Part2/](http://www.opcfoundation.org/UA/Part2/)\nOPC 10000-3, OPC Unified Architecture - Part 3: Address Space Model\n[http://www.opcfoundation.org/UA/Part3/](http://www.opcfoundation.org/UA/Part3/)\nOPC 10000-4, OPC Unified Architecture - Part 4: Services\n[http://www.opcfoundation.org/UA/Part4/](http://www.opcfoundation.org/UA/Part4/)\nOPC 10000-5, OPC Unified Architecture - Part 5: Information Model\n[http://www.opcfoundation.org/UA/Part5/](http://www.opcfoundation.org/UA/Part5/)\nOPC 10000-6, OPC Unified Architecture - Part 6: Mappings\n[http://www.opcfoundation.org/UA/Part6/](http://www.opcfoundation.org/UA/Part6/)\nOPC 10000-7, OPC Unified Architecture - Part 7: Profiles"
    },
    {
      "Id": "36811c3f-b60d-4b2f-8995-885b0a5f9900",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "[http://www.opcfoundation.org/UA/Part7/](http://www.opcfoundation.org/UA/Part7/)\nOPC 10000-9, OPC Unified Architecture - Part 9: Alarms and Conditions\n[http://www.opcfoundation.org/UA/Part9/](http://www.opcfoundation.org/UA/Part9/)\nOPC 10000-12, OPC Unified Architecture - Part 12: Discovery and Global Services\n[http://www.opcfoundation.org/UA/Part12/](http://www.opcfoundation.org/UA/Part12/)\nOPC 10000-14, OPC Unified Architecture - Part 14: PubSub\n[http://www.opcfoundation.org/UA/Part14/](http://www.opcfoundation.org/UA/Part14/)\nOPC 10000-18, OPC Unified Architecture - Part 18: Role-Based Security\n[http://www.opcfoundation.org/UA/Part18/](http://www.opcfoundation.org/UA/Part18/)\nOPC 10000-21, OPC Unified Architecture - Part 21: Device Onboarding\n[http://www.opcfoundation.org/UA/Part21/](http://www.opcfoundation.org/UA/Part21/)\nXML Schema Part 2: XML Schema Part 2: Datatypes\n[http://www.w3.org/TR/xmlschema-2/](http://www.w3.org/TR/xmlschema-2/)\nSOAP Part 1, SOAP Version 1.2 Part 1: Messaging Framework\n[http://www.w3.org/TR/soap12-part1/](http://www.w3.org/TR/soap12-part1/)"
    },
    {
      "Id": "3cce681a-1e12-4822-8fa8-07e0b6ebe017",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "WS Addressing, Web Services Addressing (WS-Addressing)\n[http://www.w3.org/Submission/ws-addressing/](http://www.w3.org/Submission/ws-addressing/)\nTLS, RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3\n[https://datatracker.ietf.org/doc/html/rfc8446](https://datatracker.ietf.org/doc/html/rfc8446)\nX.509 v3, ISO/IEC 9594-8 (ITU-T Rec. X.509), Information technology - Open Systems\nInterconnection - The Directory: Public-key and attribute certificate frameworks\nhttps://www.itu.int/rec/T-REC-X.509-201910-I/en\nHTTP, HTTP/1.1\nhttps://datatracker.ietf.org/doc/html/rfc9112\nHTTPS, HTTP Semantics\nhttps://datatracker.ietf.org/doc/html/rfc9110\nBase64, The Base16, Base32, and Base64 Data Encodings\n[https://datatracker.ietf.org/doc/html/rfc4648](https://datatracker.ietf.org/doc/html/rfc4648)\nX690, ISO/IEC 8825-1 (ITU-T Rec. X.690), Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\n[https://www.itu.int/rec/T-REC-X.690](https://www.itu.int/rec/T-REC-X.690)\nX200, ISO/IEC 7498-1 (ITU-T Rec. X.200), Information technology - Open Systems Interconnection - Basic Reference Model: The Basic Model"
    },
    {
      "Id": "71e6543d-018c-4b4f-9dc7-bfd4c5ac3fd9",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "[https://www.itu.int/rec/T-REC-X.200](https://www.itu.int/rec/T-REC-X.200)\nIEEE 754, 60559-2020 - ISO/IEC/IEEE International Standard - Standard for Floating-Point Arithmetic\n[https://ieeexplore.ieee.org/document/9091348](https://ieeexplore.ieee.org/document/9091348)\nHMAC, Keyed-Hashing for Message Authentication\n[https://datatracker.ietf.org/doc/html/rfc2104](https://datatracker.ietf.org/doc/html/rfc2104)\nPKCS #1, RSA Cryptography Specifications Version 2.2\n[https://datatracker.ietf.org/doc/html/rfc8017](https://datatracker.ietf.org/doc/html/rfc8017)\nPKCS #12, Personal Information Exchange Syntax v1.1\n[https://datatracker.ietf.org/doc/html/rfc7292](https://datatracker.ietf.org/doc/html/rfc7292)\nFIPS 180-4, Secure Hash Standard (SHS)\n[https://csrc.nist.gov/publications/detail/fips/180/4/final](https://csrc.nist.gov/publications/detail/fips/180/4/final)\nFIPS 197, Advanced Encryption Standard (AES)\n[https://www.nist.gov/publications/advanced-encryption-standard-aes](https://www.nist.gov/publications/advanced-encryption-standard-aes)\nUTF-8, UTF-8, a transformation format of ISO 10646\n[https://datatracker.ietf.org/doc/html/rfc3629](https://datatracker.ietf.org/doc/html/rfc3629)\nRFC 5280, Internet X.509 Public Key Infrastructure Certificate"
    },
    {
      "Id": "1b708ce1-d0ac-42af-81b9-6d961c5846f6",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "and Certificate Revocation List (CRL) Profile\n[https://datatracker.ietf.org/doc/html/rfc5280](https://datatracker.ietf.org/doc/html/rfc5280)\nRFC 6818, Updates to the Internet X.509 Public Key Infrastructure\nCertificate and Certificate Revocation List (CRL) Profile\n[https://datatracker.ietf.org/doc/html/rfc6818](https://datatracker.ietf.org/doc/html/rfc6818)\nRFC 4514, LDAP: String Representation of Distinguished Names\n[https://datatracker.ietf.org/doc/html/rfc4514](https://datatracker.ietf.org/doc/html/rfc4514)\nNTP, Network Time Protocol Version 4: Protocol and Algorithms Specification\n[https://datatracker.ietf.org/doc/html/rfc5905](https://datatracker.ietf.org/doc/html/rfc5905)\nRFC 3986, Uniform Resource Identifier (URI): Generic Syntax\n[https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)\nRFC 8141, Uniform Resource Names (URNs)\n[https://datatracker.ietf.org/doc/html/rfc8141](https://datatracker.ietf.org/doc/html/rfc8141)\nRFC 6455, The WebSocket Protocol\n[https://datatracker.ietf.org/doc/html/rfc6455](https://datatracker.ietf.org/doc/html/rfc6455)\nRFC 8259, The JavaScript Object Notation (JSON) Data Interchange Format\n[https://datatracker.ietf.org/doc/html/rfc8259](https://datatracker.ietf.org/doc/html/rfc8259)\nRFC 7519, JSON Web Token (JWT)"
    },
    {
      "Id": "b517ebde-4c2d-4c14-919e-b3d740ee58cb",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "[https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)\nRFC 7523, JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and\nAuthorization Grants\n[https://datatracker.ietf.org/doc/html/rfc7523](https://datatracker.ietf.org/doc/html/rfc7523)\nRFC 8705, OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens\n[https://datatracker.ietf.org/doc/html/rfc8705](https://datatracker.ietf.org/doc/html/rfc8705)\nhttps://www.rfc-editor.org/rfc/rfc8705.html\nRFC 6749, The OAuth 2.0 Authorization Framework\n[https://datatracker.ietf.org/doc/html/rfc6749](https://datatracker.ietf.org/doc/html/rfc6749)\nOpenID-Core, OpenID Connect Core 1.0\n[http://openid.net/specs/openid-connect-core-1_0.html](http://openid.net/specs/openid-connect-core-1_0.html)\nOpenID-Discovery, OpenID Connect Discovery 1.0\n[https://openid.net/specs/openid-connect-discovery-1_0.html](https://openid.net/specs/openid-connect-discovery-1_0.html)\nRFC 6960, X.509 Internet Public Key Infrastructure - Online Certificate Status Protocol - OCSP\n[https://datatracker.ietf.org/doc/html/rfc6960](https://datatracker.ietf.org/doc/html/rfc6960)\nRFC 5869, HMAC-based Extract-and-Expand Key Derivation Function (HKDF)"
    },
    {
      "Id": "aec45db7-7058-4031-b1d9-2d4e8ba52c89",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "[https://datatracker.ietf.org/doc/html/rfc5869](https://datatracker.ietf.org/doc/html/rfc5869)\nRFC 8422, Elliptic Curve Cryptography (ECC) Cipher Suites\n[https://datatracker.ietf.org/doc/html/rfc8422](https://datatracker.ietf.org/doc/html/rfc8422)\nRFC 6750, The OAuth 2.0 Authorization Framework: Bearer Token Usage\n[https://datatracker.ietf.org/doc/html/rfc6750](https://datatracker.ietf.org/doc/html/rfc6750)\nISO 8601-1, Date and time - Representations for information interchange - Part 1: Basic rules\n[https://www.iso.org/standard/70907.html](https://www.iso.org/standard/70907.html)\nRFC 5234, Augmented BNF for Syntax Specifications: ABNF\n[https://datatracker.ietf.org/doc/html/rfc5234](https://datatracker.ietf.org/doc/html/rfc5234)\nRFC 4151, The \u0027tag\u0027 URI Scheme\n[https://datatracker.ietf.org/doc/html/rfc4151](https://datatracker.ietf.org/doc/html/rfc4151)\nSemVer, Semantic Versioning 2.0.0\nhttps://semver.org/spec/v2.0.0.html\nOpenAPI, OpenAPI Specification v3.0\n[https://spec.openapis.org/oas/v3.0.4.html](https://spec.openapis.org/oas/v3.0.4.html)\nJSON Schema, JSON Schema 2020-12\n[https://json-schema.org/specification](https://json-schema.org/specification)\nRFC 1952: GZIP file format specification version 4.3"
    },
    {
      "Id": "7c814f4c-62c3-45ba-9dad-901dfe3c3c28",
      "Header": "Document: Part 6 - Mappings\nSection: 2 Normative references\n---\n",
      "Content": "https://www.rfc-editor.org/rfc/rfc1952\nAES-CTR, NIST SP 800-38A: Recommendation for Block Cipher Modes of Operation\nhttps://csrc.nist.gov/pubs/sp/800/38/a/final"
    },
    {
      "Id": "c0b5125f-ae9a-431f-8a40-bc3fb78a51ee",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "3 Terms, definitions and abbreviated terms"
    },
    {
      "Id": "9b2639c1-5f8d-4b60-bf10-4e9622b6c54f",
      "Header": "Document: Part 6 - Mappings\nSection: 3 Terms, definitions and abbreviated terms\n---\n",
      "Content": "3.1 Terms and definitions"
    },
    {
      "Id": "fac99402-6e66-4433-9592-139131da3875",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "For the purposes of this document the terms and definitions given in[OPC 10000-1](/\u00A7UAPart1),[OPC 10000-2](/\u00A7UAPart2) and[OPC 10000-3](/\u00A7UAPart3) as well as the following apply.\n3.1.1 CertificateDigest"
    },
    {
      "Id": "a8671307-75d9-404f-b180-0b24080c33c8",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.1 CertificateDigest\n---\n",
      "Content": "short identifier used to uniquely identify an[X.509 v3](/\u00A7X509) Certificate.\nNote 1 to entry: This is the SHA1 hash of DER encoded form of the Certificate."
    },
    {
      "Id": "7f5a3c87-33f9-40d5-9180-fdff084c65a4",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.2 DataEncoding"
    },
    {
      "Id": "2c79af57-2e3c-4cde-bb0a-614f0b21fd75",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.2 DataEncoding\n---\n",
      "Content": "way to serialize messages and data structures."
    },
    {
      "Id": "50c3cbd9-d394-47db-b169-61a38fba0b36",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.3 DefaultValue"
    },
    {
      "Id": "b4a5311b-b127-4ca3-a56b-38e3428fde61",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.3 DefaultValue\n---\n",
      "Content": "a value that is used when no other value is known or available."
    },
    {
      "Id": "0d92e305-ef8b-4014-9f67-ef236fe7a0bc",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.4 DevelopmentPlatform"
    },
    {
      "Id": "a0052f06-338d-40ce-ae78-39cceaff5e37",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.4 DevelopmentPlatform\n---\n",
      "Content": "suite of tools and/or programming languages used to create software."
    },
    {
      "Id": "a3a009d9-e355-4279-baf4-2dafef1d75ca",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.5 Mapping"
    },
    {
      "Id": "e1421140-b867-4ec2-91d9-18ed75ac43f5",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.5 Mapping\n---\n",
      "Content": "specification on how to implement an OPC UA feature with a specific technology.\nNote 1 to entry: For example, the OPC UA Binary Encoding is a Mapping that specifies how to serialize OPC UA data structures as sequences of bytes."
    },
    {
      "Id": "a8f60e20-2371-4884-be21-13cc108ce9f2",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.6 VerboseEncoding"
    },
    {
      "Id": "72d6221d-8294-465d-acbf-322f72a07765",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.6 VerboseEncoding\n---\n",
      "Content": "A DataEncoding where the serialized form does not omit optional or default values and adds additional descriptive text.\nNote 1 to entry: VerboseEncodings are used when the consumers of the data do not have access to schema information and rely on the self-describing nature of DataEncodings such as JSON\nNote 2 to entry: A VerboseEncoding is only defined for the JSON DataEncoding."
    },
    {
      "Id": "a2e6faf7-cad8-4107-aebb-29cb1225f44f",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.7 OctetString"
    },
    {
      "Id": "ca8ecdec-a87c-4954-bd52-475b598a6280",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.7 OctetString\n---\n",
      "Content": "a sequence of zero or more octets without any length prefix.\nNote 1 to entry: an OctetString is not defined as a DataType and only used in this document when a ByteString is not appropriate."
    },
    {
      "Id": "50ec496b-be59-489b-bff1-654d8b1f2e56",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.8 CompactEncoding"
    },
    {
      "Id": "136a8bcb-4e6c-494b-9961-19e6cc4ddcff",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.8 CompactEncoding\n---\n",
      "Content": "A DataEncoding where encoding the serialized form omits optional and default values.\nNote 1 to entry: All DataEncodings are CompactEncodings unless otherwise stated."
    },
    {
      "Id": "6e489c4a-44e5-4044-9994-f483cfe22cec",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.9 SecurityProtocol"
    },
    {
      "Id": "489281df-264b-486d-8a95-e959db303a1e",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.9 SecurityProtocol\n---\n",
      "Content": "Protocol which ensures the integrity and privacy of UA Messages that are exchanged between OPC UA applications"
    },
    {
      "Id": "f03ae32a-b120-48ce-8eb5-8ebfa0fc2894",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.10 StackProfile"
    },
    {
      "Id": "fb7cbf98-632d-4906-9a10-485a3e5642f3",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.10 StackProfile\n---\n",
      "Content": "combination of DataEncodings, SecurityProtocol and TransportProtocol Mappings\nNote 1 to entry: OPC UA applications implement one or more StackProfiles and can only communicate with OPC UA applications that support a StackProfile that they support."
    },
    {
      "Id": "83fbdd4c-af19-4436-bb6b-21918b624613",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.11 TransportConnection"
    },
    {
      "Id": "0451ce4e-51bd-406a-9b87-aa68d2ba28f0",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.11 TransportConnection\n---\n",
      "Content": "full-duplex communication link established between OPC UA applications.\nNote 1 to entry: A TCP/IP socket is an example of a TransportConnection."
    },
    {
      "Id": "1c177b69-711d-45c8-bee4-08ce54b79059",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1 Terms and definitions\n---\n",
      "Content": "3.1.12 TransportProtocol"
    },
    {
      "Id": "574ec9b0-28fd-47c5-a7b5-a50892d9d926",
      "Header": "Document: Part 6 - Mappings\nSection: 3.1.12 TransportProtocol\n---\n",
      "Content": "way to exchange serialized OPC UA Messages between OPC UA applications"
    },
    {
      "Id": "8d9c90d5-c6ae-4b2d-8935-f6b83387d6e3",
      "Header": "Document: Part 6 - Mappings\nSection: 3 Terms, definitions and abbreviated terms\n---\n",
      "Content": "3.2 Abbreviated terms"
    },
    {
      "Id": "8e817b61-2469-4cea-abe6-99c55b76dcfc",
      "Header": "Document: Part 6 - Mappings\nSection: 3.2 Abbreviated terms\n---\n",
      "Content": "AEAD Authenticated Encryption with Associated Data\nAPI Application Programming Interface\nASN.1 Abstract Syntax Notation #1 (used in[X690](/\u00A7X690))\nCSV Comma Separated Value (File Format)\nDNS Domain Name Service\nECC Elliptic Curve Cryptography\nHTTP Hypertext Transfer Protocol\nHTTPS Secure Hypertext Transfer Protocol\nIANA Internet Assigned Numbers Authority\nIPSec Internet Protocol Security\nJWT JSON Web Token\nNAT Network Address Translation\nOID Object Identifier (used with ASN.1)\nPRF Pseudo Random Function\nRSA Rivest, Shamir and Adleman [Public Key Encryption System]\nSHA1 Secure Hash Algorithm\nSOAP Simple Object Access Protocol\nSSL Secure Sockets Layer (Defined in[TLS](/\u00A7Tls))\nTCP Transmission Control Protocol\nTLS Transport Layer Security (Defined in[TLS](/\u00A7Tls))\nUA Unified Architecture\nUACP OPC UA Connection Protocol\nUASC OPC UA Secure Conversation\nWS-* XML Web Services Specifications\nXML Extensible Markup Language"
    },
    {
      "Id": "7d03ca6b-200e-4f8a-9645-a4a1e56d5504",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "4 Overview"
    },
    {
      "Id": "4aab324f-6220-489b-a8fe-cb2c14331037",
      "Header": "Document: Part 6 - Mappings\nSection: 4 Overview\n---\n",
      "Content": "Other parts of the OPC 10000 series are written to be independent of the technology used for implementation. This approach means OPC UA is a flexible specification that will continue to be applicable as technology evolves. On the other hand, this approach means that it is not possible to build an OPC UA application with the information contained in[OPC 10000-1](/\u00A7UAPart1) through to[OPC 10000-5](/\u00A7UAPart5) because important implementation details have been left out.\nThis document defines Mappings between the abstract specifications and technologies that can be used to implement them. The Mappings are organized into three groups: DataEncodings, SecurityProtocols and TransportProtocols. Different Mappings are combined together to create StackProfiles. All OPC UA applications shall implement at least one StackProfile and can only communicate with other OPC UA applications that implement the same StackProfile.\nThis document defines the DataEncodings in Clause[5](/\u00A7_Ref177411975), the SecurityProtocols in[5.4](/\u00A7_Ref164133776) and the TransportProtocols in[6.7.6](/\u00A7_Ref164133819). The StackProfiles are defined in[OPC 10000-7](/\u00A7UAPart7).\nAll communication between OPC UA applications is based on the exchange of Messages. The parameters contained in the Messages are defined in[OPC 10000-4](/\u00A7UAPart4); however, their format is specified by the DataEncoding and TransportProtocol. For this reason, each Message defined in[OPC 10000-4](/\u00A7UAPart4) shall have a normative description which specifies exactly what shall be put on the wire. The normative descriptions are defined in the annexes.\nA Stack"
    },
    {
      "Id": "a3406d96-dad7-4adb-94f3-cc9809a60452",
      "Header": "Document: Part 6 - Mappings\nSection: 4 Overview\n---\n",
      "Content": "A Stack is a collection of software libraries that implement one or more StackProfiles. The interface between an OPC UA application and the Stack is a non-normative API which hides the details of the Stack implementation. An API depends on a specific DevelopmentPlatform. Note that the datatypes exposed in the API for a DevelopmentPlatform may not match the datatypes defined by the specification because of limitations of the DevelopmentPlatform. For example, Java Programming Language does not support an unsigned integer which means that any API will need to map unsigned integers onto a signed integer type.\n[Figure 1](/\u00A7_Ref164135651) illustrates the relationships between the different concepts defined in this document."
    },
    {
      "Id": "5e1cd5e7-fbe5-4f9f-8b89-165a641e7f40",
      "Header": "Document: Part 6 - Mappings\nSection: 4 Overview\nCaption: Figure 1 - The OPC UA Stack Overview\n---\n",
      "Content": "[image004.png](images/image004.png)"
    },
    {
      "Id": "3f6a9536-ed91-47a3-b96e-479ccef85e09",
      "Header": "Document: Part 6 - Mappings\nSection: 4 Overview\n---\n",
      "Content": "Figure 1 - The OPC UA Stack Overview\nThe layers described in this specification do not correspond to layers in the OSI 7-layer model [[X200](/\u00A7X200)]. Each OPC UA StackProfile should be treated as a single Layer 7 (application) protocol that is built on an existing Layer 5, 6 or 7 protocol such as TCP/IP, TLS or[HTTP](/\u00A7Http). The SecureChannel layer is always present even if the SecurityMode is None. In this situation, no security is applied but the SecurityProtocol implementation shall maintain a logical channel with a unique identifier. Users and administrators are expected to understand that a SecureChannel with SecurityMode set to None cannot be trusted unless the application is operating on a physically secure network or a low-level protocol such as IPSec is being used."
    },
    {
      "Id": "2e3e0b32-30fc-45ed-9fe1-b93a70232e12",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "5 Data encoding"
    },
    {
      "Id": "1ed8f072-a89b-484e-a35e-02b05ef2f3fa",
      "Header": "Document: Part 6 - Mappings\nSection: 5 Data encoding\n---\n",
      "Content": "5.1 General"
    },
    {
      "Id": "1b7604ea-cd26-4164-a623-ace23f295874",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.1 Overview"
    },
    {
      "Id": "5bb13774-1a09-4abf-bc31-1aa67d253510",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.1 Overview\n---\n",
      "Content": "This document defines three DataEncodings: OPC UA Binary, OPC UA XML and OPC UA JSON. It describes how to construct Messages using each of these encodings."
    },
    {
      "Id": "60cad7e3-b692-47a1-a3ed-d7e88e7dcb18",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.2 Built-in Types"
    },
    {
      "Id": "0ccdd080-1b4d-49b9-98a5-8a8962453f50",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.2 Built-in Types\n---\n",
      "Content": "All OPC UA DataEncodings are based on rules that are defined for a standard set of built-in types. These built-in types are then used to construct structures, arrays and Messages. The built-in types are described in[Table 1](/\u00A7_Ref83387521).\nTable 1- Built-in Data Types\nID\nName\nNullable\nDefault\nDescription\n1\nBoolean\nNo\nfalse\nA two-state logical value (true or false).\n2\nSByte\nNo\n0\nAn integer value between \u2212128 and 127 inclusive.\n3\nByte\nNo\n0\nAn integer value between 0 and 255 inclusive.\n4\nInt16\nNo\n0\nAn integer value between \u221232768 and 32767 inclusive.\n5\nUInt16\nNo\n0\nAn integer value between 0 and 65535 inclusive.\n6\nInt32\nNo\n0\nAn integer value between \u22122,147,483,648 and 2,147,483,647 inclusive.\n7\nUInt32\nNo\n0\nAn integer value between 0 and 4,294,967,295 inclusive.\n8\nInt64\nNo\n0\nAn integer value between \u22129,223,372,036,854,775,808 and 9,223,372,036,854,775,807 inclusive.\n9\nUInt64\nNo\n0\nAn integer value between 0 and 18,446,744,073,709,551,615 inclusive.\n10\nFloat\nNo\n0\nAn IEEE single precision (32 bit) floating point value.\n11\nDouble\nNo\n0\nAn IEEE double precision (64 bit) floating point value.\n12\nString\nYes\nnull\nA sequence of Unicode characters.\n13"
    },
    {
      "Id": "d912f755-e81f-44c8-aed4-11918b8a4baa",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.2 Built-in Types\n---\n",
      "Content": "13\nDateTime\nYes\nDateTime.MinValue (see[5.1.4](/\u00A7_Ref43238679))\nAn instance in time.\n14\nGuid\nYes\nAll zeros\nA 16-byte value that can be used as a globally unique identifier.\n15\nByteString\nYes\nnull\nA sequence of octets.\n16\nXmlElement\nYes\nnull\nA sequence of Unicode characters that is an XML element.\nThis built-in type shall not have subtypes.\n17\nNodeId\nYes\nAll fields set to default.\nAn identifier for a node in the address space of an OPC UA Server.\n18\nExpandedNodeId\nYes\nAll fields set to default.\nA NodeId that allows the namespace URI to be specified instead of an index.\n19\nStatusCode\nNo\nGood\nA numeric identifier for an error or condition that is associated with a value or an operation.\n20\nQualifiedName\nYes\nAll fields set to default.\nA name qualified by a namespace.\n21\nLocalizedText\nYes\nAll fields set to default.\nHuman readable text with an optional locale identifier.\n22\nExtensionObject\nYes\nAll fields set to default.\nA structure that contains an application specific data type that may not be recognized by the receiver.\n23\nDataValue\nYes\nAll fields set to default.\nA data value with an associated status code and timestamps.\n24\nVariant\nYes\nNull\nA union of all of the types specified above.\n25\nDiagnosticInfo\nYes\nNo fields specified.\nA structure that contains detailed error and diagnostic information associated with a StatusCode.\n\nMost of these data types are the same as the abstract types defined in[OPC 10000-3](/\u00A7UAPart3) and"
    },
    {
      "Id": "00aa79b1-a49f-44c6-a35e-5236d52be7d9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.2 Built-in Types\n---\n",
      "Content": "and[OPC 10000-4](/\u00A7UAPart4). However, the ExtensionObject and Variant types are defined in this document. In addition, this document defines a representation for the Guid type defined in[OPC 10000-3](/\u00A7UAPart3).\nThe Nullable column indicates whether a \u0027null\u0027 value exists for the DataType in all DataEncodings. A \u0027null\u0027 value is a value that is equavalent \u0027no value specified\u0027. A nullable type with a default value means the default value shall be interpreted equivalent to a null.\nThe Default column specifies the default value for the type if a default value is needed. The default value for all arrays is \u0027null\u0027."
    },
    {
      "Id": "3c604b2e-1860-48cd-be1c-b3d4aa9c80af",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.3 Guid"
    },
    {
      "Id": "51552bb5-1e99-4e5f-8059-c40928bbfe05",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.3 Guid\n---\n",
      "Content": "A Guid is a 16-byte globally unique identifier with the layout shown in[Table 2](/\u00A7_Ref179432783).\nTable 2- Guid structure\nComponent\nData Type\nData1\nUInt32\nData2\nUInt16\nData3\nUInt16\nData4\nByte [8]\n\nGuid values may be represented as a string in this form:\n\u003CData1\u003E-\u003CData2\u003E-\u003CData3\u003E-\u003CData4[0:1]\u003E-\u003CData4[2:7]\u003E\nwhere Data1 is 8 characters wide, Data2 and Data3 are 4 characters wide and each Byte in Data4 is 2 characters wide. Each value is formatted as a hexadecimal number with padded zeros. A typical Guid value would look like this when formatted as a string:\nC496578A-0DFE-4B8F-870A-745238C6AEAE"
    },
    {
      "Id": "4a05e03a-281e-4fac-a114-bbd7dfbd4728",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.4 DateTime"
    },
    {
      "Id": "0388ee03-218d-4208-8d08-3ff2788365eb",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.4 DateTime\n---\n",
      "Content": "DateTime values have different ranges on different DevelopmentPlatforms. To ensure interoperablity two named values are defined:\n\u0022DateTime.MinValue\u0022 is the earliest value that can be represented;\n\u0022DateTime.MaxValue\u0022 is the latest value that can be represented.\nIf the range supported by the DataEncoding is outside of the range supported by a DevelopmentPlatform then decoders shall replace any below range values with DateTime.MinValue and any above range values with DateTime.MaxValue for the DevelopmentPlatform.\nIf the range supported by a DevelopmentPlatform is outside of the range supported by a DataEncoding then encoders shall replace any below range values with DateTime.MinValue and any above range values with DateTime.MaxValue for the DataEncoding.\nThe representation of a DateTime on a DevelopmentPlatform also has a maximum precision. Decoders shall truncate DateTime values that exceed the supported precision. All DevelopmentPlatforms shall support a precision of at least 1ms.\nThe DataValue built-in type adds additional fields for Picoseconds. If a DevelopmentPlatform cannot support the full precision of DateTime values allowed by the DataEncoding then it should expand the size of its internal representation of Picoseconds field to preserve the full precision of the DateTime. If it does not do this it shall set the Picoseconds to 0.\nThe Picoseconds shall be set to 0 when the DateTime value is DateTime.MinValue or DateTime.MaxValue.\nConcrete examples can be found in[5.2.2.5](/\u00A7_Ref400565610)."
    },
    {
      "Id": "1325d6f4-5410-46cd-9663-76ddea8d93c1",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.5 ByteString"
    },
    {
      "Id": "5ac77ceb-f812-4a73-951f-0918b0164516",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.5 ByteString\n---\n",
      "Content": "A ByteString is structurally the same as a one-dimensional array of Byte. It is represented as a distinct built-in data type because it allows encoders to optimize the transmission of the value. However, some DevelopmentPlatforms will not be able to preserve the distinction between a ByteString and a one-dimensional array of Byte.\nIf a decoder for DevelopmentPlatform cannot preserve the distinction it shall convert all one-dimensional arrays of Byte to ByteStrings.\nEach element in a one-dimensional array of ByteString can have a different length which means is structurally different from a two-dimensional array of Byte where the length of each dimension is the same. This means decoders shall preserve the distinction between two or more dimension arrays of Byte and one or more dimension arrays of ByteString.\nIf a DevelopmentPlatform does not support unsigned integers, then it will have to represent ByteStrings as arrays of SByte. In this case, the requirements for Byte would then apply to SByte."
    },
    {
      "Id": "97776b98-f53e-4966-861b-345489595064",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.6 Number, Integer and UInteger"
    },
    {
      "Id": "317ee767-6296-4a92-903d-a9edbe6c1a68",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.6 Number, Integer and UInteger\n---\n",
      "Content": "Number, Integer and UInteger are abstract simple types defined in[OPC 10000-3](/\u00A7UAPart3). When these types are used in Structure fields, the field value is encoded as a Variant."
    },
    {
      "Id": "71e5c0f1-f8ac-44b2-9825-9825657ecf3a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.7 Structures and Unions"
    },
    {
      "Id": "01b7946f-b2ad-4762-a255-87fa600323b3",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.7 Structures and Unions\n---\n",
      "Content": "Structures are sequences of name value pairs defined by the DataTypeDefinition Attribute in[OPC 10000-3](/\u00A7UAPart3). Each DataEncoding describes how to use the DataTypeDefinition to serialize Structures. Subtypes of Structure extend the parent by adding additional name-value pairs to the sequence.\nIf a DataTypeDefinition sets the StructureType to StructureWithSubtypedValues then any field with a subtype of Structure DataType and IsOptional =TRUE allows the type and any subtype of the field\u0027s DataType to be present in the field. In these cases, the values are serialized as an ExtensionObject. If IsOptional =FALSE then the field value is encoded directly according to the rules for the DataEncoding.\nA field is serialized as an ExtensionObject if a field has a DataType set explicitly to Structure.\nUnions are special subtypes of Structure where only one field value is encoded. All subtypes of Union are concrete. The remainder of the rules for Structure also apply to Unions."
    },
    {
      "Id": "4f186041-2984-437c-8654-123ca99acdbb",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.8 ExtensionObject"
    },
    {
      "Id": "02e3c08c-03f3-451e-9b2c-85f26e189d62",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.8 ExtensionObject\n---\n",
      "Content": "An ExtensionObject is a container for any Structure and Union DataTypes.\nThe ExtensionObject contains a complex value serialized as a sequence of other DataTypes. It also contains an identifier which indicates what data it contains and how it is encoded.\nThere are four primary use cases where ExtensionObjects appear:\nWhen encoding a top-level DataType as a Service Request or Response;\nWhen encoding a Structure value inside a Variant;\nWhen encoding a field value in a Structure where the field DataType is Structure.\nWhen encoding a field value in a Structure where AllowSubTypes =TRUE (see[F.12](/\u00A7_Ref472366023)).\nIn all of these cases, the ExtensionObject provides an identifier that allows a decoder to know if it understands the Structure contained with it and a length that allows the Structure to be skipped if it is not recognized.\nStructured DataTypes are represented in a Server address space as sub-types of the Structure DataType. The DataEncodings available for any given Structured DataTypes are represented as a DataTypeEncoding Object in the Server AddressSpace. The NodeId for the DataTypeEncoding Object is the identifier stored in the ExtensionObject.[OPC 10000-3](/\u00A7UAPart3) describes how DataTypeEncoding Nodes are related to other Nodes of the AddressSpace.\nElements of an array of ExtensionObjects may have different DataTypeEncoding NodeIds specified. In some cases, this will be invalid, however, it is the responsibility of the application layer to enforce whatever constraints are imposed by the Information Model on a given array. Decoders shall accept any valid ExtensionObject as an array element.\nServer implementers should use namespace qualified numeric NodeIds for any DataTypeEncoding Objects they define. This will minimize the overhead introduced by packing Structured DataType values into an ExtensionObject.\nExtensionObjects and Variants"
    },
    {
      "Id": "a94862b6-d35c-449e-9a5d-17533859bb96",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.8 ExtensionObject\n---\n",
      "Content": "ExtensionObjects and Variants allow unlimited nesting which could result in stack overflow errors even if the message size is less than the maximum allowed. Decoders shall support at least 100 nesting levels. Decoders shall report an error if the number of nesting levels exceeds what it supports."
    },
    {
      "Id": "6a8e8120-2f03-443a-8582-dd6856cfa2a3",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.9 Variant"
    },
    {
      "Id": "3ce20175-3c38-4b47-ac67-ae82bca08a9a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.9 Variant\n---\n",
      "Content": "A Variant is a union of all built-in data types including an ExtensionObject. Variants can also contain arrays of any of these built-in types. Variants are used to store any value or parameter with a data type of BaseDataType or one of its subtypes.\nVariants can be empty. An empty Variant is described as having a null value and should be treated like a null column in a SQL database. A null value in a Variant may not be the same as a null value for data types that support nulls such as Strings. Some DevelopmentPlatforms may not be able to preserve the distinction between a null for a DataType and a null for a Variant, therefore, applications shall not rely on this distinction. This requirement also means that if an Attribute supports the writing of a null value it shall also support writing of an empty Variant and vice versa.\nVariants can contain arrays of Variants but they cannot directly contain another Variant.\nDiagnosticInfo types only have meaning when returned in a response message with an associated StatusCode and table of strings. As a result, Variants cannot contain instances of DiagnosticInfo.\nValues of Attributes are always returned in instances of DataValues. Therefore, the DataType of an Attribute cannot be a DataValue. Variants can contain DataValue when used in other contexts such as Method Arguments or PubSub Messages. The Variant in a DataValue cannot, directly or indirectly, contain another DataValue.\nExtensionObjects and Variants allow unlimited nesting which could result in stack overflow errors even if the message size is less than the maximum allowed. Decoders shall support at least 100 nesting levels. Decoders shall report an error if the number of nesting levels exceeds what it supports."
    },
    {
      "Id": "64c1b430-892a-434d-9bf6-b3daa31b09e5",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.10 Decimal"
    },
    {
      "Id": "4f0143bc-5122-4795-81ad-d4195d2e4978",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.10 Decimal\n---\n",
      "Content": "A Decimal is a high-precision signed decimal number. It consists of an arbitrary precision integer unscaled value and an integer scale. The scale is the inverse power of ten that is applied to the unscaled value.\nA Decimal has the fields described in[Table 3](/\u00A7_Ref473271895).\nTable 3- Layout of Decimal\nField\nType\nDescription\nTypeId\nNodeId\nThe identifier for the Decimal DataType.\nEncoding\nByte\nThis value is always 1.\nLength\nInt32\nThe length of the Scale and Value fields in bytes.If the length is less than or equal to 2 then the Decimal is an invalid value that cannot be used.\nScale\nInt16\nA signed integer representing scale which is the inverse power of ten that is applied to the unscaled value.\ni.e., the decimal number of the value multiplied by 10-scale\nThe integer is encoded starting with the least significant bit.\nValue\nOctetString\nA 2-complement signed integer representing the unscaled value.\nThe number of bytes is the value of the Length field minus size of the Scale field.\nThe integer is encoded with the least significant byte first.\n\nWhen a Decimal is encoded in a Variant the built-in type is set to ExtensionObject. Decoders that do not understand the Decimal type shall treat it like any other unknown Structure and pass it on to the application. Decoders that do understand the Decimal can parse the value and use any construct that is suitable for the DevelopmentPlatform. Note that a Decimal is like a built-in type and a DevelopmentPlatform has to have hardcoded knowledge of the type. No Structure metadata is published for this type.\nIf a Decimal is embedded in another Structure then the DataTypeDefinition for the field shall specify the NodeId of the Decimal Node as the DataType. If a Server"
    },
    {
      "Id": "78d535c7-7680-4a9f-9d2c-b8329132ea79",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.10 Decimal\n---\n",
      "Content": "DataType. If a Server publishes an OPC Binary type description for the Structure then the type description shall set the DataType for the field to ExtensionObject."
    },
    {
      "Id": "e87ca257-b826-482b-bb11-e8064e6b77f8",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.11 Null, Empty and Zero-Length Arrays"
    },
    {
      "Id": "fb94fd27-f657-44dc-ba19-08894850db23",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.11 Null, Empty and Zero-Length Arrays\n---\n",
      "Content": "The terms null, empty and zero-length are used to describe array values ( Strings are arrays of characters and ByteStrings are arrays of Bytes for purposes of this discussion). A null array has no value. A zero-length or empty array is an array with 0 elements. Some DataEncodings will allow the distinction to be preserved on the wire, however, not all DevelopmentPlatforms will be able to preserve the distinction. For this reason, null, empty and zero length arrays are semantically the same for all DataEncodings. Decoders shall be able to handle all variations supported by the DataEncoding, however, decoders are not required to preserve the distinction. When testing for equality, applications shall treat null and empty arrays as equal. When a DevelopmentPlatform supports the distinction, writing and reading back an array value may result in null array becoming an empty array or vice versa."
    },
    {
      "Id": "c18bc785-ff82-4984-9e69-b6184ce01a9f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.12 QualifiedName, NodeId and ExpandedNodeId String Encoding"
    },
    {
      "Id": "e47e5498-046b-429e-b228-a54cdb3fcee8",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.12 QualifiedName, NodeId and ExpandedNodeId String Encoding\n---\n",
      "Content": "QualifiedNames, NodeIds and ExpandedNodeIds optimize representation of NamespaceUris by using a NamespaceIndex to reference the location of the URI in a NamespaceTable. The NamespaceTable to use is known from the context. For example, when a Client establishes a Session with a Server, the Server supplies the NamespaceTable that is used for all exchanges within that Session. Another example, is when a Publisher publishes DataSetMetadata messages, the NamespaceTable is provided as part of the message.\nHowever, there are other scenarios where there is no obvious context that can be used to store the NamespaceTable, such as column in a database table, so it is necessary to provide a self-contained representation of these DataTypes. This clause defines a normative String representation using the ABNF like notation (see[RFC 5234](/\u00A7RFC5234)).[Table 4](/\u00A7_Ref122646535) defines additional core rules used in these definitions.\nTable 4- Additional Core Rules\nUNICODE\nAny Unicode character other than a Control character.\nCONTROL\nAny Unicode Control character (includes nulls, carriage returns, tabs and new lines).\nURI\nA string that conforms to[RFC 3986](/\u00A7RFC3986).\nENCODEDURI\nA URI which has the[RFC 3986](/\u00A7RFC3986) Percent-Encoding applied to it.\nAny \u0027;\u0027 in the URI shall be percent encoded.\nBASE64\nA Base64 encoded binary value (see[Base64](/\u00A7Base64)).\n\nThe description for a NodeId is found in[Table 5](/\u00A7_Ref122646734).\nTable 5- Description for a NodeId\n\u003Cnode-id\u003E\n= \u003Cidentifier\u003E\n\u003Cnode-id\u003E"
    },
    {
      "Id": "712bb5a2-be71-41b3-bd26-30792eda74c9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.12 QualifiedName, NodeId and ExpandedNodeId String Encoding\n---\n",
      "Content": "\u003Cnode-id\u003E\n=/ \u003Cnamespace-index\u003E \u0022;\u0022 \u003Cidentifier\u003E\n\u003Cnode-id\u003E\n=/ \u003Cnamespace-uri\u003E \u0022;\u0022 \u003Cidentifier\u003E\n\u003Cnamespace-index\u003E\n= \u0022ns=\u0022 1*DIGIT\n\u003Cnamespace-uri\u003E\n= \u0022nsu=\u0022 ENCODEDURI\n\u003Cidentifier\u003E\n= \u003Cnumericid\u003E / \u003Cstringid\u003E / \u003Cguidid\u003E / \u003Copaqueid\u003E\n\u003Cnumericid\u003E\n= \u0022i=\u0022 *DIGIT\n\u003Cstringid\u003E\n= \u0022s=\u0022 *(UNICODE)\n\u003Cguidid\u003E\n= \u0022g=\u0022 8HEXDIG 3(\u0022-\u0022 4HEXDIG) \u0022-\u0022 12HEXDIG\n\u003Copaqueid\u003E\n= \u0022b=\u0022 BASE64\n\nNodeIds with a NamespaceIndex of 0 or a NamespaceUri of[http://opcfoundation.org/UA/](http://opcfoundation.org/UA/) shall only use the \u003Cidentifier\u003E form.\n[OPC 10000-3](/\u00A7UAPart3) prohibits control characters, such as tabs (0x09), in the string identifier for NodeIds.\nThe URI portion of NodeIds are escaped with URI percent encoding as defined in[RFC 3986](/\u00A7RFC3986). Semicolons are added to the list of reserved characters of all URI schemes.\nExamples of NodeIds:\ni=13\nns=10;i=12345\nnsu=http://widgets.com/schemas/hello;s=\u6C34 World\ng=09087e75-8e5e-499b-954f-f2a9603db28a"
    },
    {
      "Id": "f87eec96-f545-4b20-8c26-201d783c12a3",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.12 QualifiedName, NodeId and ExpandedNodeId String Encoding\n---\n",
      "Content": "nsu=tag:acme.com,2023:schemas:data#off%3B;b=M/RbKBsRVkePCePcx24oRA==\n\nThe description for a ExpandedNodeId is found in[Table 6](/\u00A7_Ref122649055).\nTable 6- Description for a ExpandedNodeId\n\u003Cexpanded-node-id\u003E\n= \u003Cnode-id\u003E\n\u003Cexpanded-node-id\u003E\n=/ \u003Cserver-index\u003E \u0022;\u0022 \u003Cnode-id\u003E\n\u003Cexpanded-node-id\u003E\n=/ \u003Cserver-uri\u003E \u0022;\u0022 \u003Cnode-id\u003E\n\u003Cserver-index\u003E\n= \u0022svr=\u0022 *DIGIT\n\u003Cserver-uri\u003E\n= \u0022svu=\u0022 ENCODEDURI\n\nExpandedNodeIds that are not specific to a Server shall use the \u003Cnode-id\u003E form.\n[OPC 10000-3](/\u00A7UAPart3) prohibits control characters, such as tabs (0x09), in the string identifier for ExpandedNodeIds.\nThe URI portions of ExpandedNodeIds are escaped with URI percent encoding as defined in[RFC 3986](/\u00A7RFC3986). Semicolons are added to the list of reserved characters of all URI schemes. Examples of ExpandedNodeIds:\ni=13\nsvr=1;nsu=http://widgets.com/schemas/hello;s=\u6C34 World\nsvu=http://smith.com/east/factory;g=09087e75-8e5e-499b-954f-f2a9603db28a\nsvu=http://smith.com/west/factory;nsu=tag:acme.com,2023:schemas:data#off%3B;b=M/RbKBsRVkePCePcx24oRA=="
    },
    {
      "Id": "5815fc30-fb5d-4385-ac6f-1fc793e4a45a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.12 QualifiedName, NodeId and ExpandedNodeId String Encoding\n---\n",
      "Content": "The description for a QualifiedName is found in[Table 7](/\u00A7_Ref122649467).\nTable 7- Description for a QualifiedName\n\u003Cqualified-name\u003E\n= \u003Cname\u003E\n\u003Cqualified-name\u003E\n=/ 1*DIGIT \u0022:\u0022 \u003Cname\u003E\n\u003Cqualified-name\u003E\n=/ \u003Cnamespace-uri\u003E \u0022;\u0022 \u003Cname\u003E\n\u003Cname\u003E\n= 1*(UNICODE)\n\nQualifiedNames in the OPC UA Namespace shall not use the form with a \u003Cnamespace-uri\u003E.\nThe form without a prefix (the first row in[Table 7](/\u00A7_Ref122649467)) shall only be used for QualifiedNames in the OPC UA Namespace. This is unambiguous because the Name portion of a QualifiedName in the OPC UA Namespace starting with a sequence of digits followed by a colon is prohibited.\n[OPC 10000-3](/\u00A7UAPart3) prohibits control characters, such as tabs (0x09), in the name portion of a QualifiedName.\nThe URI portions of QualifiedNames are escaped with URI percent encoding as defined in[RFC 3986](/\u00A7RFC3986). Semicolons are added to the list of reserved characters of all URI schemes. Examples of QualifiedNames:\nInputArguments\n3:Hello:World\nnsu=http://widgets.com/schemas/hello;Hello;World\nnsu=tag:acme.com,2023:schemas:data#off%3B;Boiler2"
    },
    {
      "Id": "d1a17641-aa06-4c04-9900-6a4821b21f6d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.13 Name Encoding Rules"
    },
    {
      "Id": "4ecf59c9-e929-4c80-9ffa-6d70e11bb50a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.13 Name Encoding Rules\n---\n",
      "Content": "Text based DataEncodings such as UA XML ([5.3](/\u00A7_Ref131702289)) or UA JSON ([5.4](/\u00A7_Ref443435038)) make use of Names from the DataType and DataTypeDefinition to create the serialized data. XML and JSON formats impose restrictions on the Strings that may be used in serialized data so it is necessary to define a transformation that ensures any Names can be used in the DataEncoding. The following rules are used to convert a DataType Name or a Structure Field Name to a string supported by the Encoding:\nAny character that is not permitted by the DataEncoding is replaced by an underscore (U\u002B005F);\nA name with text sequence that is not valid in the first position has an underscore (U\u002B005F) added as a prefix.\nThe character restrictions for the XML DataEncoding are:\n\u003Callowed-name\u003E\n= \u003Cletter\u003E *(\u003Callowed-char\u003E / \u0022_\u0022 / \u0022-\u0022/ \u0022.\u0022)\n\u003Callowed-char\u003E\n= \u003Cletter\u003E / DIGIT\n\u003Cletter\u003E\n= UNICODE-LETTER\nUNICODE-LETTER\nAny Unicode character with a general category of \u0027Letter\u0027\nIn addition, XML names cannot start with the text \u0027xml\u0027 or any variation in case (i.e. \u0027xMl\u0027).\nThere are no restrictions for the JSON encoding other than the general restrictions defined in[OPC 10000-3](/\u00A7UAPart3).\n[Table 8](/\u00A7_Ref130464699) has examples of XML encoded names.\nTable 8- Examples of XML Encoded Names\nHello\nHello\n_Hello\n_Hello\n3DHello\n_3DHello\n\u51B7\u6C34\n\u51B7\u6C34\n3 (\u51B7\u6C34\u3002)-Hello"
    },
    {
      "Id": "067d920c-69da-4722-8d2a-6180df526dbe",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.13 Name Encoding Rules\n---\n",
      "Content": "_3__\u51B7\u6C34__-Hello\n\nNote the last example includes a Japanese period that is not permitted by XML rules. The glyph for the Japanese period has trailing white space embedded in it. All characters not allowed by XML rules are replaced with underscores."
    },
    {
      "Id": "400c494f-4ec2-4e19-9ab6-529a99854f75",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1 General\n---\n",
      "Content": "5.1.14 Structure FieldPath Encoding Rules"
    },
    {
      "Id": "f4957bf4-0c08-4ff3-bbd0-a930b1de59d5",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.14 Structure FieldPath Encoding Rules\n---\n",
      "Content": "Values of Structure DataTypes are sequences of name-value pairs. In many cases the value will be an array or another Structure. There are situations where it is necessary to refer to an element within a Structure. The Structure FieldPath defines a path to a single value within a Structure.\nThe description for a Structure FieldPath is found in[Table 9](/\u00A7_Ref157112060).\nTable 9- Description for a Structure FieldPath\n\u003Cpath\u003E\n= \u003Cpath-element\u003E *(\u0022.\u0022 \u003Cpath-element\u003E)\n\u003Cpath-element\u003E\n= \u003Cname\u003E / \u003Cindex\u003E\n\u003Cname\u003E\n= 1*\u003Cchar\u003E / \u0022\u0027\u0022 1*\u003Cchar\u003E \u0022\u0027\u0022\n\u003Cindex\u003E\n= \u0022[\u0022 1*DIGIT *(\u0022,\u0022 1*DIGIT) \u0022]\u0022\n\u003Cchar\u003E\n= UNICODE-NO-CONTROL-OR-ESCAPED / \u003Cescaped\u003E\n\u003Cescaped\u003E\n= \u0022..\u0022 / \u0022[[\u0022\n\nThe UNICODE-NO-CONTROL-OR-ESCAPED is a core rule that includes all UNICODE characters except for U\u002B0027 (\u0027) and any character with a category of Cc (control codes).\nAny apostrophe (U\u002B0027 (\u0027)) in a \u003Cname\u003E is escaped by adding an extra copy of the same character and the name shall be enclosed with apostrophes.\nAny \u003Cname\u003E may be enclosed with apostrophes. Any \u003Cname\u003E that contains U\u002B0027 (\u0027), U\u002B005B ([), U\u002B005B (]), or U\u002B002E (.) shall be enclosed with apostrophes.\nThe \u003Cname\u003E comes from the Name of a field in the DataTypeDefinition for the Structure."
    },
    {
      "Id": "d6dc99f9-b021-495d-8341-fba80f17e09f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.14 Structure FieldPath Encoding Rules\n---\n",
      "Content": "for the Structure.\nThe \u003Cindex\u003E is an index in field containing an array value. If an array has multiple dimensions, then the \u003Cindex\u003E has multiple elements separated by U\u002B002C (,).\nThe DataTypeDefinition for a simple Structure is found in[Table 10](/\u00A7_Ref162238229).\nTable 10- DataTypeDefinition for a simple Structure\nField Name\nDataType\nDescription\nRed\nBoolean\nSimple Boolean value.\nYellow.One\nInt32\nInt32 value with a special character in the name.\nGreen\u0027s\nString []\nArray of string values.\n\nThe value for the simple Structure using JSON:\n{\n\u0022Red\u0022: true,\n\u0022Yellow.One\u0022: 42,\n\u0022Green\u0027s\u0022: [ \u0022macintosh\u0022, \u0022fuji\u0022, \u0022ambrosia\u0022 ]\n}\n\nExamples of FieldPaths and their values based on the simple Structure value are in[Table 11](/\u00A7_Ref162238648).\nTable 11- Examples of FieldPaths for a Simple Structure\nFieldPath\nResolved Value\n\u0027Yellow.One\u0027\n42\n\u0027Green\u0027\u0027s\u0027\n[\u0022macintosh\u0022, \u0022fuji\u0022, \u0022ambrosia\u0022]\n\u0027Green\u0027\u0027s\u0027.[1]\n\u0022fuji\u0022\nPink\nCannot be resolved because name not found.\n\u0027Green\u0027\u0027s\u0027.[6]\nCannot be resolved because of index too large.\n\u0027Green\u0027\u0027s\u0027.[TEXT]\nCannot be resolved because of non-numeric index.\n\nThe DataTypeDefinition for a complex Structure is found in[Table 12](/\u00A7_Ref162239346).\nTable 12- DataTypeDefinition for a Complex Structure\nField Name\nDataType\nDescription\nApple\nSimpleStructure []\nAn array of the Structure defined in"
    },
    {
      "Id": "ec45c8c7-4a16-4141-9f50-58bebe71ca8a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.14 Structure FieldPath Encoding Rules\n---\n",
      "Content": "[Table 10](/\u00A7_Ref162238229).\n[Banana]\nStructure\nAny Structure value.\nGrape\nBaseDataType\nAny value.\n\nThe value for the complex Structure using JSON:\n{\n\u0022Apple\u0022: [\n{\n\u0022Red\u0022: true,\n\u0022Yellow.One\u0022: 42,\n\u0022Green\u0027s\u0022: [ \u0022macintosh\u0022, \u0022fuji\u0022, \u0022ambrosia\u0022 ]\n}\n],\n\u0022[Banana]\u0022: {\n\u0022TypeId\u0022: \u0022\u003Ctype-id\u003E\u0022,\n\u0022Body\u0022: {\n\u0022X\u0022: 987,\n\u0022Y\u0022: 432\n},\n\u0022Grape\u0022: {\n\u0022Type\u0022: 6\n\u0022Body\u0022: [ 123, 345, 678 ]\n},\n}\n\nExamples of FieldPaths and their values based on the complex Structure value are in[Table 13](/\u00A7_Ref162239373).\nTable 13- Examples of FieldPaths in a Complex Structure\nFieldPath\nResolved Value\nApple.[0]\n{\n\u0022Red\u0022: true,\n\u0022Yellow.One\u0022: 42,\n\u0022Green\u0022: [ \u0022macintosh\u0022, \u0022fuji\u0022, \u0022ambrosia\u0022 ]\n}\nApple.[0].\u0027Yellow.One\u0027\n42\nApple.[0].\u0027Green\u0027\u0027s\u0027\n[\u0022macintosh\u0022, \u0022fuji\u0022, \u0022ambrosia\u0022]\nApple.[0].\u0027Green\u0027\u0027s\u0027.[1]\n\u0022fuji\u0022\n\u0027[Banana]\u0027\n{\n\u0022TypeId\u0022: \u0022\u003Ctype-id\u003E\u0022,\n\u0022Body\u0022: {\n\u0022X\u0022: 987,\n\u0022Y\u0022: 432\n}\n}\n\u0027[Banana]\u0027.Body\n{ \u0022X\u0022: 987, \u0022Y\u0022: 432 }\n\u0027[Banana]\u0027.Body.Y\n432\nGrape\n{"
    },
    {
      "Id": "10721ae9-eb39-477d-b8cd-524897c504dc",
      "Header": "Document: Part 6 - Mappings\nSection: 5.1.14 Structure FieldPath Encoding Rules\n---\n",
      "Content": "Grape\n{\n\u0022Type\u0022: 6\n\u0022Body\u0022: [ 123, 345, 678 ]\n}\nGrape.Body.[1]\n345"
    },
    {
      "Id": "185bb871-ac7d-407e-8244-3eab02019d6a",
      "Header": "Document: Part 6 - Mappings\nSection: 5 Data encoding\n---\n",
      "Content": "5.2 OPC UA Binary"
    },
    {
      "Id": "660af61d-dd7e-40e1-9cd4-e3952e96c2bb",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.1 General"
    },
    {
      "Id": "3e603f54-dc19-4db7-b353-3216a7fe8e72",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.1 General\n---\n",
      "Content": "The OPC UA Binary DataEncoding is a data format developed to meet the performance needs of OPC UA applications. This format is designed primarily for fast encoding and decoding, however, the size of the encoded data on the wire was also a consideration.\nThe OPC UA Binary DataEncoding relies on several primitive data types with clearly defined encoding rules that can be sequentially written to or read from a binary stream. A structure is encoded by sequentially writing the encoded form of each field. If a given field is also a structure, then the values of its fields are written sequentially before writing the next field in the containing structure. All fields shall be written to the stream even if they contain null values. The encodings for each primitive type specify how to encode either a null or a DefaultValue for the type.\nThe OPC UA Binary DataEncoding does not include any type or field name information because all OPC UA applications are expected to have advance knowledge of the services and structures that they support. An exception is an ExtensionObject which provides an identifier and a size for the Structured DataType structure it represents. This allows a decoder to skip over types that it does not recognize."
    },
    {
      "Id": "0d24c26f-7c70-40b1-a2d6-99d1ad860e41",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.2 Built-in Types"
    },
    {
      "Id": "70ef47f9-a12d-45b7-ae71-b3c3c7b11b58",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.1 Boolean"
    },
    {
      "Id": "d9708035-f061-46ef-9cb9-b003733f8f76",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.1 Boolean\n---\n",
      "Content": "A Boolean value shall be encoded as a single byte where a value of 0 (zero) is false and any non-zero value is true.\nEncoders shall use the value of 1 to indicate a true value; however, decoders shall treat any non-zero value as true."
    },
    {
      "Id": "a995e6cd-3fa9-42d7-acfb-51fab03f3baa",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.2 Integer"
    },
    {
      "Id": "fe7df395-c0ce-41dc-ae8a-7319c84dce4a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.2 Integer\n---\n",
      "Content": "All integer types shall be encoded as little-endian values where the least significant byte appears first in the stream.\n[Figure 2](/\u00A7_Ref105731366) illustrates how value 1 000 000 000 (Hex: 3B9ACA00) is encoded as a 32-bit integer in the stream."
    },
    {
      "Id": "d655f5d4-d5c7-49b3-b626-771c8ee03c9e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.2 Integer\nCaption: Figure 2 - Encoding Integers in a binary stream\n---\n",
      "Content": "[image005.png](images/image005.png)"
    },
    {
      "Id": "85862ead-e994-4dbd-89dc-40bcd4a3ab53",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.2 Integer\n---\n",
      "Content": "Figure 2 - Encoding Integers in a binary stream"
    },
    {
      "Id": "5bcf4cf4-6c8f-4a4e-9a05-f31215ab4bd2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.3 Floating Point"
    },
    {
      "Id": "35f88a77-d210-43e6-a153-14c572c42b50",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.3 Floating Point\n---\n",
      "Content": "All floating-point values shall be encoded with the appropriate[IEEE 754](/\u00A7IEEE754) binary representation which has three basic components: the sign, the exponent, and the fraction. The bit ranges assigned to each component depend on the width of the type.[Table 14](/\u00A7_Ref105731537) lists the bit ranges for the supported floating-point types.\nTable 14- Supported Floating Point Types\nName\nWidth (bits)\nFraction\nExponent\nSign\nFloat\n32\n0-22\n23-30\n31\nDouble\n64\n0-51\n52-62\n63\nIn addition, the order of bytes in the stream is significant. All floating-point values shall be encoded with the least significant byte appearing first (i.e., little endian).\n[Figure 3](/\u00A7_Ref105731403) illustrates how the value \u22126.5 (Hex: C0D00000) is encoded as a Float.\nThe floating-point type supports positive and negative infinity and not-a-number (NaN). The IEEE specification allows for multiple NaN variants; however, the encoders/decoders may not preserve the distinction. Encoders shall encode a NaN value as an IEEE quiet-NAN (Hex: 000000000000F8FF) or (Hex: 0000C0FF). Any unsupported types such as denormalized numbers shall also be encoded as an IEEE quiet-NAN. Any test for equality between NaN values always fails."
    },
    {
      "Id": "5cab93ed-6614-4d16-8f7f-22b6e8a24f14",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.3 Floating Point\nCaption: Figure 3 - Encoding Floating Points in a binary stream\n---\n",
      "Content": "[image006.png](images/image006.png)"
    },
    {
      "Id": "4ae0a1a5-1821-4457-932e-deeafd49dc1b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.3 Floating Point\n---\n",
      "Content": "Figure 3 - Encoding Floating Points in a binary stream"
    },
    {
      "Id": "4d085077-db75-41d6-9dfa-427d2c8d29e4",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.4 String"
    },
    {
      "Id": "fe61075e-ec31-4f63-8993-1f85bb04002f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.4 String\n---\n",
      "Content": "All String values are encoded as a sequence of[UTF-8](/\u00A7UTF8) characters preceded by the length in bytes.\nThe length in bytes is encoded as Int32. A value of \u22121 is used to indicate a \u0027null\u0027 string.\nStrings with embedded nulls (\u0027\\0\u0027) can lead to unpredictable application behaviour because embedded nulls have special meaning to some DevelopmentPlatforms. For this reason, embedded nulls are not recommended and ByteString should be used instead. That said, Encoders may encode Strings with embedded nulls. Decoders shall use the length to read all bytes in String.\n[Figure 4](/\u00A7_Ref105731569) illustrates how the multilingual string \u0027\u6C34Boy\u0027 is encoded in a byte stream."
    },
    {
      "Id": "4ac5db74-256b-447d-a4d7-644030b56a19",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.4 String\nCaption: Figure 4 - Encoding Strings in a binary stream\n---\n",
      "Content": "[image007.png](images/image007.png)"
    },
    {
      "Id": "44b2d450-4329-451c-8db8-614077988811",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.4 String\n---\n",
      "Content": "Figure 4 - Encoding Strings in a binary stream"
    },
    {
      "Id": "8c6d9e29-69bc-46e5-a335-38b226629119",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.5 DateTime"
    },
    {
      "Id": "3f01888b-2143-4634-b8df-e3c00461b7ee",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.5 DateTime\n---\n",
      "Content": "A DateTime value shall be encoded as a 64-bit signed integer (see[5.2.2.2](/\u00A7_Ref90086478)) which represents the number of 100 nanosecond intervals since January 1, 1601 (UTC).\nNot all DevelopmentPlatforms will be able to represent the full range of dates and times that can be represented with this DataEncoding. For example, the UNIX time_t structure only has a 1 second resolution and cannot represent dates prior to 1970. For this reason, a number of rules shall be applied when dealing with date/time values that exceed the dynamic range of a DevelopmentPlatform. These rules are:\nA date/time value is encoded as 0 if either:\nThe value is equal to or earlier than 1601-01-01 12:00AM UTC.\nThe value is the earliest date that can be represented with the DevelopmentPlatform\u0027s encoding.\nA date/time is encoded as the maximum value for an Int64 if either:\nThe value is equal to or greater than 9999-12-31 11:59:59PM UTC,\nThe value is the latest date that can be represented with the DevelopmentPlatform\u0027s encoding.\nA date/time is decoded as the earliest time that can be represented on the platform if either:\nThe encoded value is 0,\nThe encoded value represents a time earlier than the earliest time that can be represented with the DevelopmentPlatform\u0027s encoding.\nA date/time is decoded as the latest time that can be represented on the platform if either:\nThe encoded value is the maximum value for an Int64,\nThe encoded value represents a time later than the latest time that can be represented with the DevelopmentPlatform\u0027s encoding."
    },
    {
      "Id": "4fdcfeca-2dfd-4951-a5ca-238e5fce7773",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.5 DateTime\n---\n",
      "Content": "\u0027s encoding.\nThese rules imply that the earliest and latest times that can be represented on a given platform are invalid date/time values and should be treated that way by applications.\nA decoder shall truncate the value if a decoder encounters a DateTime value with a resolution that is greater than the resolution supported on the DevelopmentPlatform."
    },
    {
      "Id": "4ad945d3-50a3-4cac-9cd4-6cfd5053f346",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.6 Guid"
    },
    {
      "Id": "209cdce1-ee81-4bc8-8bb6-5dd78369d510",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.6 Guid\n---\n",
      "Content": "A Guid is encoded in a structure as shown in[Table 2](/\u00A7_Ref179432783). Fields are encoded sequentially according to the data type for field.\n[Figure 5](/\u00A7_Ref179441379) illustrates how the Guid\u002272962B91-FA75-4AE6-8D28-B404DC7DAF63\u0022 is encoded in a byte stream."
    },
    {
      "Id": "a6b54ff0-6a00-499c-9545-72d6ec126e81",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.6 Guid\nCaption: Figure 5 - Encoding Guids in a binary stream\n---\n",
      "Content": "[image008.png](images/image008.png)"
    },
    {
      "Id": "bbdebb99-2cfd-4d69-b162-69974b91f4f0",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.6 Guid\n---\n",
      "Content": "Figure 5 - Encoding Guids in a binary stream"
    },
    {
      "Id": "bc4b8050-0355-49a0-af03-e6cd54b232c2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.7 ByteString"
    },
    {
      "Id": "f4f31152-b5e5-4f04-9c54-b96a40c2c49d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.7 ByteString\n---\n",
      "Content": "A ByteString is encoded as sequence of bytes preceded by its length in bytes. The length is encoded as a 32-bit signed integer as described above.\nIf the length of the byte string is \u22121 then the byte string is \u0027null\u0027."
    },
    {
      "Id": "1c3bdbec-7a6a-4096-bb76-856a4d9516c3",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.8 XmlElement (Deprecated)"
    },
    {
      "Id": "283a514f-3d51-48ca-8130-5e06f55fcb36",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.8 XmlElement (Deprecated)\n---\n",
      "Content": "An XmlElement is an XML element serialized as[UTF-8](/\u00A7UTF8) string and then encoded as ByteString.\n[Figure 6](/\u00A7_Ref179441758) illustrates how the XmlElement\u0022\u003CA\u003EHot\u6C34\u003C/A\u003E\u0022 is encoded in a byte stream."
    },
    {
      "Id": "cef18827-22db-4b0d-8436-d5d54356376f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.8 XmlElement (Deprecated)\nCaption: Figure 6 - Encoding XmlElement in a binary stream\n---\n",
      "Content": ".[image009.png](images/image009.png)"
    },
    {
      "Id": "17858267-9cca-4c90-9680-8379478e63b2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.8 XmlElement (Deprecated)\n---\n",
      "Content": "Figure 6 - Encoding XmlElement in a binary stream\nA decoder may choose to parse the XML after decoding; if an unrecoverable parsing error occurs then the decoder should try to continue processing the stream. For example, if the XmlElement is the body of a Variant or an element in an array which is the body of a Variant then this error can be reported by setting value of the Variant to the StatusCode Bad_DecodingError."
    },
    {
      "Id": "11541c05-c611-4157-a38c-df8b1109ce03",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.9 NodeId"
    },
    {
      "Id": "92da3e29-79d7-4f74-99cf-6f9bc98dc5d8",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\n---\n",
      "Content": "The components of a NodeId are described the[Table 15](/\u00A7_Ref105731646).\nTable 15- NodeId components\nName\nData Type\nDescription\nNamespace\nUInt16\nThe index for a namespace URI.\nAn index of 0 is used for OPC UA defined NodeIds.\nIdentifierType\nEnumeration\nThe format and data type of the identifier.\nThe value may be one of the following:\nNUMERIC- the value is an UInteger;\nSTRING- the value is String;\nGUID- the value is a Guid;\nOPAQUE- the value is a ByteString;\nValue\nUInt32 or String or Guid or ByteString\nThe identifier for a node in the address space of an OPC UA Server.\n\nThe DataEncoding of a NodeId varies according to the contents of the instance. For that reason, the first byte of the encoded form indicates the format of the rest of the encoded NodeId. The possible DataEncoding formats are shown in[Table 16](/\u00A7_Ref105731689).[Table 16](/\u00A7_Ref105731689) through[Table 19](/\u00A7_Ref131423295) describe the structure of each possible format (they exclude the byte which indicates the format).\nTable 16- NodeId DataEncoding values\nName\nValue\nDescription\nTwo Byte\n0x00\nA numeric value that fits into the two-byte representation.\nFour Byte\n0x01\nA numeric value that fits into the four-byte representation.\nNumeric\n0x02\nA numeric value that does not fit into the two or four byte representations.\nString\n0x03\nA String value.\nGuid\n0x04\nA Guid value.\nByteString\n0x05\nAn opaque (ByteString) value."
    },
    {
      "Id": "50c698f3-7387-4377-b892-4af35739c173",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\n---\n",
      "Content": "NamespaceUri Flag\n0x80\nSee discussion of ExpandedNodeId in[5.2.2.10](/\u00A7_Ref135290999).\nServerIndex Flag\n0x40\nSee discussion of ExpandedNodeId in[5.2.2.10](/\u00A7_Ref135290999).\n\nThe standard NodeId DataEncoding has the structure shown in[Table 17](/\u00A7_Ref187488302). The standard DataEncoding is used for all formats that do not have an explicit format defined.\nTable 17- Standard NodeId Binary DataEncoding\nName\nData Type\nDescription\nNamespace\nUInt16\nThe NamespaceIndex.\nIdentifier\n*\nThe identifier which is encoded according to the following rules:\nNUMERIC\nUInt32\nSTRING\nString\nGUID\nGuid\nOPAQUE\nByteString\n\n\nAn example of a String NodeId with Namespace = 1 and Identifier = \u0022Hot\u6C34\u0022 is shown in[Figure 7](/\u00A7_Ref191055924)."
    },
    {
      "Id": "2670875f-5a61-4f25-bb50-45a83d1c1a87",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\nCaption: Figure 7 - A String NodeId\n---\n",
      "Content": "[image010.png](images/image010.png)"
    },
    {
      "Id": "275e928e-8c0b-426c-9dd4-924d08e62c6e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\n---\n",
      "Content": "Figure 7 - A String NodeId\nThe Two Byte NodeId DataEncoding has the structure shown in[Table 18](/\u00A7_Ref131422614).\nTable 18- Two Byte NodeId Binary DataEncoding\nName\nData Type\nDescription\nIdentifier\nByte\nThe Namespace is the default OPC UA namespace (i.e. 0).\nThe Identifier Type is \u0027Numeric\u0027.\nThe Identifier shall be in the range 0 to 255.\n\n\nAn example of a Two Byte NodeId with Identifier = 72 is shown in[Figure 8](/\u00A7_Ref191056174)."
    },
    {
      "Id": "3e866489-421a-49db-9745-3fa6e96d23b8",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\nCaption: Figure 8 - A Two Byte NodeId\n---\n",
      "Content": "[image011.png](images/image011.png)"
    },
    {
      "Id": "84507833-1865-4c13-b249-8d4b6cf9d2f0",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\n---\n",
      "Content": "Figure 8 - A Two Byte NodeId\nThe Four Byte NodeId DataEncoding has the structure shown in[Table 19](/\u00A7_Ref131423295).\nTable 19- Four Byte NodeId Binary DataEncoding\nName\nData Type\nDescription\nNamespace\nByte\nThe Namespace shall be in the range 0 to 255.\nIdentifier\nUInt16\nThe Identifier Type is \u0027Numeric\u0027.\nThe Identifier shall be an integer in the range 0 to 65 535.\n\nAn example of a Four Byte NodeId with Namespace = 5 and Identifier = 1025 is shown in[Figure 9](/\u00A7_Ref191057283)."
    },
    {
      "Id": "4f1a4aef-43f6-4829-984e-d21823328d16",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\nCaption: Figure 9 - A Four Byte NodeId\n---\n",
      "Content": "[image012.png](images/image012.png)"
    },
    {
      "Id": "647794b3-4c09-4d59-a88d-e9554a42beea",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.9 NodeId\n---\n",
      "Content": "Figure 9 - A Four Byte NodeId"
    },
    {
      "Id": "3a2a4ffc-4230-4474-b388-fec92acc88ab",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.10 ExpandedNodeId"
    },
    {
      "Id": "bd0def17-7b80-4904-928f-0ffa5a8d8339",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.10 ExpandedNodeId\n---\n",
      "Content": "An ExpandedNodeId extends the NodeId structure by allowing the NamespaceUri to be explicitly specified instead of using the NamespaceIndex. The NamespaceUri is optional. If it is specified, then the NamespaceIndex inside the NodeId shall be ignored.\nThe ExpandedNodeId is encoded by first encoding a NodeId as described in[5.2.2.9](/\u00A7_Ref131470336) and then encoding NamespaceUri as a String.\nAn instance of an ExpandedNodeId may still use the NamespaceIndex instead of the NamespaceUri. In this case, the NamespaceUri is not encoded in the stream. The presence of the NamespaceUri in the stream is indicated by setting the NamespaceUri flag in the encoding format byte for the NodeId.\nIf the NamespaceUri is present, then the encoder shall encode the NamespaceIndex as 0 in the stream when the NodeId portion is encoded. The unused NamespaceIndex is included in the stream for consistency.\nAn ExpandedNodeId may also have a ServerIndex which is encoded as a UInt32 after the NamespaceUri. The ServerIndex flag in the NodeId encoding byte indicates whether the ServerIndex is present in the stream. The ServerIndex is omitted if it is equal to zero.\nThe ExpandedNodeId encoding has the structure shown in[Table 20](/\u00A7_Ref179490138).\nTable 20- ExpandedNodeId Binary DataEncoding\nName\nData Type\nDescription\nNodeId\nNodeId\nThe NamespaceUri and ServerIndex flags in the NodeId encoding indicate whether those fields are present in the stream.\nNamespaceUri\nString\nNot present if null or Empty.\nServerIndex\nUInt32\nNot present if 0."
    },
    {
      "Id": "4265159e-3934-4208-87ce-f330f74ab9e6",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.11 StatusCode"
    },
    {
      "Id": "7de4943f-f997-42c8-ac99-772fb46e7cda",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.11 StatusCode\n---\n",
      "Content": "A StatusCode is encoded as a UInt32."
    },
    {
      "Id": "e17f0d7d-9cde-46ba-bc03-be29b5c8376d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.12 DiagnosticInfo"
    },
    {
      "Id": "d0898ca7-a580-40ef-9c61-0808d5988d29",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.12 DiagnosticInfo\n---\n",
      "Content": "A DiagnosticInfo structure is described in[OPC 10000-4](/\u00A7UAPart4). It specifies a number of fields that could be missing. For that reason, the encoding uses a bit mask to indicate which fields are actually present in the encoded form.\nAs described in[OPC 10000-4](/\u00A7UAPart4), the SymbolicId, NamespaceUri, LocalizedText and Locale fields are indexes in a string table which is returned in the response header. Only the index of the corresponding string in the string table is encoded. An index of \u22121 indicates that there is no value for the string.\nDiagnosticInfo is recursive and unlimited recursion could result in stack overflow errors even if the message size is less than the maximum allowed. Decoders shall support at least 4 recursion levels and are not expected to support more than 10. Decoders shall report an error if the number of recursion levels exceeds what it supports.\nTable 21- DiagnosticInfo Binary DataEncoding\nName\nData Type\nDescription\nEncoding Mask\nByte\nA bit mask that indicates which fields are present in the stream.\nThe mask has the following bits:\n0x01\nSymbolic Id\n0x02\nNamespace\n0x04\nLocalizedText\n0x08\nLocale\n0x10\nAdditional Info\n0x20\nInnerStatusCode\n0x40\nInnerDiagnosticInfo\n\nSymbolicId\nInt32\nA symbolic name for the status code.\nNamespaceUri\nInt32\nA namespace that qualifies the symbolic id.\nLocale\nInt32\nThe locale used for the localized text.\nLocalizedText\nInt32\nA human readable summary of the status code.\nAdditional Info\nString\nDetailed application specific diagnostic information.\nInner StatusCode\nStatusCode"
    },
    {
      "Id": "5052fce0-f25e-43bc-9866-acd896893736",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.12 DiagnosticInfo\n---\n",
      "Content": "Inner StatusCode\nStatusCode\nA status code provided by an underlying system.\nInner DiagnosticInfo\nDiagnosticInfo\nDiagnostic info associated with the inner status code."
    },
    {
      "Id": "b0d36378-d199-4fe6-9687-69aa9f353ee3",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.13 QualifiedName"
    },
    {
      "Id": "6625f18c-5319-4691-a557-870e2ef8e32b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.13 QualifiedName\n---\n",
      "Content": "A QualifiedName structure is encoded as shown in[Table 22](/\u00A7_Ref166071367).\nThe abstract QualifiedName structure is defined in[OPC 10000-3](/\u00A7UAPart3).\nTable 22- QualifiedName Binary DataEncoding\nName\nData Type\nDescription\nNamespaceIndex\nUInt16\nThe namespace index.\nName\nString\nThe name."
    },
    {
      "Id": "13c6e9c7-4eda-4ed4-91c3-f9a106d6f347",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.14 LocalizedText"
    },
    {
      "Id": "43ee9703-86a4-4160-bf37-35ec257a9875",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.14 LocalizedText\n---\n",
      "Content": "A LocalizedText structure contains two fields that could be missing. For that reason, the encoding uses a bit mask to indicate which fields are actually present in the encoded form.\nThe abstract LocalizedText structure is defined in[OPC 10000-3](/\u00A7UAPart3).\nTable 23- LocalizedText Binary DataEncoding\nName\nData Type\nDescription\nEncodingMask\nByte\nA bit mask that indicates which fields are present in the stream.\nThe mask has the following bits:\n0x01\nLocale\n0x02\nText\n\nLocale\nString\nThe locale.\nOmitted is null or empty.\nText\nString\nThe text in the specified locale.\nOmitted is null or empty."
    },
    {
      "Id": "a10857e5-e21f-4922-bbf2-fbdd33ca21e8",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.15 ExtensionObject"
    },
    {
      "Id": "55d9573b-efb8-4a5f-a5f1-3cb966ab8c58",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.15 ExtensionObject\n---\n",
      "Content": "An ExtensionObject is encoded as sequence of bytes prefixed by the NodeId of its DataTypeEncoding, the DataEncoding used and the number of bytes encoded.\nAn ExtensionObject may be serialized as a ByteString or an XmlElement by the application and then passed to the encoder. In this case, the encoder will be able to write the number of bytes in the object before it encodes the bytes. However, an ExtensionObject may know how to encode/decode itself which means the encoder shall calculate the number of bytes before it encodes the object or it shall be able to seek backwards in the stream and update the length after encoding the body.\nWhen a decoder encounters an ExtensionObject it shall check if it recognizes the DataTypeEncoding identifier. If it does, then it can call the appropriate function to decode the object body. If the decoder does not recognize the type it shall use the Encoding to determine if the body is a ByteString or an XmlElement and then decode the object body or treat it as opaque data and skip over it.\nIf the Encoding is Binary the Body uses the OPC UA Binary DataEncoding. If the Encoding is XML the Body uses the OPC UA XML DataEncoding. Other DataEncodings may not be serialized in an ExtensionObject.\nThe serialized form of an ExtensionObject is shown in[Table 24](/\u00A7_Ref135154704).\nTable 24- Extension Object Binary DataEncoding\nName\nData Type\nDescription\nTypeId\nNodeId\nThe identifier for the DataTypeEncoding node in the Server\u0027s AddressSpace. ExtensionObjects defined by the OPC UA specification have a numeric node identifier assigned to them with a NamespaceIndex of 0. The numeric identifiers are defined in[A.3](/\u00A7_Ref400571295).\nDecoders use this field to determine the syntax of the Body.\nEncoding\nByte"
    },
    {
      "Id": "d94546cf-f45f-48af-9044-aeb711480996",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.15 ExtensionObject\n---\n",
      "Content": "Encoding\nByte\nAn enumeration that indicates how the body is encoded.\nThe parameter may have the following values:\n0x00\nNo body is encoded.\n0x01\nThe body is encoded as a ByteString.\n0x02\nThe body is encoded as an XmlElement.\n\nLength\nInt32\nThe length of the object body.\nThe length shall be specified if the body is encoded.\nBody\nOctetString\nThe object encoded with the DataEncoding indicated by the TypeId.\nThis field contains the raw bytes for ByteString bodies.\nFor XmlElement bodies this field contains the XML encoded as a UTF-8 string without any null terminator.\n\nA decoder may choose to parse an XmlElement body after decoding; if an unrecoverable parsing error occurs then the decoder should try to continue processing the stream. For example, if the ExtensionObject is the body of a Variant or an element in an array that is the body of Variant then this error can be reported by setting the value of the Variant to the StatusCode Bad_DecodingError."
    },
    {
      "Id": "ef5ee6c0-a640-4aef-9721-0521be81aa7a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.16 Variant"
    },
    {
      "Id": "bf7db217-2bb4-4ab8-9d60-900c6eb16ca9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.16 Variant\n---\n",
      "Content": "A Variant is a union of the built-in types.\nThe structure of a Variant is shown in[Table 25](/\u00A7_Ref131482954).\nTable 25- Variant Binary DataEncoding\nName\nData Type\nDescription\nEncodingMask\nByte\nThe type of data encoded in the stream. A value of 0 specifies a NULL and that no other fields are encoded.The mask has the following bits assigned:\n0:5\nBuilt-in Type Id (see[Table 1](/\u00A7_Ref83387521)).\n6\nTrue if the ArrayDimensions field is encoded.\n7\nTrue if an array of values is encoded.\nThe Built-in Type Ids 26 through 31 are not currently assigned but may be used in the future. Decoders shall accept these IDs, assume the Value contains a ByteString or an array of ByteStrings and pass both onto the application. Encoders shall not use these IDs.\nThe ArrayDimensions field shall only be present if the number of dimensions is 2 or greater and all dimensions have a length greater than 0.\nArrayLength\nInt32\nThe number of elements in the array.\nThis field is only present if the array bit is set in the encoding mask.\nMulti-dimensional arrays are encoded as a one-dimensional array and this field specifies the total number of elements. The original array can be reconstructed from the dimensions that are encoded after the value field.\nHigher rank dimensions are serialized first. For example, an array with dimensions [2,2,2] is written in this order:"
    },
    {
      "Id": "bf218e08-06d9-4ac7-86e5-79cb3303b036",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.16 Variant\n---\n",
      "Content": "[0,0,0], [0,0,1], [0,1,0], [0,1,1], [1,0,0], [1,0,1], [1,1,0], [1,1,1]\nIf one or more dimensions has a length \u003C= 0 then the ArrayLength is 0.\nValue\n*\nThe value encoded according to its built-in data type.\nIf the array bit is set in the encoding mask, then each element in the array is encoded sequentially. Since many types have variable length encoding each element shall be decoded in order.\nThe value shall not be a Variant but it could be an array of Variants.\nMany implementation platforms do not distinguish between one dimensional Arrays of Bytes and ByteStrings. For this reason, decoders are allowed to automatically convert an Array of Bytes to a ByteString.\nArrayDimensionsLength\nInt32\nThe number of dimensions.\nThis field is only present if the ArrayDimensions flag is set in the encoding mask.\nArrayDimensions\nInt32[]\nThe length of each dimension encoded as a sequence of Int32 values\nThis field is only present if the ArrayDimensions flag is set in the encoding mask. The lower rank dimensions appear first in the array.\nAll dimensions shall be specified and shall be greater than zero..\nIf ArrayDimensions are inconsistent with the ArrayLength then the decoder shall stop and raise a Bad_DecodingError.\n\nThe types and their identifiers that can be encoded in a Variant are shown in[Table 1](/\u00A7_Ref83387521)."
    },
    {
      "Id": "c86b46da-a7c5-43ac-ae61-45032fa03af2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2 Built-in Types\n---\n",
      "Content": "5.2.2.17 DataValue"
    },
    {
      "Id": "e95fb72b-e667-43aa-a10e-a35c13a5d467",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.17 DataValue\n---\n",
      "Content": "A DataValue is always preceded by a mask that indicates which fields are present in the stream.\nThe fields of a DataValue are described in[Table 26](/\u00A7_Ref105731849).\nTable 26- Data Value Binary DataEncoding\nName\nData Type\nDescription\nEncoding Mask\nByte\nA bit mask that indicates which fields are present in the stream.\nThe mask has the following bits:\n0x01\nFalse if the Value is Null.\n0x02\nFalse if the StatusCode is Good.\n0x04\nFalse if the SourceTimestamp is DateTime. MinValue.\n0x08\nFalse if the ServerTimestamp is DateTime. MinValue.\n0x10\nFalse if the SourcePicoseconds is not present.\n0x20\nFalse if the ServerPicoseconds is not present.\n\nValue\nVariant\nThe value.\nNot present if the Value bit in the EncodingMask is False.\nStatus\nStatusCode\nThe status associated with the value.\nNot present if the StatusCode bit in the EncodingMask is False.\nSourceTimestamp\nDateTime\nThe source timestamp associated with the value.\nNot present if the SourceTimestamp bit in the EncodingMask is False.\nSourcePicoseconds\nUInt16\nThe number of 10 Picosecond intervals for the SourceTimestamp.\nNot present if the SourcePicoseconds bit in the EncodingMask is False.\nIf the source timestamp is missing the Picoseconds are ignored.\nServerTimestamp\nDateTime\nThe Server timestamp associated with the value.\nNot present if the ServerTimestamp bit in the EncodingMask is False.\nServerPicoseconds\nUInt16\nThe number of 10 Picosecond intervals for the ServerTimestamp.\nNot present if the ServerPicoseconds bit in the EncodingMask is False.\nIf the Server"
    },
    {
      "Id": "4c9429f2-d699-4688-8570-d2c39794a337",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.2.17 DataValue\n---\n",
      "Content": "If the Server timestamp is missing the Picoseconds are ignored.\n\nThe Picoseconds fields store the difference between a high-resolution timestamp with a resolution of 10 Picoseconds and the Timestamp field value which only has a 100 ns resolution. The Picoseconds fields shall contain values less than 10 000. The decoder shall treat values greater than or equal to 10 000 as the value \u00279999\u0027."
    },
    {
      "Id": "79a0f9da-7bc7-4ef9-b364-1c22e2f15555",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.3 Decimal"
    },
    {
      "Id": "2272d547-3d86-4ffd-97aa-94fbfd16d7a4",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.3 Decimal\n---\n",
      "Content": "Decimals are encoded as described in[5.1.10](/\u00A7_Ref473899214).\nA Decimal does not have a NULL value."
    },
    {
      "Id": "318f2762-2c8e-4ee1-9959-716cd41c0884",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.4 Enumerations"
    },
    {
      "Id": "8be9116d-bbe7-461d-b929-3f08498cc952",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.4 Enumerations\n---\n",
      "Content": "Enumerations are encoded as Int32 values.\nAn Enumeration does not have a NULL value."
    },
    {
      "Id": "a19acaad-4298-4840-a1cb-5d43ae0be14c",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.5 Arrays"
    },
    {
      "Id": "1c9c977a-c072-411b-aeee-cee0869f7b15",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.5 Arrays\n---\n",
      "Content": "One dimensional Arrays are encoded as a sequence of elements preceded by the number of elements encoded as an Int32 value.\nMulti-dimensional Arrays have an encoding that depends on where they are used. When a multi-dimensional Array is the Value of an Attribute it uses the Variant encoding described in[5.2.2.16](/\u00A7_Ref400568926).\nWhen a multi-dimensional Array is a field of a Structure(see[5.2.6](/\u00A7_Ref80122070)) it shall be encoded with the inline matrix representation as shown in[Table 27](/\u00A7_Ref80123330).\nTable 27- Inline Matrix DataEncoding\nName\nData Type\nDescription\nDimensions\nInt32 []\nThe length of each dimension.\nIf any dimension has a length \u003C= 0, then no values are encoded.\nThe number of dimensions shall be at least 2.\nValues\n*\nThe values encoded sequentially according to its built-in data type.\nThe total number of values is the product of the dimensions.\nThe mapping of a multidimensional array to a flat list is described in[5.2.2.16](/\u00A7_Ref400568926).\n\nThe inline matrix representation is not supported by earlier versions of this specification. This means any Structure with a field or nested field mapped to an inline matrix is not compatible with the deprecated DataTypeDictionary mechanism, and shall not be included in a DataTypeDictionary.\nIf an Array is null, then its length is encoded as \u22121. See[5.1.11](/\u00A7_Ref71756850) for a discussion of zero-length vs null arrays."
    },
    {
      "Id": "7f0d7331-5d30-435c-b433-3f61ce87a3dd",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.6 Structures"
    },
    {
      "Id": "069198e1-c243-4a64-9fee-57425ed7dcc7",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.6 Structures\n---\n",
      "Content": "Structures are encoded as a sequence of fields in the order that they appear in the definition. The encoding for each field is determined by the built-in type for the field.\nAll fields specified in the structure shall be encoded. If optional fields exist in the Structure, then see[5.2.7](/\u00A7_Ref401507564).\nStructures do not have a null value. If an encoder is written in a programming language that allows structures to have null values, then the encoder shall create a new instance with DefaultValues for all fields and serialize that. Encoders shall not generate an encoding error in this situation.\nThe following is an example of a structure using C/C\u002B\u002B syntax:\n\nstruct Type2\n{\nInt32 A;\nInt32 B;\n};\n\nstruct Type1\n{\nInt32 X;\nByte NoOfY;\nType2* Y;\nInt32 Z;\nUInt16 W[10];\nByte M[2,3,4];\n};\n\nIn the C/C\u002B\u002B example above, the Y field is a pointer to an array with a length stored in NoOfY. When encoding an array, the length is part of the array encoding so the NoOfY field is not encoded. That said, encoders and decoders use NoOfY during encoding. W is a fixed length array with an implicitly defined length of 10. This length is always encoded with the array. M is a fixed length multidimensional array. The length of each dimension is always encoded with the array.\nAn instance of Type1 which contains an array of two Type2 instances would be encoded as 28-byte sequence. If the instance of Type1 was encoded in an ExtensionObject it would have an additional prefix shown in[Table 28](/\u00A7_Ref115456711)"
    },
    {
      "Id": "6f49cb11-ed1b-4259-a20a-b64b6ba5cf00",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.6 Structures\n---\n",
      "Content": "which would make the total length 101 bytes The TypeId, Encoding and the Length are fields defined by the ExtensionObject. The encoding of the Type2 instances do not include any type identifier because it is explicitly defined in Type1.\nTable 28- Sample OPC UA Binary Encoded structure\nField\nBytes\nValue\nType Id\n4\nThe identifier for the \u0027Type1\u0027 Binary Encoding Node\nEncoding\n1\n0x1 for ByteString\nLength\n4\n92\nX\n4\nThe value of field \u0027X\u0027\nY.Length\n4\n2\nY.A\n4\nThe value of field \u0027Y[0].A\u0027\nY.B\n4\nThe value of field \u0027Y[0].B\u0027\nY.A\n4\nThe value of field \u0027Y[1].A\u0027\nY.B\n4\nThe value of field \u0027Y[1].B\u0027\nZ\n4\nThe value of field \u0027Z\u0027\nW.Length\n4\n10\nW\n20\nThe value of field \u0027W\u0027.\nM.Dimensions.Length\n4\n3\nM.Dimensions\n12\nThe sequence [2,3,4] encoded as a Int32.\nM.Values\n24\nThe values in \u0027M\u0027 encoded sequentially as described in[5.2.2.16](/\u00A7_Ref400568926).\n\nThe Value of the DataTypeDefinition Attribute for a DataType Node describing Type1 is shown in[Table 29](/\u00A7_Ref94015568).\nTable 29- DataTypeDefinition for \u0022Type1\u0022 from Sample\nName\nType\nDescription\ndefaultEncodingId\nNodeId\nNodeId of the \u0022Type1_Encoding_DefaultBinary\u0022 Node.\nbaseDataType\nNodeId\n\u0022i=22\u0022 [Structure]\nstructureType\nStructureType"
    },
    {
      "Id": "37952b41-8798-481d-852f-16872efd82bd",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.6 Structures\n---\n",
      "Content": "StructureType\nStructure_0 [Structure without optional fields]\nfields [0]\nStructureField\n\nname\nString\n\u0022X\u0022\ndescription\nLocalizedText\nDescription of X\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [1]\nStructureField\n\nname\nString\n\u0022Y\u0022\ndescription\nLocalizedText\nDescription of Y-Array\ndataType\nNodeId\nNodeId of the Type2 DataType Node (e.g. \u0022ns=3; s=MyType2\u0022)\nvalueRank\nInt32\n1 (OneDimension)\narrayDimensions\nUInt32[]\n{ 0 }\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [2]\nStructureField\n\nname\nString\n\u0022Z\u0022\ndescription\nLocalizedText\nDescription of Z\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [3]\nStructureField\n\nname\nString\n\u0022W\u0022\ndescription\nLocalizedText\nDescription of W\ndataType\nNodeId\n\u0022i=5\u0022 [UInt16]\nvalueRank\nInt32\n1 (OneDimension)\narrayDimensions\nUInt32[]\n{ 10 }\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [4]\nStructureField\n\nname\nString\n\u0022M\u0022\ndescription\nLocalizedText\nDescription of M\ndataType\nNodeId\n\u0022i=3\u0022 [Byte]\nvalueRank"
    },
    {
      "Id": "49654183-c0d6-4984-a8ad-cce51fe5d1d0",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.6 Structures\n---\n",
      "Content": "valueRank\nInt32\n3\narrayDimensions\nUInt32[]\n{ 2, 3, 4 }\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\n\nThe Value of the DataTypeDefinition Attribute for a DataType Node describing Type2 is shown in[Table 30](/\u00A7_Ref94016249).\nTable 30- DataTypeDefinition for \u0022Type2\u0022 from Sample\nName\nType\nDescription\ndefaultEncodingId\nNodeId\nNodeId of the \u0022Type2_Encoding_DefaultBinary\u0022 Node.\nbaseDataType\nNodeId\n\u0022i=22\u0022 [Structure]\nstructureType\nStructureType\nStructure_0 [Structure without optional fields]\nfields [0]\nStructureField\n\nname\nString\n\u0022A\u0022\ndescription\nLocalizedText\nDescription of A\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [1]\nStructureField\n\nname\nString\n\u0022B\u0022\u0022\ndescription\nLocalizedText\nDescription of B\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse"
    },
    {
      "Id": "c7cf17b8-75cd-42db-b655-6897d29fea2e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.7 Structures with optional fields"
    },
    {
      "Id": "4902971c-29f8-49af-bcc7-59fc2671b90e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.7 Structures with optional fields\n---\n",
      "Content": "Structures with optional fields are encoded with an encoding mask preceding a sequence of fields in the order that they appear in the definition. The encoding for each field is determined by the data type for the field.\nThe EncodingMask is a 32-bit unsigned integer. Each optional field is assigned exactly one bit. The first optional field is assigned bit \u00270\u0027, the second optional field is assigned bit \u00271\u0027 and so until all optional fields are assigned bits. A maximum of 32 optional fields can appear within a single Structure. Unassigned bits are set to 0 by encoders. Decoders shall report an error if unassigned bits are not 0.\nThe following is an example of a structure with optional fields using C\u002B\u002B syntax:\n\nstruct TypeA\n{\nInt32 X;\nInt32* O1;\nSByte Y;\nInt32* O2;\n};\n\nO1 and O2 are optional fields which are NULL if not present\nAn instance of TypeA which contains two mandatory (X and Y) and two optional (O1 and O2) fields would be encoded as a byte sequence. The length of the byte sequence depends on the available optional fields. An encoding mask field determines the available optional fields.\nAn instance of TypeA where field O2 is available and field O1 is not available would be encoded as a 13-byte sequence. If the instance of TypeA was encoded in an ExtensionObject it would have the encoded form shown in[Table 31](/\u00A7_Ref531786547) and have a total length of 22 bytes. The length of the TypeId, Encoding and the Length are fields defined by the ExtensionObject.\nTable 31- Sample OPC UA Binary Encoded Structure with optional fields\nField\nBytes\nValue\nType Id\n4"
    },
    {
      "Id": "d5c7e3c5-fa2d-4d01-a16a-d09e399866fa",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.7 Structures with optional fields\n---\n",
      "Content": "Type Id\n4\nThe identifier for the TypeA Binary Encoding Node\nEncoding\n1\n0x1 for ByteString\nLength\n4\n13\nEncodingMask\n4\n0x02 for O2\nX\n4\nThe value of X\nY\n1\nThe value of Y\nO2\n4\nThe value of O2\n\nIf a Structure with optional fields is subtyped, the subtypes extend the EncodingMask defined for the parent.\n\nThe Value of the DataTypeDefinition Attribute for a DataType Node describing TypeA is:\nName\nType\nDescription\ndefaultEncodingId\nNodeId\nNodeId of the \u0022TypeA_Encoding_DefaultBinary\u0022 Node.\nbaseDataType\nNodeId\n\u0022i=22\u0022 [Structure]\nstructureType\nStructureType\nStructureWithOptionalFields_1 [Structure without optional fields]\nfields [0]\nStructureField\n\nname\nString\n\u0022X\u0022\ndescription\nLocalizedText\nDescription of X\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [1]\nStructureField\n\nname\nString\n\u0022O1\u0022\ndescription\nLocalizedText\nDescription of O1\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\ntrue\nfields [2]\nStructureField\n\nname\nString\n\u0022Y\u0022\ndescription\nLocalizedText\nDescription of Z\ndataType\nNodeId\n\u0022i=2\u0022 [SByte]\nvalueRank\nInt32"
    },
    {
      "Id": "f6c0319f-39a4-45a5-b62a-07e352a92208",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.7 Structures with optional fields\n---\n",
      "Content": "Int32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [3]\nStructureField\n\nname\nString\n\u0022O2\u0022\ndescription\nLocalizedText\nDescription of O2\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\ntrue"
    },
    {
      "Id": "2a0fab2e-11e0-42e6-852c-15ceb81d8921",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.8 Unions"
    },
    {
      "Id": "b0ecc942-0a42-41d8-8d61-9bd8eea04189",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.8 Unions\n---\n",
      "Content": "Unions are encoded as a switch field preceding one of the possible fields. The encoding for the selected field is determined by the data type for the field.\nThe switch field is encoded as a UInt32.\nThe switch field is the index of the available union fields starting with 1. If the switch field is 0 then no field is present. For any value greater than the number of defined union fields the encoders or decoders shall report an error.\nA Union with no fields present has the same meaning as a NULL value. A Union with any field present is not a NULL value even if the value of the field itself is NULL.\nThe following is an example of a union using C/C\u002B\u002B syntax:\nstruct Type2\n{\nInt32 A;\nInt32 B;\n};\n\nstruct Type1\n{\nByte Selector;\n\nunion\n{\nInt32 Field1;\nType2 Field2;\n}\nValue;\n};\n\nIn the C/C\u002B\u002B example above, the Selector, Field1 and Field2 are semantically coupled to form a union.\nAn instance of Type1 would be encoded as byte sequence. The length of the byte sequence depends on the selected field.\nAn instance of Type1 where field Field1 is available would be encoded as 8-byte sequence. If the instance of Type 1 was encoded in an ExtensionObject it would have the encoded form shown in[Table 32](/\u00A7_Ref531786635) and it would have a total length of 17 bytes. The TypeId, Encoding and the Length are fields defined by the ExtensionObject.\nTable 32- Sample OPC UA Binary Encoded Structure\nField\nBytes\nValue\nType Id\n4\nThe identifier for Type1\nEncoding\n1\n0x1 for ByteString\nLength\n4\n8"
    },
    {
      "Id": "eac87db0-765a-40e0-8470-7a2242866b9a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.8 Unions\n---\n",
      "Content": "4\n8\nSwitchValue\n4\n1 for Field1\nField1\n4\nThe value of Field1\n\nThe Value of the DataTypeDefinition Attribute for a DataType Node describing Type1 is:\nName\nType\nDescription\ndefaultEncodingId\nNodeId\nNodeId of the \u0022Type1_Encoding_DefaultBinary\u0022 Node.\nbaseDataType\nNodeId\n\u0022i=22\u0022 [Union]\nstructureType\nStructureType\nUnion_2 [Union]\nfields [0]\nStructureField\n\nname\nString\n\u0022Field1\u0022\ndescription\nLocalizedText\nDescription of Field1\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\ntrue\nfields [1]\nStructureField\n\nname\nString\n\u0022Field2\u0022\ndescription\nLocalizedText\nDescription of Field2\ndataType\nNodeId\nNodeId of the Type2 DataType Node (e.g. \u0022ns=3; s=MyType2\u0022)\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\ntrue\n\nThe Value of the DataTypeDefinition Attribute for a DataType Node describing Type2 is:\nName\nType\nDescription\ndefaultEncodingId\nNodeId\nNodeId of the \u0022Type2_Encoding_DefaultBinary\u0022 Node.\nbaseDataType\nNodeId\n\u0022i=22\u0022 [Structure]\nstructureType\nStructureType\nStructure_0 [Structure without optional fields]\nfields [0]\nStructureField\n\nname\nString\n\u0022A\u0022\ndescription\nLocalizedText\nDescription of A\ndataType\nNodeId"
    },
    {
      "Id": "7660e974-2e88-4cbe-ba2a-bd6ff6aed628",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.8 Unions\n---\n",
      "Content": "dataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse\nfields [1]\nStructureField\n\nname\nString\n\u0022B\u0022\ndescription\nLocalizedText\nDescription of B\ndataType\nNodeId\n\u0022i=6\u0022 [Int32]\nvalueRank\nInt32\n-1 (Scalar)\narrayDimensions\nUInt32[]\nnull\nmaxStringLength\nUInt32\n0\nisOptional\nBoolean\nfalse"
    },
    {
      "Id": "676ef584-fd89-4e6d-8af9-43b771e33db2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2 OPC UA Binary\n---\n",
      "Content": "5.2.9 Messages"
    },
    {
      "Id": "245e2da2-a0f7-4278-ad24-a3437446985b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.2.9 Messages\n---\n",
      "Content": "Messages are Structures encoded as sequence of bytes prefixed by the NodeId of for the OPC UA Binary DataTypeEncoding defined for the Message.\nEach OPC UA Service described in[OPC 10000-4](/\u00A7UAPart4) has a request and response Message. The DataTypeEncoding IDs assigned to each Service are specified in Clause[A.3](/\u00A7_Ref294144163)."
    },
    {
      "Id": "fc5bc3bb-239a-4926-896b-fabbe00a3b1a",
      "Header": "Document: Part 6 - Mappings\nSection: 5 Data encoding\n---\n",
      "Content": "5.3 OPC UA XML"
    },
    {
      "Id": "f0300ec5-36e8-4dd5-8881-593acb482b0b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.1 Built-in Types"
    },
    {
      "Id": "aa728e62-6545-48f0-8b75-a3a9e4d9c013",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.1 General"
    },
    {
      "Id": "6f1d45aa-090e-488f-aa07-30e742d9815e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.1 General\n---\n",
      "Content": "Most built-in types are encoded in XML using the formats defined in[XML Schema Part 2](/\u00A7XmlSchema2) specification. Any special restrictions or usages are discussed below. Some of the built-in types have an XML Schema defined for them using the syntax defined in[XML Schema Part 2](/\u00A7XmlSchema2).\nThe prefix xs: is used to denote a symbol defined by the XML Schema specification."
    },
    {
      "Id": "cf5d7498-1c77-4037-8679-5b6b0e6479e2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.2 Boolean"
    },
    {
      "Id": "818f5e42-307f-4493-b570-f18e825c05d1",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.2 Boolean\n---\n",
      "Content": "A Boolean value is encoded as an xs:boolean value."
    },
    {
      "Id": "2ed9f01e-2ef9-48b0-876f-99a8162c93ec",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.3 Integer"
    },
    {
      "Id": "2e00917f-a8d9-4c8f-aaad-e8583d50f8cf",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.3 Integer\n---\n",
      "Content": "Integer values are encoded using one of the subtypes of the xs:decimal type. The mappings between the OPC UA integer types and XML schema data types are shown in[Table 33](/\u00A7_Ref131518889).\nTable 33- XML Data Type Mappings for Integers\nName\nXML Type\nSByte\nxs:byte\nByte\nxs:unsignedByte\nInt16\nxs:short\nUInt16\nxs:unsignedShort\nInt32\nxs:int\nUInt32\nxs:unsignedInt\nInt64\nxs:long\nUInt64\nxs:unsignedLong"
    },
    {
      "Id": "92733050-3edc-4c4e-b2d8-7b486084d86e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.4 Floating Point"
    },
    {
      "Id": "55482eb9-d8c1-41fc-aa9c-cadd74dbae76",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.4 Floating Point\n---\n",
      "Content": "Floating point values are encoded using one of the XML floating point types. The mappings between the OPC UA floating point types and XML schema data types are shown in[Table 34](/\u00A7_Ref131519179).\nTable 34- XML Data Type Mappings for Floating Points\nName\nXML Type\nFloat\nxs:float\nDouble\nxs:double\n\nThe XML floating point type supports positive infinity (INF), negative infinity (-INF) and not-a-number (NaN)."
    },
    {
      "Id": "97f15f6c-b991-4ad7-91fa-2aa7714a2afe",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.5 String"
    },
    {
      "Id": "d18bae3b-46f6-4866-b805-b23a930f6478",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.5 String\n---\n",
      "Content": "A String value is encoded as an xs:string value.\nStrings with embedded nulls (\u0027\\u0000\u0027) are not guaranteed to be interoperable because not all DevelopmentPlatforms can handle Strings with embedded nulls. For this reason, embedded nulls are not recommended. Encoders may encode Strings with embedded nulls. Decoders shall read all bytes in String; however, decoders may truncate the String at the first embedded null before passing it on to the application."
    },
    {
      "Id": "4aa2ac44-ada7-4cce-b381-74faf2cfd624",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.6 DateTime"
    },
    {
      "Id": "3a0db1b2-687b-437c-b507-9ad9b7fdd55e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.6 DateTime\n---\n",
      "Content": "A DateTime value is encoded as an xs:dateTime value.\nAll DateTime values shall be encoded as UTC times or with the time zone explicitly specified.\nCorrect:\n2002-10-10T00:00:00\u002B05:00\n2002-10-09T19:00:00Z\nIncorrect:\n2002-10-09T19:00:00\nIt is recommended that all xs:dateTime values be represented in UTC format.\nThe earliest and latest date/time values that can be represented on a DevelopmentPlatform have special meaning and shall not be literally encoded in XML.\nThe earliest date/time value on a DevelopmentPlatform shall be encoded in XML as \u00270001-01-01T00:00:00Z\u0027.\nThe latest date/time value on a DevelopmentPlatform shall be encoded in XML as \u00279999-12-31T23:59:59Z\u0027\nIf a decoder encounters a xs:dateTime value that cannot be represented on the DevelopmentPlatform it should convert the value to either the earliest or latest date/time that can be represented on the DevelopmentPlatform. The XML decoder should not generate an error if it encounters an out of range date value.\nThe earliest date/time value on a DevelopmentPlatform is equivalent to a null date/time value."
    },
    {
      "Id": "f4fdaafc-a222-491c-ac84-51fe68b918f9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.7 Guid"
    },
    {
      "Id": "e04ccb2a-144d-4729-90a1-d348fadff19a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.7 Guid\n---\n",
      "Content": "A Guid is encoded using the string representation defined in[5.1.3](/\u00A7_Ref179442324).\nThe XML schema for a Guid is:\n\u003Cxs:complexType name=\u0022Guid\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022String\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "c137d668-952f-4f28-9b23-8db37463873b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.8 ByteString"
    },
    {
      "Id": "e2e54882-7a36-43e0-bd25-3e0221fe0297",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.8 ByteString\n---\n",
      "Content": "A ByteString value is encoded as an xs:base64Binary value (see[Base64](/\u00A7Base64)).\nThe XML schema for a ByteString is:\n\u003Cxs:element name=\u0022ByteString\u0022 type=\u0022xs:base64Binary\u0022 nillable=\u0022true\u0022/\u003E"
    },
    {
      "Id": "88dc89fc-7298-4828-92ea-94b43bedbfe4",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.9 XmlElement (Deprecated)"
    },
    {
      "Id": "1f2fc0b8-fdf2-4467-bcfd-5fc995937caf",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.9 XmlElement (Deprecated)\n---\n",
      "Content": "An XmlElement value is encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022XmlElement\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:any minOccurs=\u00220\u0022 maxOccurs=\u00221\u0022 processContents=\u0022lax\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\n\nXmlElements may only be used inside Variant or ExtensionObject values."
    },
    {
      "Id": "9b149f00-d96a-4852-a9dd-cd10b606ef09",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.10 NodeId"
    },
    {
      "Id": "40df8887-ecef-4564-be74-6cc33a095277",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.10 NodeId\n---\n",
      "Content": "A NodeId value is encoded as an xs:string with the syntax defined in[5.1.12](/\u00A7_Ref122651839).\nThe XML schema for a NodeId is:\n\u003Cxs:complexType name=\u0022NodeId\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Identifier\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "f39e774f-0801-4d2f-81af-1d753ad46fe1",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.11 ExpandedNodeId"
    },
    {
      "Id": "25fff2d8-123a-4146-b368-c9c2998dd266",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.11 ExpandedNodeId\n---\n",
      "Content": "An ExpandedNodeId value is encoded as an xs:string with the syntax defined in[5.1.12](/\u00A7_Ref122651839).\nThe XML schema for an ExpandedNodeId is:\n\u003Cxs:complexType name=\u0022ExpandedNodeId\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Identifier\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "c5f9b600-8686-4f81-980f-3462f43ddd56",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.12 StatusCode"
    },
    {
      "Id": "f9218228-aec9-4fe1-8b2f-33aad0d775a4",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.12 StatusCode\n---\n",
      "Content": "A StatusCode is encoded as an xs:unsignedInt with the following XML schema:\n\u003Cxs:complexType name=\u0022StatusCode\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Code\u0022 type=\u0022xs:unsignedInt\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "a67030f2-35ae-4a8e-a7da-b23b04a438eb",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.13 DiagnosticInfo"
    },
    {
      "Id": "403388ed-d6d0-4a67-8a5c-7510d689f551",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.13 DiagnosticInfo\n---\n",
      "Content": "An DiagnosticInfo value is encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022DiagnosticInfo\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022SymbolicId\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022NamespaceUri\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022Locale\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220/\u003E\n\u003Cxs:element name=\u0022LocalizedText\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220/\u003E\n\u003Cxs:element name=\u0022AdditionalInfo\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022/\u003E\n\u003Cxs:element name=\u0022InnerStatusCode\u0022 type=\u0022tns:StatusCode\u0022\nminOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022InnerDiagnosticInfo\u0022 type=\u0022tns:DiagnosticInfo\u0022\nminOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\nDiagnosticInfo is recursive and unlimited recursion could result in stack overflow errors even if the message size is less than the maximum allowed. Decoders shall support at least 4 recursion levels and are not expected to support more than 10. Decoders shall report an error if the number of recursion levels exceeds what it supports."
    },
    {
      "Id": "8702273a-551c-4747-afcd-6b09c9ae1dac",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.14 QualifiedName"
    },
    {
      "Id": "860bcad4-5b0e-4363-a117-8db2a87449b6",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.14 QualifiedName\n---\n",
      "Content": "A QualifiedName value is encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022QualifiedName\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022NamespaceIndex\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022Name\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "33eaf38d-27ab-4b0c-b063-f5a2e1db9709",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.15 LocalizedText"
    },
    {
      "Id": "e2ddf11a-32df-4ef9-bf3a-26a454c675a9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.15 LocalizedText\n---\n",
      "Content": "A LocalizedText value is encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022LocalizedText\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Locale\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022Text\u0022 type=\u0022xs:string\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "6dcbb5d8-c2dd-4a5c-8ddb-651734690e5d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.16 ExtensionObject"
    },
    {
      "Id": "76d62c81-4d4f-4d27-844b-4acb581c3d37",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.16 ExtensionObject\n---\n",
      "Content": "An ExtensionObject value is encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022ExtensionObject\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022TypeId\u0022 type=\u0022tns:NodeId\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022Body\u0022 minOccurs=\u00220\u0022\u003E\n\u003Cxs:complexType\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:any minOccurs=\u00220\u0022 processContents=\u0022lax\u0022/\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\n\u003C/xs:element\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\nThe body of the ExtensionObject contains a single element which is either a ByteString or XML encoded Structure. A decoder can distinguish between the two by inspecting the top-level element. An XML element with the name tns:ByteString contains an OPC UA Binary encoded body. Any other XML element name shall contain an OPC UA XML encoded body. Other DataEncodings may not be serialized in an ExtensionObject.\nThe TypeId should be the NodeId for the DataTypeEncoding Node. The NodeId of DataType Node may also be used when the body is encoded with the XML encoding."
    },
    {
      "Id": "aa537efa-e75a-4205-8767-67bfdafe199e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.17 Variant"
    },
    {
      "Id": "96fca7ab-6166-4080-8728-ba6952100e13",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.17 Variant\n---\n",
      "Content": "A Variant value is encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022Variant\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Value\u0022 minOccurs=\u00220\u0022 nillable=\u0022true\u0022\u003E\n\u003Cxs:complexType\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:any minOccurs=\u00220\u0022 processContents=\u0022lax\u0022/\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\n\u003C/xs:element\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\n\nIf the Variant represents a scalar value, then it shall contain a single child element with the name of the built-in type. For example, the single precision floating point value 3.1415 would be encoded as:\n\n\u003Ctns:Float\u003E3.1415\u003C/tns:Float\u003E\n\nIf the Variant represents a single dimensional array, then it shall contain a single child element with the prefix \u0027ListOf\u0027 and the name built-in type. For example, an Array of strings would be encoded as:\n\n\u003Ctns:ListOfString\u003E\n\u003Ctns:String\u003EHello\u003C/tns:String\u003E\n\u003Ctns:String\u003EWorld\u003C/tns:String\u003E\n\u003C/tns:ListOfString\u003E\n\nIf the Variant represents a multidimensional Array, then it shall contain a child element with the name \u0027 Matrix\u0027 with the two sub-elements shown in this example:\n\n\u003Ctns:Matrix\u003E\n\u003Ctns:Dimensions\u003E\n\u003Ctns:Int32\u003E2\u003C/tns:Int32\u003E\n\u003Ctns:Int32\u003E2\u003C/tns:Int32\u003E\n\u003C/tns:Dimensions\u003E\n\u003Ctns:Elements\u003E\n\u003Ctns:String\u003EA\u003C/tns:String\u003E\n\u003Ctns:String\u003EB\u003C/tns:String\u003E"
    },
    {
      "Id": "db16bcbc-1a88-478b-b674-f2d8ccdc96b5",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.17 Variant\n---\n",
      "Content": "\u003Ctns:String\u003EC\u003C/tns:String\u003E\n\u003Ctns:String\u003ED\u003C/tns:String\u003E\n\u003C/tns:Elements\u003E\n\u003C/tns:Matrix\u003E\n\nIn this example, the array has the following elements:\n[0,0] = \u0022A\u0022; [0,1] = \u0022B\u0022; [1,0] = \u0022C\u0022; [1,1] = \u0022D\u0022\nThe elements of a multi-dimensional Array are always flattened into a single dimensional Array where the higher rank dimensions are serialized first. This single dimensional Array is encoded as a child of the \u0027Elements\u0027 element. The \u0027Dimensions\u0027 element is an Array of Int32 values that specify the dimensions of the array starting with the lowest rank dimension. The multi-dimensional Array can be reconstructed by using the dimensions encoded. All dimensions shall be specified and shall be greater than zero. If the dimensions are inconsistent with the number of elements in the array, then the decoder shall stop and raise a Bad_DecodingError.\nThe complete set of built-in type names is found in[Table 1](/\u00A7_Ref83387521)."
    },
    {
      "Id": "1d51b3e8-8ac8-4e80-86a8-15e6c3809ea7",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.18 DataValue"
    },
    {
      "Id": "77604ac3-6123-4414-9b23-4145087653a7",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.18 DataValue\n---\n",
      "Content": "A DataValue value is encoded as a xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022DataValue\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Value\u0022 type=\u0022tns:Variant\u0022 minOccurs=\u00220\u0022\nnillable=\u0022true\u0022 /\u003E\n\u003Cxs:element name=\u0022StatusCode\u0022 type=\u0022tns:StatusCode\u0022\nminOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022SourceTimestamp\u0022 type=\u0022xs:dateTime\u0022\nminOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022SourcePicoseconds\u0022 type=\u0022xs:unsignedShort\u0022\nminOccurs=\u00220\u0022/\u003E\n\u003Cxs:element name=\u0022ServerTimestamp\u0022 type=\u0022xs:dateTime\u0022\nminOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022ServerPicoseconds\u0022 type=\u0022xs:unsignedShort\u0022\nminOccurs=\u00220\u0022/\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "57cadf2a-e7f5-4b7e-9e3a-c6d8205c4f93",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1 Built-in Types\n---\n",
      "Content": "5.3.1.19 Subtypes of Built-in Types"
    },
    {
      "Id": "ecdf3a98-db42-4dff-8333-fc1a9e23b676",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.1.19 Subtypes of Built-in Types\n---\n",
      "Content": "The subtypes of the built-in DataTypes described in[5.3.1](/\u00A7_Ref80085574) are encoded as the base Built-in DataType."
    },
    {
      "Id": "2332ef9e-1b29-4420-96c2-82f9bb88e8c5",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.2 Decimal"
    },
    {
      "Id": "84d51db7-acd8-4c43-b761-f048aad8939c",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.2 Decimal\n---\n",
      "Content": "A Decimal Value is a encoded as an xs:complexType with the following XML schema:\n\u003Cxs:complexType name=\u0022Decimal\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022TypeId\u0022 type=\u0022tns:NodeId\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022Body\u0022 minOccurs=\u00220\u0022\u003E\n\u003Cxs:complexType\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022Scale\u0022 type=\u0022xs:short\u0022 /\u003E\n\u003Cxs:element name=\u0022Value\u0022 type=\u0022xs:string\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\n\u003C/xs:element\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\nThe NodeId is always the NodeId of the Decimal DataType. When encoded in a Variant the Decimal is encoded as an ExtensionObject. Arrays of Decimals are Arrays of ExtensionObjects.\nThe Value is a base-10 signed integer with no limit on size. See[5.1.10](/\u00A7_Ref473899214) for a description of the Scale and Value fields."
    },
    {
      "Id": "a4cf554a-0489-48f5-b826-50c068737d7e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.3 Enumerations"
    },
    {
      "Id": "ea693ecb-d8cc-4633-8cc9-2edfc1f830c2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.3 Enumerations\n---\n",
      "Content": "Enumerations that are used as parameters in the Messages defined in[OPC 10000-4](/\u00A7UAPart4) are encoded as xs:string with the following syntax:\n\u003Csymbol\u003E_\u003Cvalue\u003E\nThe elements of the syntax are described in[Table 35](/\u00A7_Ref131571897).\nTable 35- Components of Enumeration\nField\nType\nDescription\n\u003Csymbol\u003E\nString\nThe symbolic name for the enumerated value.\n\u003Cvalue\u003E\nUInt32\nThe numeric value associated with enumerated value.\n\nFor example, the XML schema for the NodeClass enumeration is:\n\u003Cxs:simpleType name=\u0022NodeClass\u0022\u003E\n\u003Cxs:restriction base=\u0022xs:string\u0022\u003E\n\u003Cxs:enumeration value=\u0022Unspecified_0\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022Object_1\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022Variable_2\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022Method_4\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022ObjectType_8\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022VariableType_16\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022ReferenceType_32\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022DataType_64\u0022 /\u003E\n\u003Cxs:enumeration value=\u0022View_128\u0022 /\u003E\n\u003C/xs:restriction\u003E\n\u003C/xs:simpleType\u003E\n\nEnumerations that are stored in a Variant are encoded as an Int32 value.\nFor example, any Variable could have a value with a DataType of NodeClass. In this case, the corresponding numeric value is placed in the Variant(e.g. NodeClass Object would be stored as a 1)."
    },
    {
      "Id": "ff59ce3e-163a-4a8b-9aa7-f6dca2d5ccc4",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.4 Arrays"
    },
    {
      "Id": "1e8e4d39-6bc5-4b0f-a3b4-d2576d8b2831",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.4 Arrays\n---\n",
      "Content": "One dimensional Array parameters are always encoded by wrapping the elements in a container element and inserting the container into the structure. The name of the container element should be the name of the parameter. The name of the element in the array shall be the type name.\nFor example, the Read service takes an array of ReadValueIds. The XML schema would look like:\n\u003Cxs:complexType name=\u0022ListOfReadValueId\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022ReadValueId\u0022 type=\u0022tns:ReadValueId\u0022\nminOccurs=\u00220\u0022 maxOccurs=\u0022unbounded\u0022 nillable=\u0022true\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\nThe nillable attribute shall be specified because XML encoders will drop elements in arrays if those elements are empty.\nMulti-dimensional Array parameters are encoded using the Matrix type defined in[5.3.1.17](/\u00A7_Ref294074990)."
    },
    {
      "Id": "73900f44-ec19-4f68-8c35-89fb964404e7",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.5 Structures"
    },
    {
      "Id": "c721945b-0465-4f0e-b006-28f909f79f3f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.5 Structures\n---\n",
      "Content": "Structures are encoded as a xs:complexType with all of the fields appearing as a sequence of xs:elements. Each element has a name specified by the name of the field in the DataTypeDefinition. All elements have minOccurs set 0 to allow for compact XML representations. If an element is missing the DefaultValue for the field type is used. If the field type is a structure the DefaultValue is an instance of the structure with DefaultValues for each contained field.\nThe XML type for an element name is xs:name and it restricts the set of characters that are permitted. If a DataType name or its field names uses characters that are not permitted then the name encoding rules in[5.1.13](/\u00A7_Ref157826681) shall be used.\nTypes which have a NULL value defined shall have the nillable=\u0022true\u0022 flag set.\nFor example, the Read service has a ReadValueId structure in the request. The XML schema would look like:\n\u003Cxs:complexType name=\u0022ReadValueId\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022NodeId\u0022 type=\u0022tns:NodeId\u0022\nminOccurs=\u00220\u0022 nillable=\u0022true\u0022 /\u003E\n\u003Cxs:element name=\u0022AttributeId\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022IndexRange\u0022 type=\u0022xs:string\u0022\nminOccurs=\u00220\u0022 nillable=\u0022true\u0022 /\u003E\n\u003Cxs:element name=\u0022DataEncoding\u0022 type=\u0022tns:NodeId\u0022\nminOccurs=\u00220\u0022 nillable=\u0022true\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "de85ecec-380c-46ee-b093-23b8fa17a037",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.6 Structures with optional fields"
    },
    {
      "Id": "2f4e1023-576b-4d65-9e50-221612df16af",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.6 Structures with optional fields\n---\n",
      "Content": "Structures with optional fields are encoded as a xs:complexType with all of the fields appearing as a sequence of xs:elements. The first element is a bit mask that specifies what fields are encoded. The bits in the mask are sequentially assigned to optional fields in the order they appear in the Structure. The rest of the elements have a name specified by the name of the field in the DataTypeDefinition.\nTo allow for compact XML, any field can be omitted from the XML so decoders shall assign DefaultValues based on the field type for any mandatory fields.\nThe xs:name attribute restricts the set of characters that are permitted. See[5.3.5](/\u00A7_Ref181724699) for instructions on how to handle invalid characters.\nFor example, the following Structure has one mandatory and two optional fields. The XML schema would look like:\n\u003Cxs:complexType name=\u0022OptionalType\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022EncodingMask\u0022 type=\u0022xs:unsignedLong\u0022 /\u003E\n\u003Cxs:element name=\u0022X\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022O1\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022Y\u0022 type=\u0022xs:byte\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003Cxs:element name=\u0022O2\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022 /\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E\nIn the example above, the EncodingMask has a value of 3 if both O1 and O2 are encoded. Encoders shall set unused bits to 0 and decoders shall ignore unused bits.\nIf a Structure with optional fields is subtyped, the subtypes extend the EncodingMask defined for the parent."
    },
    {
      "Id": "6eac34b8-5d77-4879-a0f0-97a5d1b05f88",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.7 Unions"
    },
    {
      "Id": "b41510fa-7851-495c-bba2-8fc581f550e0",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.7 Unions\n---\n",
      "Content": "Unions are encoded as an xs:complexType containing an xs:sequence with two entries.\nThe first entry in the sequence is the SwitchField xs:element and specifies a numeric value which identifies which element in the xs:choice is encoded. The name of the element may be any valid text.\nThe second entry in the sequence is an xs:choice which specifies the possible fields as xs:elements. The order in the xs:choice determines the value of the SwitchField when that choice is encoded. The first element has a SwitchField value of 1 and the last value has a SwitchField equal to the number of choices. The name of each xs:choice is the name of the field in the DataTypeDefinition.\nNo additional elements in the sequence are permitted. If the SwitchField is missing or 0 then the union has a NULL value. Encoders or decoders shall report an error for any SwitchField value greater than the number of defined union fields.\nThe name attribute restricts the set of characters that are permitted. See[5.3.5](/\u00A7_Ref181724699) for instructions on how to handle invalid characters.\nFor example, the following union has two fields. The XML schema would look like:\n\u003Cxs:complexType name=\u0022Type1\u0022\u003E\n\u003Cxs:sequence\u003E\n\u003Cxs:element name=\u0022SwitchField\u0022\ntype=\u0022xs:unsignedInt\u0022 minOccurs=\u00220\u0022/\u003E\n\u003Cxs:choice\u003E\n\u003Cxs:element name=\u0022Field1\u0022 type=\u0022xs:int\u0022 minOccurs=\u00220\u0022/\u003E\n\u003Cxs:element name=\u0022Field2\u0022 type=\u0022tns:Field2\u0022 minOccurs=\u00220\u0022/\u003E    \u003C/xs:choice\u003E\n\u003C/xs:sequence\u003E\n\u003C/xs:complexType\u003E"
    },
    {
      "Id": "4f23e906-5e6d-453b-8ffb-45f5ae3d539e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3 OPC UA XML\n---\n",
      "Content": "5.3.8 Messages"
    },
    {
      "Id": "bbc2d2ed-3125-4f74-ade4-925122af3b81",
      "Header": "Document: Part 6 - Mappings\nSection: 5.3.8 Messages\n---\n",
      "Content": "Messages are encoded as an xs: complexType. The parameters in each Message are serialized in the same way the fields of a Structure are serialized."
    },
    {
      "Id": "c7a91fcd-1132-454b-9463-e04996c87985",
      "Header": "Document: Part 6 - Mappings\nSection: 5 Data encoding\n---\n",
      "Content": "5.4 OPC UA JSON"
    },
    {
      "Id": "fffed40f-4b94-424c-b6e9-2c5db695b041",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.1 General"
    },
    {
      "Id": "559e8ed6-734b-4745-bb21-556f7227a2be",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.1 General\n---\n",
      "Content": "Editors Note: The JSON encoding was changed very late in the specification release cycle with limited implementation to validate the design. Subsequent implementations and interoperability testing may result in changes to the JSON encoding in future versions of this specification.\nThe JSON DataEncoding was developed to allow OPC UA applications to interoperate with web and enterprise software that use this format. The OPC UA JSON DataEncoding defines standard JSON representations for all OPC UA Built-In types.\nThe JSON format is defined in[RFC 8259](/\u00A7RFC7159). It is partially self-describing because each field has a name encoded in addition to the value, however, JSON has no mechanism to qualify names with namespaces.\nThe JSON format does not have a published standard for a schema that can be used to describe the contents of a JSON document. However, the schema mechanisms defined in this document can be used to describe JSON documents. Specifically, the DataTypeDescription structure defined in[OPC 10000-3](/\u00A7UAPart3) can define any JSON document that conforms to the rules described below.\nThere are two important use cases for the JSON encoding: cloud applications which consume PubSub messages and JavaScript Clients(JSON is the preferred serialization format for JavaScript). For the cloud application use case, the PubSub message needs to be self-contained which implies it cannot contain numeric references to an externally defined namespace table. Cloud applications also often rely on scripting languages to process the incoming messages so artefacts in the DataEncoding that exist to ensure fidelity during decoding are not necessary. For this reason, this DataEncoding identifies some the artefacts which can be removed to meet the needs of cloud applications. Applications, such as JavaScript Clients, which use the DataEncoding for communication with other OPC UA applications require the artefacts.\nThe CompactEncoding omits all fields in Structure"
    },
    {
      "Id": "4b3c8234-5266-46c1-aa92-501859a4a02a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.1 General\n---\n",
      "Content": "Structure values with a value equal to the default value for the type. The VerboseEncoding includes all of these fields.\nThe CompactEncoding and VerboseEncoding replace the ReversibleEncoding and NonReversibleEncoding. The differences are described in Annex H. The VerboseEncoding also supports the RawData mode defined in[OPC 10000-14](/\u00A7UAPart14). In RawData mode, encoders shall omit the following fields:\nUaType (see[5.4.2.17](/\u00A7_Ref123196369) and[5.4.2.18](/\u00A7_Ref181691902));\nUaTypeId (see[5.4.2.16](/\u00A7_Ref173668848));\nDecoders may not be able to process streams encoding in RawData mode unless they have access to the associated metadata. These fields are not omitted when serialization uses abstract DataTypes such as Structure(i.e. ExtensionObject) or BaseDataType(i.e. Variant).[OPC 10000-14](/\u00A7UAPart14) specifies the behaviour if a Publisher is misconfigured with metadata that uses abstract DataTypes."
    },
    {
      "Id": "1a5f8ecf-fc1b-4efe-8695-10f2d48cfad9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.2 Built-in Types"
    },
    {
      "Id": "41070805-bbde-442e-9274-de864e169404",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.1 General"
    },
    {
      "Id": "3171d9a6-26d8-460b-a198-7b6e16f5e769",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.1 General\n---\n",
      "Content": "Any value for a nullable Built-In type that is NULL shall be encoded as the JSON literal \u0027null\u0027 if the value is an element of a JSON array. If the NULL value is for a field within a JSON object, the field shall be omitted when using the CompactEncoding. When using the VerboseEncoding, the field is encoded as the JSON literal \u0027null\u0027.\nAny non-nullable Built-In type shall be encoded if it is an element of an array. When using the CompactEncoding, the field of a Structure or Union is omitted if value is equal to the default value for the Built-In type.\nNote that JSON objects are unordered sets of name-value pairs. When a Built-In type is encoded as a JSON object, the order of fields specified is not preserved."
    },
    {
      "Id": "237a4d00-13f1-4b31-bf22-5dfc2f3c2a7b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.2 Boolean"
    },
    {
      "Id": "01e0e649-8c8c-45f1-8874-11365c44a24c",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.2 Boolean\n---\n",
      "Content": "A Boolean value shall be encoded as the JSON literal \u0027true\u0027 or \u0027false\u0027."
    },
    {
      "Id": "db4debd5-b2f8-4711-9cbc-edb926312b69",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.3 Integer"
    },
    {
      "Id": "de9671c5-3fa4-40c6-9d23-f907a5047e7b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.3 Integer\n---\n",
      "Content": "Integer values other than Int64 and UInt64 shall be encoded as a JSON number.\nInt64 and UInt64 values shall be formatted as a decimal number encoded as a JSON string\n(See the XML encoding of 64-bit values described in[5.3.1.3](/\u00A7_Ref477957966))."
    },
    {
      "Id": "3dcf4213-caed-4952-bd63-d98fa46883e2",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.4 Floating point"
    },
    {
      "Id": "2b2a0e7a-dd40-43df-a2b4-5552eb3e827b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.4 Floating point\n---\n",
      "Content": "Normal Float and Double values shall be encoded as a JSON number.\nSpecial floating-point numbers such as positive infinity (INF), negative infinity (-INF) and not-a-number (NaN) shall be represented by the values \u0022Infinity\u0022, \u0022-Infinity\u0022 and \u0022NaN\u0022 encoded as a JSON string. See[5.2.2.3](/\u00A7_Ref397324905) for more information on the different types of special floating-point numbers."
    },
    {
      "Id": "6851bbf0-d72c-496a-98a9-3bb06f084377",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.5 String"
    },
    {
      "Id": "f22ba1a8-f2ad-4afd-beb5-cf15c4a0b25c",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.5 String\n---\n",
      "Content": "String values shall be encoded as JSON strings.\nAny characters which are not allowed in JSON strings are escaped using the rules defined in[RFC 8259](/\u00A7RFC7159).\nStrings with embedded nulls (\u0027\\u0000\u0027) are not guaranteed to be interoperable because not all DevelopmentPlatforms can handle Strings with embedded nulls. For this reason, embedded nulls are not recommended. Encoders may encode Strings with embedded nulls. Decoders shall read all bytes in String; however, decoders may truncate the String at the first embedded null before passing it on to the application."
    },
    {
      "Id": "b3766b76-5be3-442d-9755-977ba1383299",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.6 DateTime"
    },
    {
      "Id": "c1323eda-4a61-467e-9230-eee760db2bbf",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.6 DateTime\n---\n",
      "Content": "DateTime values shall be formatted as specified by[ISO 8601-1](/\u00A7ISO8601) and encoded as a JSON string.\nDateTime values which exceed the minimum or maximum values supported on a platform shall be encoded as \u00220001-01-01T00:00:00Z\u0022 or \u00229999-12-31T23:59:59Z\u0022 respectively. During decoding, these values shall be converted to the minimum or maximum values supported on the platform.\n[ISO 8601-1](/\u00A7ISO8601) DateType values may specify an arbitrary number of decimal places representing fractions of seconds. Encoders shall support as many decimal places needed to represent the full range of the DateTime type on their DevelopmentPlatform. Decoders may truncate decimal places that exceed the range supported by the DateTime type on their DevelopmentPlatform.\nDateTime values equal to \u00220001-01-01T00:00:00Z\u0022 are considered to be NULL values."
    },
    {
      "Id": "96397f92-b695-408d-8021-0b90bf3cc94e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.7 Guid"
    },
    {
      "Id": "d12023b7-349d-4080-87d3-818178ab9c0e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.7 Guid\n---\n",
      "Content": "Guid values shall be formatted as described in[5.1.3](/\u00A7_Ref179442324) and encoded as a JSON string."
    },
    {
      "Id": "0ae48a84-6317-4782-bdd7-6aead8dfc55e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.8 ByteString"
    },
    {
      "Id": "645557ad-bca6-4ae8-a44b-431737e37e6f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.8 ByteString\n---\n",
      "Content": "ByteString values shall be formatted as a[Base64](/\u00A7Base64) text and encoded as a JSON string.\nAny characters which are not allowed in JSON strings are escaped using the rules defined in[RFC 8259](/\u00A7RFC7159)."
    },
    {
      "Id": "dece6ef9-01f4-417b-a812-5f755f18213d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.9 XmlElement"
    },
    {
      "Id": "e58aa154-bb3e-4708-b9e6-8bca485afd71",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.9 XmlElement\n---\n",
      "Content": "XmlElement value shall be encoded as a String as described in[5.4.2.5](/\u00A7_Ref443248195)."
    },
    {
      "Id": "8244a2f1-c498-41d7-b132-9f9a5f0f73f0",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.10 NodeId"
    },
    {
      "Id": "63fea1a6-9f68-4318-a8bc-7570464a2092",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.10 NodeId\n---\n",
      "Content": "NodeId values shall be encoded as a JSON string using the format defined in[5.1.12](/\u00A7_Ref122651839). NodeIds in NamespaceIndex 0 use the \u003Cidentifier\u003E form. All other NodeIds use the \u003Cnamespace-uri\u003E form.\nThe first abnormal state occurs when the encoder cannot map a NamespaceIndex to a NamespaceUri. In this case, the encoder shall encode the NamespaceIndex using the \u003Cnamespace-index\u003E form. The decoder shall pass this NamespaceIndex to the application.\nThe second abnormal state occurs when the decoder cannot convert a NamespaceUri to a NamespaceIndex. If this occurs the decoder shall set the NamespaceIndex to 0, the IdType to String and the Identifier to the JSON string."
    },
    {
      "Id": "df4aa7a7-4c53-4aff-bc1a-42ff2c0466ae",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.11 ExpandedNodeId"
    },
    {
      "Id": "0e571fa7-7604-4a07-bd52-24412c23201d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.11 ExpandedNodeId\n---\n",
      "Content": "ExpandedNodeId values shall be encoded as a JSON string using the format defined in[5.1.12](/\u00A7_Ref122651839). The NodeId portion of the ExpandedNodeId uses the rules from[5.4.2.10](/\u00A7_Ref456142221). ExpandedNodeIds with a ServerIndex of 0 are encoded using the \u003Cnode-id\u003E form. All other ExpandedNodeIds use the \u003Cserver-uri\u003E form unless the first abnormal state occurs as described below.\nThe first abnormal state occurs when the encoder cannot map a ServerIndex to a ServerUri. In this case, the encoder shall encode the ServerIndex using the \u003Cserver-index\u003E form. The decoder shall pass this ServerIndex to the application.\nThe second abnormal state occurs when the decoder cannot convert a ServerUri to a ServerIndex. If this occurs the decoder shall set the ServerIndex to 0, the NamespaceIndex to 0, the IdType to String and the Identifier to the JSON string.\nWhen the ServerIndex is 0, decoders shall replace a NamespaceUri with a NamespaceIndex when a mapping exists or if a mapping can be created. If no mapping exists or one cannot be created the NamespaceUri is stored in the NamespaceUri field of the ExpandedNodeId."
    },
    {
      "Id": "eb4685ac-111f-412a-af43-d0bb96eeb6f8",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.12 StatusCode"
    },
    {
      "Id": "14750380-95ae-4082-9a86-91269769df4a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.12 StatusCode\n---\n",
      "Content": "StatusCode values shall be encoded as a JSON object with the fields defined in[Table 36](/\u00A7_Ref457558533).\nTable 36- JSON Object Definition for a StatusCode\nName\nDescription\nCode\nThe numeric code encoded as a JSON number.\nThe Code is omitted if the numeric code is 0 (Good).\nSymbol\nThe string literal associated with the numeric code encoded as JSON string.\ne.g. 0x80AB0000 has the associated literal \u0022BadInvalidArgument\u0022.\nAny InfoBits in the StatusCode are ignored when looking up the symbol.\nIf the string literal is not known to the encoder the field is omitted.\nThe field is omitted in the CompactEncoding.\nThe field is omitted if the numeric code is 0 (Good).\nThe recommended string literals are defined in[A.2](/\u00A7_Ref80223065)."
    },
    {
      "Id": "818ee8ad-d921-47b5-bc65-5b05e4f0f8ad",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.13 DiagnosticInfo"
    },
    {
      "Id": "2200f815-26b9-418d-a155-dd402b6f84e0",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.13 DiagnosticInfo\n---\n",
      "Content": "DiagnosticInfo values shall be encoded as a JSON object with the fields shown in[Table 37](/\u00A7_Ref457558616).\nTable 37- JSON Object Definition for a DiagnosticInfo\nName\nData Type\nDescription\nSymbolicId\nInt32\nA symbolic name for the status code.\nThe default value is -1.\nIt is not encoded if the value is -1.\nNamespaceUri\nInt32\nA namespace that qualifies the symbolic id.\nThe default value is -1.\nIt is not encoded if the value is -1.\nLocale\nInt32\nThe locale used for the localized text.\nThe default value is -1.\nIt is not encoded if the value is -1.\nLocalizedText\nInt32\nA human readable summary of the status code.\nThe default value is -1.\nIt is not encoded if the value is -1.\nAdditionalInfo\nString\nDetailed application specific diagnostic information.\nThe default value is null.\nIt is not encoded if the value is null.\nInnerStatusCode\nStatusCode\nA status code provided by an underlying system.\nThe default value is Good.\nIt is not encoded if the value is Good.\nInnerDiagnosticInfo\nDiagnosticInfo\nDiagnostic info associated with the inner status code.\nThe default value is null.\nIt is not encoded if the value is null.\n\nThe SymbolicId, NamespaceUri, Locale and LocalizedText fields are encoded as JSON numbers which reference the StringTable contained in the ResponseHeader.\nDiagnosticInfo"
    },
    {
      "Id": "af593499-ae60-42dd-8881-4cfd5fbc0f00",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.13 DiagnosticInfo\n---\n",
      "Content": ".\nDiagnosticInfo is recursive and unlimited recursion could result in stack overflow errors even if the message size is less than the maximum allowed. Decoders shall support at least 4 recursion levels and are not expected to support more than 10. Decoders shall report an error if the number of recursion levels exceeds what it supports."
    },
    {
      "Id": "e8c4bf19-73d9-4efb-9b81-4bd83b687b27",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.14 QualifiedName"
    },
    {
      "Id": "fba7ece6-8880-4603-ba96-b518078ce630",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.14 QualifiedName\n---\n",
      "Content": "QualifiedName values shall be encoded as a JSON string using the format defined in[5.1.12](/\u00A7_Ref122651839).\nThe form with the NamespaceIndex is not allowed unless there is an encoding error. This can occur when the encoder cannot map a NamespaceIndex to a NamespaceUri. In this case, the encoder shall encode the NamespaceIndex using the \u003Cnamespace-index\u003E form. The decoder shall pass this NamespaceIndex to the application.\nA second abnormal state occurs when the decoder cannot convert a NamespaceUri to a NamespaceIndex. If this occurs the decoder shall set the NamespaceIndex to 0 and the Name to the raw JSON string that includes the NamespaceUri that cannot be decoded."
    },
    {
      "Id": "0caf56a5-1da3-42ac-87f9-70e810a20ad6",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.15 LocalizedText"
    },
    {
      "Id": "bffe78c7-5074-435d-8008-56e0fe8e1c83",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.15 LocalizedText\n---\n",
      "Content": "LocalizedText values shall be encoded as a JSON object with the fields shown in[Table 38](/\u00A7_Ref457559512).\nTable 38- JSON Object Definition for a LocalizedText\nName\nDescription\nLocale\nThe Locale portion of LocalizedText values shall be encoded as a JSON string.\nThe field is not encoded if it is null or empty.\nText\nThe Text portion of LocalizedText values shall be encoded as a JSON string.\nThe field is not encoded if it is null or empty."
    },
    {
      "Id": "719fd7dc-12f1-4c9f-9924-ec6b579c8646",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.16 ExtensionObject"
    },
    {
      "Id": "00022136-0f4e-4ea6-b434-b835da6a3257",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.16 ExtensionObject\n---\n",
      "Content": "The ExtensionObject is encoded as a JSON object as described in:\nStructure(see[5.4.6](/\u00A7_Ref456142396));\nStructure with optional fields (see[5.4.7](/\u00A7_Ref477876716));\nUnion(see[5.4.8](/\u00A7_Ref181569080));\nwith the UaTypeId field inserted into the JSON object.\nDecoders shall report decoding errors to the application if a JSON object has multiple fields with the same name.\nThe UaEncoding and UaBody fields are only used when UA Binary or UA XML encoded Structures are serialized. Only the fields in[Table 39](/\u00A7_Ref158752135) are present if these fields are used.\nThe JSON object fields used for an ExtensionObject are in[Table 39](/\u00A7_Ref158752135).\nTable 39- JSON Object Fields used for an ExtensionObject\nName\nDescription\nUaTypeId\nA NodeId formatted using the rules in[5.4.2.10](/\u00A7_Ref456142221).\nThis is the NodeId of a DataType Node.\nUaEncoding\nA JSON number that represents the format of the UaBody field.\nA value of 1 indicates UA Binary data is encoded in the UaBody field.\nA value of 2 indicates UA XML data is encoded in the UaBody field.\nThis field is omitted for JSON encoded Structures.\nUaBody\nA ByteString containing an UA Binary or UA XML encoded Structure.\nThis field is omitted for JSON encoded Structures.\n\nEncoders, when allowed by the DevelopmentPlatform, should write the UaTypeId first. Decoders shall accept the UaTypeId in any position."
    },
    {
      "Id": "5588d199-6754-434e-b29f-5987da457f4e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.17 Variant"
    },
    {
      "Id": "626bcc74-a5cc-4b6d-a309-fbcbdc0d4959",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.17 Variant\n---\n",
      "Content": "Variant values shall be encoded as a JSON object with the fields shown in[Table 40](/\u00A7_Ref456171710).\nTable 40- JSON Object Definition for a Variant\nName\nDescription\nUaType\nThe Built-in type for the value contained in the Body(see[Table 1](/\u00A7_Ref83387521)) encoded as JSON number.\nValue\nIf the value is a scalar, it is encoded using the rules for type specified for the Type.\nIf the value is a one-dimensional array it is encoded as JSON array (see[5.4.5](/\u00A7_Ref457562559)).\nMulti-dimensional arrays are encoded as a JSON array containing all elements. The mapping of a multidimensional array to a flat list is described in[5.2.2.16](/\u00A7_Ref400568926).\nThe field is not encoded if the value is a NULL for nullable Built-in types (see[Table 1](/\u00A7_Ref83387521)).\nDimensions\nThe dimensions of the array encoded as a JSON array of JSON numbers.\n\nEncoders, when allowed by the DevelopmentPlatform, should write the UaType first. Decoders shall accept the UaType field in any position."
    },
    {
      "Id": "49ed9ddb-a041-4347-b4c2-5e66ed279434",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2 Built-in Types\n---\n",
      "Content": "5.4.2.18 DataValue"
    },
    {
      "Id": "c65288c8-6c8b-4bb5-83b9-3e0f82f0cb2b",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.2.18 DataValue\n---\n",
      "Content": "DataValue values shall be encoded as a JSON object with the fields shown in[Table 41](/\u00A7_Ref457894143).\nThe DataValue adds additional fields to a Variant(see[5.4.2.17](/\u00A7_Ref123196369)).\nTable 41- JSON Object Definition for a DataValue\nName\nData Type\nDescription\nUaType\nByte\nSee the UaType field in the Variant.\nValue\n*\nSee the Value field in the Variant.\nDimensions\nUInt32\nSee the Dimensions field in the Variant.\nStatus\nStatusCode\nThe status associated with the value.\nNot encoded if the value is Good (0).\nSourceTimestamp\nDateTime\nThe source timestamp associated with the value.\nNot encoded if the value is DateTime.MinValue.\nSourcePicoseconds\nUInt16\nThe number of 10 Picosecond intervals for the SourceTimestamp.\nNot encoded if the value is 0.\nServerTimestamp\nDateTime\nThe Server timestamp associated with the value.\nNot encoded if the value is DateTime.MinValue.\nServerPicoseconds\nUInt16\nThe number of 10 Picosecond intervals for the ServerTimestamp.\nNot encoded if the value is 0."
    },
    {
      "Id": "67688795-79fe-4c3a-8b04-2a916a43bcc7",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.3 Decimal"
    },
    {
      "Id": "aa8cd1aa-1672-4063-8477-d68165d34224",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.3 Decimal\n---\n",
      "Content": "Decimal values shall be encoded as a JSON object with the fields in[Table 42](/\u00A7_Ref482950713).\nTable 42- JSON Object Definition for a Decimal\nName\nDescription\nScale\nA JSON number with the scale applied to the Value.\nValue\nA JSON string with the Value encoded as a base-10 signed integer.\n(See the XML encoding of Integer values described in[5.3.1.3](/\u00A7_Ref477957966)).\n\nSee[5.1.10](/\u00A7_Ref473899214) for a description of the Scale and Value fields.\nWhen encoding in a Variant, a Decimal value shall be encoded as an ExtensionObject with the JSON object in[Table 42](/\u00A7_Ref482950713) as the Body. The TypeId shall be the NodeId of the Decimal DataType and the Encoding shall be 0."
    },
    {
      "Id": "5af295e1-452a-493b-a0fe-3117ef0e55b6",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.4 Enumerations"
    },
    {
      "Id": "3b13eafb-3f75-4b2e-9c56-981a9bb00287",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "5.4.4.1.1 Compact"
    },
    {
      "Id": "13191d4b-69e5-4575-ba67-85bef448800f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.4.1.1 Compact\n---\n",
      "Content": "Enumeration values shall be encoded as a JSON number.\nWhen an Enumeration is encoded in a Variant the Type field is Int32."
    },
    {
      "Id": "4ed8eaf2-8dc9-4447-927c-2b8e2363cfc4",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "5.4.4.1.2 Verbose"
    },
    {
      "Id": "ca6a0d56-eb0d-4725-a21c-188ae4361ede",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.4.1.2 Verbose\n---\n",
      "Content": "Enumeration values are encoded as a JSON string with the following format:\n\u003Cname\u003E_\u003Cvalue\u003E\nWhere the name is the enumeration literal and the value is the numeric value.\nIf the literal is not known to the encoder, the numeric value is encoded as a JSON string.\nWhen an Enumeration is encoded in a Variant the Type field is a Int32 and the value is encoded as a JSON number."
    },
    {
      "Id": "77bb4ea2-8e3a-458b-9095-10fda854ef4a",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.5 Arrays"
    },
    {
      "Id": "71b75733-ffed-4b1f-a11c-7db05aae35b9",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.5 Arrays\n---\n",
      "Content": "One dimensional Arrays shall be encoded as JSON arrays.\nIf an element is NULL, the element shall be encoded as the JSON literal \u0027null\u0027.\nOtherwise, the element is encoded according to the rules defined for the type.\nMultidimensional Arrays are encoded as JSON object with the fields defined in[Table 43](/\u00A7_Ref161359461).\nTable 43- JSON Object Definition for an inline Matrix\nName\nDescription\nArray\nMulti-dimensional arrays are encoded as a one-dimensional JSON array which is reconstructed using the value of the Dimensions field (see[5.2.2.16](/\u00A7_Ref400568926)).\nDimensions\nThe dimensions of the array encoded as a JSON array of JSON numbers."
    },
    {
      "Id": "2d0c8a51-291d-415e-b33b-2be2426dc732",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.6 Structures"
    },
    {
      "Id": "29fdd4f8-3c23-45b4-a82e-2f2fc2cb11e7",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.6 Structures\n---\n",
      "Content": "Structures shall be encoded as JSON objects.\nNote that JSON objects are unordered sets of name-value pairs. The order specified by the DataTypeDefinition is not preserved when a Structure is serialized in JSON.\nFields which are NULL or have a default value shall be encoded using the rules shown in[Table 44](/\u00A7_Ref83322286).\nTable 44- JSON Encoding Rules for Structures\nField Value\nCompact\nVerbose\nNULL\nOmitted\nJSON null\nDefault Value\nOmitted\nDefault Value\n\nFor example, instances of the structures:\nstruct Type2\n{\nInt32 A;\nInt32 B;\nChar* C;\n};\n\nstruct Type1\n{\nInt32 X;\nInt32 NoOfY;\nType2* Y;\nInt32 Z;\n};\n\nThe CompactEncoding is represented in JSON as:\n{\n\u0022X\u0022:1234,\n\u0022Y\u0022:[ { \u0022A\u0022:1, \u0022B\u0022:2, \u0022C\u0022:\u0022Hello\u0022 }, { \u0022A\u0022:3, \u0022B\u0022:4 } ],\n\u0022Z\u0022:5678\n}\nWhere \u0022C\u0022 is omitted from the second Type2 instance because it has a NULL value.\nThe VerboseEncoding is represented in JSON as:\n{\n\u0022X\u0022:1234,\n\u0022Y\u0022:[ { \u0022A\u0022:1, \u0022B\u0022:2, \u0022C\u0022:\u0022Hello\u0022 }, { \u0022A\u0022:3, \u0022B\u0022:4, \u0022C\u0022:null } ],\n\u0022Z\u0022:5678\n}\nWhere \u0022C\u0022 in the second Type2 instance has a JSON null value.\nCode generators should ensure that the special field names ( UaType, UaTypeId and EncodingMask) are not permitted in Structures."
    },
    {
      "Id": "0bacd080-44bd-477d-a6a5-f64f6c14e2af",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.7 Structures with optional fields"
    },
    {
      "Id": "ef67b0b6-12b2-417a-aca4-0382dc69e86d",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.7 Structures with optional fields\n---\n",
      "Content": "Structures with optional fields shall be encoded as JSON objects as shown in[Table 45](/\u00A7_Ref457739939).\nNote that JSON objects are unordered sets of name-value pairs. The order specified by the DataTypeDefinition is not preserved when a Structure is serialized in JSON. The EncodingMask may not appear as the first field.\nIn the VerboseEncoding the bits in the EncodingMask are determined by the presence of a field in the JSON object. In the CompactEncoding, EncodingMask indicates which fields are specified because fields are omitted because they have a default value.\nTable 45- JSON Object Definition for a Structures with Optional Fields\nName\nDescription\nEncodingMask\nA bit mask indicating what fields are encoded in the structure (see[5.2.7](/\u00A7_Ref401507564))\nThis mask is encoded as a JSON number.\nThe bits are sequentially assigned to optional fields in the order that they are defined.\nThis field is omitted in the VerboseEncoding\n\u003CFieldName\u003E\nThe field in structure encoded according to the rules defined for their DataType.\nOne entry may exist for each mandatory field and each optional field that is present.\n\nFields which are NULL or have a default value shall be encoded using the rules shown in[Table 46](/\u00A7_Ref83322467).\nTable 46- JSON Encoding Rules for Structures with Optional Fields\nField Value\nField Type\nCompact\nVerbose\nNULL\nMandatory\nOmitted\nJSON null\nDefault Value\nMandatory\nOmitted\nDefault Value\nNULL\nOptional (Present)\nOmitted\nJSON null\nDefault Value\nOptional (Present)\nOmitted\nDefault Value\nNULL\nOptional (Omitted)\nOmitted\nOmitted\nDefault Value\nOptional (Omitted)\nOmitted\nOmitted"
    },
    {
      "Id": "cae9de31-6019-4542-87bb-1d040264c805",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.7 Structures with optional fields\n---\n",
      "Content": "Omitted\n\nIf a Structure with optional fields is subtyped, the subtypes extend the EncodingMask defined for the parent.\nThe following is an example of a structure with optional fields using C\u002B\u002B syntax:\n\nstruct TypeA\n{\nInt32 X;\nInt32* O1;\nSByte Y;\nInt32* O2;\n};\n\nO1 and O2 are optional fields where a NULL indicates that the field is not present.\nAssume that O1 is not specified and the value of O2 is 0.\nThe CompactEncoding would be:\n{ \u0022EncodingMask\u0022: 2, \u0022X\u0022: 1, \u0022Y\u0022: 2 }\nWhere decoders would assign the default value of 0 to O2 since the mask bit is set even though the field was omitted (this is the behaviour defined for the Int32 DataType). Decoders would mark O1 as \u0027not specified\u0027.\nThe VerboseEncoding would be:\n{ \u0022X\u0022: 1, \u0022Y\u0022: 2, \u0022O2\u0022: 0 }\n\nEncoders, when allowed by the DevelopmentPlatform, should write the EncodingMask first. Decoders shall accept the EncodingMask in any position.\nCode generators should ensure that the special field names ( UaType, UaTypeId and EncodingMask) are not permitted in Structures with option field."
    },
    {
      "Id": "0d7aa681-d3af-4ba9-95c4-68b7d10a8282",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.8 Unions"
    },
    {
      "Id": "dced8289-2490-4761-aba5-cb4dcc70370f",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.8 Unions\n---\n",
      "Content": "Unions shall be encoded as JSON objects as shown in[Table 47](/\u00A7_Ref457739727).\nNote that JSON objects are unordered sets of name-value pairs. The order specified by the DataTypeDefinition is not preserved when a Union is serialized in JSON.\nTable 47- JSON Object Definition for a Union\nName\nDescription\nSwitchField\nThis field is only present in the CompactEncoding.\nThe identifier for the field in the Union which is encoded as a JSON number.\nThe valid values for this field follow the conventions defined in[5.2.8](/\u00A7_Ref35886801).\nA Union with no field specified is encoded as an empty JSON object.\n\u003CFieldName \u003E\nThe value of the field encoded using the rules that apply to the DataType.\nThe name of field in the JSON object is the name of the field in the DataTypeDefinition.\n\nFor example, instances of the union:\nstruct Union1\n{\nByte Selector;\n\n{\nInt32 A;\nDouble B;\nChar* C;\n}\nValue;\n};\n\nwould be represented in the CompactEncoding as:\n{ \u0022SwitchField\u0022:2, \u0022B\u0022:3.1415 }\n\nand would be represented in the VerboseEncoding as:\n{ \u0022B\u0022:3.1415 }"
    },
    {
      "Id": "bfc4d01a-488b-45d9-b759-371c5955a39e",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4 OPC UA JSON\n---\n",
      "Content": "5.4.9 Messages"
    },
    {
      "Id": "760da848-4f96-4dd8-838a-c46d0cebcba3",
      "Header": "Document: Part 6 - Mappings\nSection: 5.4.9 Messages\n---\n",
      "Content": "Messages are encoded ExtensionObjects(see[5.4.2.16](/\u00A7_Ref456174009))."
    },
    {
      "Id": "e0622fd9-fd8c-4772-ace3-f900b6c6bfe9",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "6 Message SecurityProtocols"
    },
    {
      "Id": "eabfa263-69ab-4df1-a0ce-2f56f2492be1",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.1 Security Handshake and Security Policies"
    },
    {
      "Id": "e7f61eb9-4d2f-4052-8d90-befbc2efd74b",
      "Header": "Document: Part 6 - Mappings\nSection: 6.1 Security Handshake and Security Policies\n---\n",
      "Content": "All SecurityProtocols shall implement the OpenSecureChannel and CloseSecureChannel services defined in[OPC 10000-4](/\u00A7UAPart4). These Services specify how to establish a SecureChannel and how to apply security to Messages exchanged over that SecureChannel. The Messages exchanged and the security algorithms applied to them are shown in[Figure 10](/\u00A7_Ref163839888).\nSecurityProtocols shall support three SecurityModes: None, Sign and SignAndEncrypt. If the SecurityMode is None then no security is used and the security handshake shown in[Figure 10](/\u00A7_Ref163839888) is not required. However, a SecurityProtocol implementation shall still maintain a logical channel and provide a unique identifier for the SecureChannel. The handshake shown also applies when using Session-less Service invocations, however the CreateSession steps are omitted."
    },
    {
      "Id": "e9447f0b-4878-4752-af1f-3a2dbd6c40cf",
      "Header": "Document: Part 6 - Mappings\nSection: 6.1 Security Handshake and Security Policies\nCaption: Figure 10 - Security handshake when Creating a Session\n---\n",
      "Content": "[image013.png](images/image013.png)"
    },
    {
      "Id": "3162ebe0-50c8-41e0-986d-409d8b5423a0",
      "Header": "Document: Part 6 - Mappings\nSection: 6.1 Security Handshake and Security Policies\n---\n",
      "Content": "Figure 10 - Security handshake when Creating a Session\nEach SecurityProtocol mapping specifies exactly how to apply the security algorithms to the Message. A set of security algorithms that shall be used together during a security handshake is called a SecurityPolicy.[OPC 10000-7](/\u00A7UAPart7) defines standard SecurityPolicies as parts of the standard Profiles which OPC UA applications are expected to support.[OPC 10000-7](/\u00A7UAPart7) also defines a URI for each standard SecurityPolicy. The latest versions of all SecurityPolicies are available in the online Profiles website.[OPC 10000-7](/\u00A7UAPart7) defines the link to this website.\nA Stack is expected to have built in knowledge of the SecurityPolicies that it supports. Applications specify the SecurityPolicy they wish to use by passing the URI to the Stack.\n[Table 48](/\u00A7_Ref130057649) defines the contents of a SecurityPolicy. Each SecurityProtocol mapping specifies how to use each of the parameters in the SecurityPolicy. A SecurityProtocol mapping may not make use of all of the parameters.\nTable 48- SecurityPolicy\nName\nDescription\nPolicyUri\nThe URI assigned to the SecurityPolicy.\nSymmetricSignatureAlgorithm\nThe symmetric signature algorithm to use.\nSymmetricEncryptionAlgorithm\nThe symmetric encryption algorithm to use.\nAsymmetricSignatureAlgorithm\nThe asymmetric signature algorithm to use.\nAsymmetricEncryptionAlgorithm\nThe asymmetric encryption algorithm to use.\nMinAsymmetricKeyLength\nThe minimum length, in bits, for an asymmetric key.\nMaxAsymmetricKeyLength\nThe maximum length, in bits, for an asymmetric key.\nKeyDerivationAlgorithm\nThe key derivation algorithm to use.\nDerivedSignatureKeyLength"
    },
    {
      "Id": "e154c084-fe47-482d-bafa-0f3cfc6816a2",
      "Header": "Document: Part 6 - Mappings\nSection: 6.1 Security Handshake and Security Policies\n---\n",
      "Content": "DerivedSignatureKeyLength\nThe length in bits of the derived key used for Message authentication.\nCertificateSignatureAlgorithm\nThe asymmetric signature algorithm used to sign certificates.\nCertificateKeyAlgorithm\nThe algorithm used to create asymmetric key pairs used with Certificates.\nEphemeralKeyAlgorithm\nThe algorithm used to create asymmetric key pairs used for EphemeralKey s.\nSecureChannelNonceLength\nThe length, in bytes, of the Nonces used when opening a SecureChannel.\nInitializationVectorLength\nThe length, in bits, of the data used to initialize the symmetric algorithm.\nSymmetricSignatureLength\nThe length, in bits, of the symmetric signature.\nLegacySequenceNumbers\nIf TRUE, the 1024 based SequenceNumber rules apply to the SecurityPolicy;\nIf FALSE, the 0 based SequenceNumber rules apply. See[6.7.2.4](/\u00A7_Ref35870750).\n\nThe KeyDerivationAlgorithm is used to create the keys used to secure Messages sent over the SecureChannel. The length of the keys used for encryption is implied by the SymmetricEncryptionAlgorithm. The length of the keys used for creating Signatures is specified by the DerivedSignatureKeyLength.\nThe MinAsymmetricKeyLength and MaxAsymmetricKeyLength are constraints that apply to all Certificates(including Issuers in the chain). In addition, the key length of issued Certificates shall be less than or equal to the key length of the issuer Certificate. See[6.2.6](/\u00A7_Ref450881358) for information on Certificate chains.\nThe CertificateKeyAlgorithm and EphemeralKeyAlgorithm are used to generate new asymmetric key pairs used with Certificates and during the SecureChannel handshake.[OPC 10000-7](/\u00A7UAPart7) specifies the algorithms that need to be supported for each"
    },
    {
      "Id": "5f0af128-f9fe-4c90-ade0-136450afaa33",
      "Header": "Document: Part 6 - Mappings\nSection: 6.1 Security Handshake and Security Policies\n---\n",
      "Content": "SecurityPolicy.\nThe CertificateSignatureAlgorithm applies the Certificate and all Issuer Certificates. If a CertificateSignatureAlgorithm allows for more than one algorithm then the algorithms are listed in order of increasing priority. Each Issuer in a chain shall have an algorithm that is the same or higher priority than any Certificate it issues.\nThe SecureChannelNonceLength specifies the length of the Nonces exchanged when establishing a SecureChannel(see[6.7.4](/\u00A7_Ref468614071))."
    },
    {
      "Id": "4f12f4f9-a76f-4c6e-a360-ff8ebd4d7fb0",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.2 Certificates"
    },
    {
      "Id": "ed503ac9-1bc1-4e05-b99d-16a7303b87e3",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2 Certificates\n---\n",
      "Content": "6.2.1 General"
    },
    {
      "Id": "a12ca5c4-7636-45de-b6d0-fffec2e1c823",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.1 General\n---\n",
      "Content": "Certificates are digitally signed data structures that contain a Public Key and the identity of a OPC UA Application. All SecurityProtocols use X.509 v3 Certificates(see[X.509 v3](/\u00A7X509)) encoded using the DER format (see[X690](/\u00A7X690)). Certificates used by OPC UA applications shall also conform to[RFC 5280](/\u00A7RFC3280) which defines a profile for X.509 v3 Certificates when they are used as part of an Internet based application.\nThe ServerCertificate and ClientCertificate parameters used in the abstract OpenSecureChannel service are instances of the ApplicationInstance Certificate DataType. Clause[6.2.2](/\u00A7_Ref181721959) describes how to create an X.509 v3 Certificate that can be used as an ApplicationInstance Certificate.\nCertificates are also used as form of UserIdentityToken which identifies a user associated with a Session. Clause[6.2.3](/\u00A7_Ref80218782) describes Certificates used as UserIdentityTokens."
    },
    {
      "Id": "d08f70db-9ae1-4fce-859a-6cb9d572924d",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2 Certificates\n---\n",
      "Content": "6.2.2 Application Instance Certificate"
    },
    {
      "Id": "face1dbf-c8d0-471e-8411-871b773d2a22",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.2 Application Instance Certificate\n---\n",
      "Content": "An Application Instance Certificate is a ByteString containing the DER encoded form (see[X690](/\u00A7X690)) of an X.509 v3 Certificate. This Certificate is issued by certifying authority and identifies an instance of an application running on a single host. The X.509 v3 fields contained in an Application Instance Certificate are described in[Table 49](/\u00A7_Ref183310394). The fields are defined completely in[RFC 5280](/\u00A7RFC3280).\n[Table 49](/\u00A7_Ref183310394) also provides a mapping from the[RFC 5280](/\u00A7RFC3280) terms to the terms used in the abstract definition of an Application Instance Certificate defined in[OPC 10000-4](/\u00A7UAPart4).\nTable 49- Application Instance Certificate\nName\n[OPC 10000-4](/\u00A7UAPart4) Parameter Name\nDescription\nApplication Instance Certificate\n\nAn X.509 v3 Certificate.\nversion\nversion\nshall be \u0022V3\u0022\nserialNumber\nserialNumber\nThe serial number assigned by the issuer.\nsignatureAlgorithm\nsignatureAlgorithm\nThe algorithm used to sign the Certificate.\nsignature\nsignature\nThe signature created by the Issuer.\nissuer\nissuer\nThe distinguished name of the Certificate used to create the signature.\nThe issuer field is completely described in[RFC 5280](/\u00A7RFC3280).\nvalidity\nvalidTo, validFrom\nWhen the Certificate becomes valid and when it expires.\nsubject\nsubject\nThe distinguished name of the application Instance.\nThe Common Name attribute shall be specified and should be the applicationName"
    },
    {
      "Id": "0128a0b7-9438-4867-b82e-757fb0d24fa0",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.2 Application Instance Certificate\n---\n",
      "Content": "applicationName or a suitable equivalent. The Organization Name attribute shall be the name of the Organization that executes the application instance. This organization is usually not the vendor of the application.\nOther attributes may be specified.\nThe subject field is completely described in[RFC 5280](/\u00A7RFC3280).\nsubjectAltName\napplicationUri,\nhostnames\nThe alternate names for the application Instance.\nShall include a uniformResourceIdentifier which is equal to the applicationUri. The URI shall be a valid URL (see[RFC 3986](/\u00A7RFC3986)) or a valid URN (see[RFC 8141](/\u00A7RFC2141)).\nServers shall specify a partial or a fully qualified dNSName or a static IPAddress which identifies the machine where the application Instance runs. Additional dNSNames may be specified if the machine has multiple names.\nThe subjectAltName field is completely described in[RFC 5280](/\u00A7RFC3280).\npublicKey\npublicKey\nThe public key associated with the Certificate.\nkeyUsage\nkeyUsage\nSpecifies how the Certificate key may be used.\nFor RSA keys, the keyUsage shall include digitalSignature, nonRepudiation, keyEncipherment and dataEncipherment.For ECC keys, the keyUsage shall include digitalSignature.Other keyUsage bits are allowed but not recommended.\nSelf-signed Certificates shall also include keyCertSign.\nextendedKeyUsage\nkeyUsage\nSpecifies additional limits on how the Certificate key may be used.\nFor RSA profiles, the extendedKeyUsage shall specify serverAuth for Servers and shall specify clientAuth for Clients. The extendedKeyUsage should also specify clientAuth for Servers.\nFor ECC profiles, serverAuth and clientAuth are optional.\nOther extendedKeyUsage bits are allowed.\nauthorityKeyIdentifier"
    },
    {
      "Id": "0280cc2c-24ab-4ce8-94ab-c7f769ae93d0",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.2 Application Instance Certificate\n---\n",
      "Content": "authorityKeyIdentifier\n(No mapping)\nProvides more information about the key used to sign the Certificate. It shall be specified for Certificates signed by a CA. It should be specified for self-signed Certificates.\nbasicConstraints\n(No mapping)\nThe basicConstraints field is completely described in[RFC 5280](/\u00A7RFC3280).\nThe cA flag Identifies whether the subject of the Certificate is a CA The pathLength specifies the maximum number of intermediate CAs in valid chains that follow this Certificate.\n\nThe basicConstraints extension shall be present and shall not be ignored. The extension shall be validated and marking the extension as critical has no effect. For backward interoperability, any error related to the critical mark produced by software libraries shall be suppressed and logged as a warning.\n\nThe cA flag shall be FALSE for any ApplicationInstance Certificate, however, TRUE shall be accepted to ensure backward interoperability when validating ApplicationInstance Certificates, if revocation checks are enabled. If revocation checks are disabled then a Certificate with the cA flag set to TRUE should not be accepted. It should be possible to disable backward interoperability in configuration.\n\nIf the cA flag is TRUE for a self-signed ApplicationInstance Certificate, then the pathLength should be 0.\nIf an application accepts an ApplicationInstance Certificate with cA flag set to TRUE, it shall write a warning to the log.\n\nNote that[RFC 6818](/\u00A7RFC6818) updates[RFC 5280](/\u00A7RFC3280) and explicitly states that self-signed Certificates used as end-entity Certificates are outside the scope of[RFC 5280](/\u00A7RFC3280). This means the requirement that the CA flag be FALSE for ApplicationInstance Certificates does not violate[RFC 5280](/\u00A7RFC3280) requirements."
    },
    {
      "Id": "b03fbff0-1889-419d-8305-213be5705db0",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.2 Application Instance Certificate\n---\n",
      "Content": "requirements."
    },
    {
      "Id": "8c75f9f1-97f2-4250-b7dc-3927626815f8",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2 Certificates\n---\n",
      "Content": "6.2.3 User Certificates"
    },
    {
      "Id": "eb1dd026-ad09-441e-b38c-e93bb545901b",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.3 User Certificates\n---\n",
      "Content": "A User Certificate is a Certificate is issued by certifying authority and identifies a user.\nThe X.509 v3 fields in a User Certificates with specific requirements are shown in[Table 50](/\u00A7_Ref80044389).\nTable 50- User Certificate\nField\nDescription\nsubject\nThe distinguished name of the User.\nThe Common Name attribute shall be specified and should be name of the user. The Organization should be provided.\nOther attributes may be specified.\nThe subject field is completely described in[RFC 5280](/\u00A7RFC3280).\nauthorityKeyIdentifier\nProvides more information about the key used to sign the Certificate. It shall be specified.\nbasicConstraints\nThe basicConstraints field is completely described in[RFC 5280](/\u00A7RFC3280).\nThe cA flag Identifies whether the subject of the Certificate is a CA The pathLength specifies the maximum depth of valid chains that include this Certificate.\nThe cA flag shall be FALSE for User Certificates.\nThe pathLength shall not be present."
    },
    {
      "Id": "a2ee52c7-1e55-4b0e-9919-117743475f95",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2 Certificates\n---\n",
      "Content": "6.2.4 Issuer (CA) Certificates"
    },
    {
      "Id": "99866c7c-331f-4d3f-a750-d2e7371f32e7",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.4 Issuer (CA) Certificates\n---\n",
      "Content": "An Issuer or CA Certificate is an X.509 v3 Certificate that identifies an authority that issues Certificates. An Issuer Certificate may identify a root CA or an intermediate CA. Certificates that identify root CAs are self-signed Certificates. Certificates that identify intermediate CAs are issued by authority identified by an intermediate CA or root CA.\nThe X.509 v3 fields in Issuer Certificates with specific requirements are shown in[Table 51](/\u00A7_Ref80216997).\nTable 51- Issuer Certificate\nField\nDescription\nsubject\nThe distinguished name of for the authority.\nThe Common Name attribute shall be specified.\nThe Organization should be provided.\nOther attributes may be specified.\nThe subject field is completely described in[RFC 5280](/\u00A7RFC3280).\nauthorityKeyIdentifier\nProvides more information about the key used to sign the Certificate. It shall be specified.\nbasicConstraints\nThe basicConstraints field is completely described in[RFC 5280](/\u00A7RFC3280).\nThe cA flag Identifies whether the subject of the Certificate is a CA The pathLength specifies the maximum depth of valid chains that include this Certificate.\nThe cA flag shall be TRUE for CA Certificates."
    },
    {
      "Id": "bb485284-0b2f-4b56-b35b-8a2fbbde8031",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2 Certificates\n---\n",
      "Content": "6.2.5 Certificate Revocation List (CRL)"
    },
    {
      "Id": "1d63b027-fe6b-4709-9be4-51a5646f8e64",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.5 Certificate Revocation List (CRL)\n---\n",
      "Content": "A Certificate Revocation List (CRL) is a ByteString containing the DER encoded form (see[X690](/\u00A7X690)) of an X.509 v3 CRL. The CRL is issued by certifying authority and contains the serial numbers of the Certificates issued by that authority which are no longer valid. All CRLs shall have the extension defined in[Table 49](/\u00A7_Ref183310394). The extension is defined completely in[RFC 5280](/\u00A7RFC3280).\nTable 52- Certificate Revocation List Extensions\nExtension\nDescription\nauthorityKeyIdentifier\nProvides more information about the key used to sign the CRL."
    },
    {
      "Id": "b0ddd36d-5a2c-4c5a-a225-2a6b9ccf7c51",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2 Certificates\n---\n",
      "Content": "6.2.6 Certificate Chains"
    },
    {
      "Id": "9308f3a9-26b7-4775-8fc2-99bca699c947",
      "Header": "Document: Part 6 - Mappings\nSection: 6.2.6 Certificate Chains\n---\n",
      "Content": "Any X.509 v3 Certificate may be signed by CA which means that validating the signature requires access to the X.509 v3 Certificate belonging to the signing CA. Whenever an application validates a Certificate(see[OPC 10000-4](/\u00A7UAPart4)) it shall recursively build a chain of Certificates by finding the issuer Certificate, validating the Certificate and then repeat the process for the issuer Certificate. The chain ends with a self-signed Certificate.\nThe number of CAs used in a system should be small so it is common to install the necessary CAs on each machine with an OPC UA application. However, applications have the option of including a partial or complete chain whenever they pass a Certificate. This includes GetEndpoints, SecureChannel negotiation and during the CreateSession/ ActivateSession handshake.\nAll OPC UA applications shall accept partial or complete chains in any field that contains a DER encoded Certificate.\nChains are stored in a ByteString by simply appending the DER encoded form of the Certificates. The first Certificate shall be the end Certificate followed by its issuer. If the root CA is sent as part of the chain, it is last Certificate appended to the ByteString.\nChains are parsed by extracting the length of each Certificate from the DER encoding. For Certificates with lengths less than 65535 bytes it is an MSB encoded UInt16 starting at the 3 rd byte."
    },
    {
      "Id": "3ec934f2-ac19-4579-b124-01804870fa87",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.3 Time synchronization"
    },
    {
      "Id": "3aaa5b69-ae19-4ce3-810c-75036bb65ea1",
      "Header": "Document: Part 6 - Mappings\nSection: 6.3 Time synchronization\n---\n",
      "Content": "All SecurityProtocols require that system clocks on communicating machines be reasonably synchronized in order to check the expiry times for Certificates or CRLs. In addition, incorrect Timestamps on Data and Events could create interoperability issues.\nThe Network Time Protocol ([NTP](/\u00A7NTP)) provides a standard way to synchronize a machine clock with a time server on the network. Systems running on a machine with a full featured operating system like Windows or Linux will already support NTP or an equivalent. Devices running embedded operating systems should support NTP.\nIf a device operating system cannot practically support NTP then an OPC UA application can use the Timestamps in the ResponseHeader(see[OPC 10000-4](/\u00A7UAPart4)) to synchronize its clock. In this scenario, the OPC UA application will have to know the URL for a Discovery Server on a machine known to have the correct time. The OPC UA application or a separate background utility would call the FindServers Service and set its clock to the time specified in the ResponseHeader. This process will need to be repeated periodically because clocks can drift over time.\nApplications should log possible time synchronization errors. For example, Certificates or CRLs with ValidFrom times in the future could indicate a time synchronization issue."
    },
    {
      "Id": "10c59ba7-e251-4671-80b1-ef1af44889b2",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.4 UTC and International Atomic Time (TAI)"
    },
    {
      "Id": "e5b23538-4271-428b-acab-c73f071a636d",
      "Header": "Document: Part 6 - Mappings\nSection: 6.4 UTC and International Atomic Time (TAI)\n---\n",
      "Content": "All times in OPC UA are in UTC, however, UTC can include discontinuities due to leap seconds or repeating seconds added to deal with variations in the earth\u0027s orbit and rotation. For this reason, some Servers will use International Atomic Time (TAI) for internal calculations. These Servers shall convert DateTime values to UTC before exchanging them with other applications."
    },
    {
      "Id": "9ee7cbf7-a212-4058-b3c8-2438a0b7d35a",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.5 Issued User Identity Tokens"
    },
    {
      "Id": "c3edb445-075b-415f-ad85-a02326ad64d8",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5 Issued User Identity Tokens\n---\n",
      "Content": "6.5.1 Kerberos"
    },
    {
      "Id": "7b6108d2-4349-4580-b692-55ef6dfd52b2",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.1 Kerberos\n---\n",
      "Content": "Note: Deprecated in Version 1.05."
    },
    {
      "Id": "281d4da0-2485-476b-9ceb-89830437c01c",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5 Issued User Identity Tokens\n---\n",
      "Content": "6.5.2 JSON Web Token (JWT)"
    },
    {
      "Id": "0ae23375-7526-4020-b322-c198a14ca847",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2 JSON Web Token (JWT)\n---\n",
      "Content": "6.5.2.1 General"
    },
    {
      "Id": "fa280197-f50f-4a04-ac3f-1b19febcc098",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2.1 General\n---\n",
      "Content": "JSON Web Token (JWT) UserIdentityTokens can be passed to the Server using the IssuedIdentityToken. The body of the token is a string that contains the JWT as defined in[RFC 7519](/\u00A7RFC7519)."
    },
    {
      "Id": "e9802e42-1b8a-49a6-a142-3f29040e9eaa",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2 JSON Web Token (JWT)\n---\n",
      "Content": "6.5.2.2 User Token Policy"
    },
    {
      "Id": "fd5c3078-43b1-418f-8255-4927aaca60bb",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2.2 User Token Policy\n---\n",
      "Content": "Servers that support JWT authentication shall provide a UserTokenPolicy which specifies the Authorization Service which provides the token and the parameters needed to access that service. The parameters are specified by a JSON object specified as the issuerEndpointUrl. The contents of this JSON object are described in[Table 54](/\u00A7_Ref472362695). The general UserTokenPolicy settings for JWT are defined in[Table 53](/\u00A7_Ref472630237).\nTable 53- JWT UserTokenPolicy\nName\nDescription\ntokenType\nISSUEDTOKEN_3\nissuedTokenType\n[http://opcfoundation.org/UA/UserToken#JWT](http://opcfoundation.org/UA/UserToken)\nissuerEndpointUrl\nFor JWTs this is a JSON object with fields defined in[Table 54](/\u00A7_Ref472362695).\n\nTable 54- JWT IssuerEndpointUrl Definition\nName\nType\nRequired\nDescription\nIssuerEndpointUrl\nJSON object\nYes\nSpecifies the parameters for a JWT UserIdentityToken.\nua:resourceId\nString\nYes\nThe URI identifying the Server to the Authorization Service.\nThe default value is the Server\u0027s ApplicationUri.\nua:authorityUrl\nString\nYes\nThe base URL for the Authorization Service.\nThis URL may be used to discover additional information about the authority.\nThis field is equivalent to the \u0022issuer\u0022 defined in[OpenID-Discovery](/\u00A7OpenIDDiscovery).\nua:authorityProfileUri\nString\nYes\nThe profile that defines the interactions with the authority.\nThe default URI is \u0022http://opcfoundation.org/UA/Authorization#OPCUA\u0022.\nA set of possible authorities are in the Profile:"
    },
    {
      "Id": "fcaa7123-c25e-44f0-b3f5-43b002758a4a",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2.2 User Token Policy\n---\n",
      "Content": "Profile:[http://opcfoundation.org/UA-Profile/Security/UserToken/Server/JsonWebToken](http://opcfoundation.org/UA-Profile/Security/UserToken/Server/JsonWebToken)\nua:tokenEndpoint\nString\nDepends on authorityProfileUri\nA path relative to the base URL used to request Access Tokens.\nIf the authorityProfileUri is OPCUA, then this is the NodeId of the AuthorizationService Object encoded as described in[5.4.2.10](/\u00A7_Ref456142221).\nThis field is equivalent to the \u0022token_endpoint\u0022 defined in[OpenID-Discovery](/\u00A7OpenIDDiscovery).\nua:authorizationEndpoint\nString\nNo\nA path relative to the base URL used to validate user credentials.\nIf the authorityProfileUri is OPCUA, then this is the NodeId of the UserTokenProfile Property of the AuthorizationService Object encoded as described in[5.4.2.10](/\u00A7_Ref456142221).\nThis field is equivalent to the \u0022authorization_endpoint\u0022 defined in[OpenID-Discovery](/\u00A7OpenIDDiscovery).\nua:requestTypes\nJSON array\nString\nNo\nThe list of request types supported by the authority.\nThe possible values are described in[6.5.3.2](/\u00A7_Ref80222022) to[6.5.3.4](/\u00A7_Ref80222025).\nIf not specified the default is \u0022authorization_code\u0022.\nua:scopes\nJSON array\nString\nNo\nA list of Scopes that are understood by the Server.\nIf not specified, the Client may be able to access any Scope supported by the Authorization Service.\nThis field is equivalent to the \u0022scopes_supported\u0022 defined in OpenID-Discovery."
    },
    {
      "Id": "13cd2197-8740-4a00-96fa-c75e47d89873",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2.2 User Token Policy\n---\n",
      "Content": ""
    },
    {
      "Id": "f9049116-4235-47d7-a737-145706d9b3e1",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2 JSON Web Token (JWT)\n---\n",
      "Content": "6.5.2.3 Access Tokens"
    },
    {
      "Id": "d135a517-c3b1-47c8-bd1a-3dd3f4fe301d",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2.3 Access Tokens\n---\n",
      "Content": "The JWT supports signatures using asymmetric cryptography which implies that Servers which accept the Access Token must have access to the Certificate used by the Authorization Service.\nAll Access Tokens shall have a signature created by the token issuer.\nAccess Tokens expire and all Servers should revoke any privileges granted to the Session when the Access Token expires. If the Server allows for anonymous users, the Server may allow the Session to stay open but treat it as an anonymous user. If the Server does not allow anonymous users, it should close the Session immediately.\nClients know when the Access Token will expire and should request a new Access Token and call ActivateSession before the old Access Token expires.\nThe JWT format allows the Authorization Service to insert any number of fields. The mandatory fields are defined in[RFC 7519](/\u00A7RFC7519). Some additional fields are defined in[Table 55](/\u00A7_Ref198674147).\nTable 55- JWT Access Token Claims\nName\nJSON Type\nRequired\nDescription\nsub\nstring\nYes\nThe subject for the token.\nThis is the equivalent of a UserName or an X509 subjectName.\nIf the field \u0022iss\u0022 is not present, it shall be a globally unique identifier. If \u0022iss\u0022 is present, it shall be unique within the context of the \u0022iss\u0022.\niss\nstring\nNo\nThe URI of the issuer.\nFor the authorityProfileUri \u0022http://opcfoundation.org/UA/Authorization#OPCUA\u0022 it shall be the ServiceUri of the Authorization Service(see[OPC 10000-12](/\u00A7UAPart12)).\naud\nstring\nYes\nShall be the resourceId specified in the UserTokenPolicy(see[6.5.2.2](/\u00A7_Ref209705948)). This is usually the"
    },
    {
      "Id": "c4bb74ee-3d6b-43e4-ba46-2498eafa0f04",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.2.3 Access Tokens\n---\n",
      "Content": "). This is usually the Server ApplicationUri.\nexp\nnumber\nYes\nThe expiration time of the token. It shall be checked before accepting the token.\ngroups\narray\nNo\nA list of groups which are assigned to the subject.\nUsually, a list of unique identifiers for specific security groups.\nFor example, Azure AD user account groups may be returned in this claim.\nroles\narray\nNo\nA list of roles which are assigned to the subject.\nRoles apply to the requestor and describe what the requestor can do with the resource.\nRoles are list of unique names for roles known to the Authorization Service.\nThese values are typically mapped to the Roles defined in[OPC 10000-3](/\u00A7UAPart3) using the identity mappings defined in[OPC 10000-18](/\u00A7UAPart18).\nnbf\nnumber\nNo\nThe time when the token becomes valid. If present, it shall be checked before accepting the token.\ncnf\nobject\nNo\nThe thumbprint of the Certificate which shall be used with the token. If present, the Server shall not accept a token unless the SecureChannel has been created with the Certificate identified by this field.\nThe field is a JSON object with a single \u0022x5t#S256\u0022 field which specifies the thumbprint of the Certificate. See[RFC 8705](/\u00A7RFC8705)."
    },
    {
      "Id": "8e50b871-da4f-472c-833a-9c6d08855a01",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5 Issued User Identity Tokens\n---\n",
      "Content": "6.5.3 OAuth2"
    },
    {
      "Id": "e28ad8c1-7394-4eb9-b27c-38dbacfdc0ba",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3 OAuth2\n---\n",
      "Content": "6.5.3.1 General"
    },
    {
      "Id": "d57d29dc-ebac-4d85-b434-c5db3e6540cc",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3.1 General\n---\n",
      "Content": "The OAuth2 Authorization Framework (see[RFC 6749](/\u00A7RFC6749)) provides a web-based mechanism to request claims-based Access Tokens from an Authorization Service(AS) that is supported by many major companies providing cloud infrastructure. These Access Tokens are passed to a Server by a Client in a UserIdentityToken as described in[OPC 10000-4](/\u00A7UAPart4).\nThe OpenID Connect specification (see[OpenID](/\u00A7OpenID)) builds on the OAuth2 specification by defining the contents of the Access Tokens more strictly.\nThe OAuth2 specification supports a number of use cases (called \u0027flows\u0027) to handle different application requirements. The use cases that are relevant to OPC UA are discussed below."
    },
    {
      "Id": "1819df87-f660-4376-b23c-ce8d75e8f6b4",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3 OAuth2\n---\n",
      "Content": "6.5.3.2 Authorization Code"
    },
    {
      "Id": "4af6ca16-c31a-4a45-8cb7-da33bc10a27b",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3.2 Authorization Code\n---\n",
      "Content": "The authorization code flow is available to Clients which allow interaction with a human user. The Client application displays a window with a web browser which sends an HTTP GET to the Identity Provider. When the human user enters credentials that the Identity Provider validates the Identity Provider returns an authorization code which is passed to the Authorization Service. The Authorization Service validates the code and returns an Access Token to the Client.\nThe complete flow is described in[RFC 6749](/\u00A7RFC6749), 4.1.\nA requestType of \u0022authorization_code\u0022 in the UserTokenPolicy(see[6.5.2](/\u00A7_Ref473652750)) means the Authorization Service supports the authorization code flow."
    },
    {
      "Id": "fd43d3da-a899-4cbf-a009-d435cbf6e252",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3 OAuth2\n---\n",
      "Content": "6.5.3.3 Refresh Token"
    },
    {
      "Id": "66b3b7a6-6219-496b-bd8d-4fa98d611748",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3.3 Refresh Token\n---\n",
      "Content": "The refresh token flow applies when a Client application has access to a refresh token returned in a previous response to an authorization code request. The refresh token allows applications to skip the step that requires human interaction with the Identity Provider. This flow is initiated when the Client sends the refresh token to Authorization Service which validates it and returns an Access Token. A Client that saves the refresh token for later use shall use encryption or other means to ensure the refresh token cannot be accessed by unauthorized parties.\nThe complete flow is described in[RFC 6749](/\u00A7RFC6749), 6.\nA requestType is not defined since support for refresh token is determined by checking the response to an authorization code request."
    },
    {
      "Id": "dafe9afc-9a68-4c13-92a1-86c44b0d8f00",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3 OAuth2\n---\n",
      "Content": "6.5.3.4 Client Credentials"
    },
    {
      "Id": "51831abf-92db-4210-b3bf-36677167d1d9",
      "Header": "Document: Part 6 - Mappings\nSection: 6.5.3.4 Client Credentials\n---\n",
      "Content": "The client credentials flow applies when a Client application cannot prompt a human user for input. This flow requires a secret know to the Authorization Service which the Client application can protect. This flow is initiated when the Client sends the client_secret to Authorization Service which validates it and returns an Access Token.\nThe complete flow is described in[RFC 6749](/\u00A7RFC6749), 4.4.\nA requestType of \u0022client_credentials\u0022 in the UserTokenPolicy(see[6.5.2](/\u00A7_Ref473652750)) means the Authorization Service supports the client credentials flow."
    },
    {
      "Id": "d1fd3a00-6555-4ebe-8c4f-0c633ec43a12",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.6 WS Secure Conversation"
    },
    {
      "Id": "dffb1654-6dd3-4d5b-ba4f-f19ef56b179a",
      "Header": "Document: Part 6 - Mappings\nSection: 6.6 WS Secure Conversation\n---\n",
      "Content": "Note: Deprecated in Version 1.03."
    },
    {
      "Id": "50790fad-82ab-4905-b20d-bd809ee2a117",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.7 OPC UA Secure Conversation"
    },
    {
      "Id": "31962313-ac39-4c13-a8b7-02f688f5ad2e",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7 OPC UA Secure Conversation\n---\n",
      "Content": "6.7.1 Overview"
    },
    {
      "Id": "0413f34c-d956-490e-ad0d-98caacc0541e",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.1 Overview\n---\n",
      "Content": "OPC UA Secure Conversation (UASC) allows secure communication using binary encoded Messages.\nUASC is designed to operate with different TransportProtocols that may have limited buffer sizes. For this reason, OPC UA Secure Conversation will break OPC UA Messages into several pieces (called \u0027 MessageChunks\u0027) that are smaller than the buffer size allowed by the TransportProtocol. UASC requires a TransportProtocol buffer size that is at least 8 192 bytes when using RSA based Asymmetric Cryptography. This minimum buffer size drops to 1024 when using ECC based Asymmetric Cryptography(see[6.8](/\u00A7_Ref201149240)) is supported.\nAll security is applied to individual MessageChunks and not the entire OPC UA Message. A Stack that implements UASC is responsible for verifying the security on each MessageChunk received and reconstructing the original OPC UA Message.\nAll MessageChunks will have a 4-byte sequence assigned to them. These sequence numbers are used to detect and prevent replay attacks.\nUASC requires a TransportProtocol that will preserve the order of MessageChunks, however, a UASC implementation does not necessarily process the Messages in the order that they were received."
    },
    {
      "Id": "1fa259f0-e571-4c80-b622-de8d9338db47",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7 OPC UA Secure Conversation\n---\n",
      "Content": "6.7.2 MessageChunkstructure"
    },
    {
      "Id": "2196108d-dcb5-4626-a7fc-36b855adaaeb",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2 MessageChunkstructure\n---\n",
      "Content": "6.7.2.1 Overview"
    },
    {
      "Id": "97bd8172-c2be-405e-94c8-3d0ec68d00da",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.1 Overview\n---\n",
      "Content": "The structure of the Message depends on whether the SecurityPolicy requires an algorithm that combines encryption and authentication (e.g. Authenticated Encryption algorithms) used or if it requires separate algorithms for each operation ( Unauthenticated Encryption algorithms).\n[Figure 11](/\u00A7_Ref164005549) shows the structure of a MessageChunk and how security is applied to the Message when using Unauthenticated Encryption algorithms. For these SecurityPolicies any padding is appended to the message before appending the Signature."
    },
    {
      "Id": "a3a14c7f-2b38-4fbf-997c-318d2544ea56",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.1 Overview\nCaption: Figure 11 - MessageChunk for Unauthenticated Encryption Algorithms\n---\n",
      "Content": "[image014.png](images/image014.png)"
    },
    {
      "Id": "64f93003-b3a3-495d-afec-dec764f59f89",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.1 Overview\n---\n",
      "Content": "Figure 11 - MessageChunk for Unauthenticated Encryption Algorithms\n[Figure 12](/\u00A7_Ref11086559) shows the structure of a MessageChunk and how security is applied to the Message when using Authenticated Encryption algorithms. For these SecurityPolicies the Signature is calculated during encryption and appended after the encrypted data. Padding is not needed."
    },
    {
      "Id": "329a6cd6-4cc8-4a6a-9e33-5747ff879d52",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.1 Overview\nCaption: Figure 12 - MessageChunk for Authenticated Encryption Algorithms\n---\n",
      "Content": "[image015.png](images/image015.png)"
    },
    {
      "Id": "57e60d61-de9b-4dcf-be9c-2564bbdf8e38",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.1 Overview\n---\n",
      "Content": "Figure 12 - MessageChunk for Authenticated Encryption Algorithms"
    },
    {
      "Id": "0b0523c0-c446-4523-b01c-54e70509e3d6",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2 MessageChunkstructure\n---\n",
      "Content": "6.7.2.2 Message Header"
    },
    {
      "Id": "8b048ea3-30ef-440f-b04d-cf0e40a1bfe5",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.2 Message Header\n---\n",
      "Content": "Every MessageChunk has a Message header with the fields defined in[Table 56](/\u00A7_Ref163954977).\nTable 56- OPC UA Secure Conversation Message Header\nName\nData Type\nDescription\nMessageType\nByte [3]\nA three byte ASCII code that identifies the Message type.\nThe following values are defined at this time:\nMSG A Message secured with the keys associated with a channel.\nOPN OpenSecureChannel Message.\nCLO CloseSecureChannel Message.\nIsFinal\nByte\nA one byte ASCII code that indicates whether the MessageChunk is the final chunk in a Message.\nThe following values are defined at this time:\nC An intermediate chunk.\nF The final chunk.\nA The final chunk (used when an error occurred and the Message is aborted).\nThis field is only meaningful for MessageType of \u0027MSG\u0027\nThis field is always \u0027F\u0027 for other MessageTypes.\nMessageSize\nUInt32\nThe length of the MessageChunk, in bytes.\nThe length starts from the beginning of the MessageType field.\nSecureChannelId\nUInt32\nA unique identifier for the SecureChannel assigned by the Server.\nIf a Server receives a SecureChannelId which it does not recognize it shall return an appropriate transport layer error.\nWhen a Server starts the first SecureChannelId used should be a value that is likely to be unique after each restart. This ensures that a Server restart does not cause previously connected Clients to accidently \u0027reuse\u0027 SecureChannels that did not belong to them."
    },
    {
      "Id": "c2679609-0578-4b5a-8f07-e2cc1e113bc1",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2 MessageChunkstructure\n---\n",
      "Content": "6.7.2.3 Security Header"
    },
    {
      "Id": "f2f65cb0-81c5-4067-8619-864787f2176c",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.3 Security Header\n---\n",
      "Content": "The Message header is followed by a security header which specifies what cryptography operations have been applied to the Message. There are two versions of the security header which depend on the type of security applied to the Message. The security header used for asymmetric algorithms is defined in[Table 57](/\u00A7_Ref163971577). Asymmetric algorithms are used to secure the OpenSecureChannel Messages.[PKCS #1](/\u00A7Pkcs1) defines a set of asymmetric algorithms that may be used by UASC implementations. The AsymmetricKeyWrapAlgorithm element of the SecurityPolicy structure defined in[Table 48](/\u00A7_Ref130057649) is not used by UASC implementations.\nTable 57- Asymmetric algorithm Security header\nName\nData Type\nDescription\nSecurityPolicyUriLength\nInt32\nThe length of the SecurityPolicyUri in bytes.\nThis value shall not exceed 255 bytes.\nIf a URI is not specified this value may be 0 or -1.\nOther negative values are invalid.\nSecurityPolicyUri\nByte []\nThe URI of the Security Policy used to secure the Message.\nThis field is encoded as a[UTF-8](/\u00A7UTF8) string without a null terminator.\nSenderCertificateLength\nInt32\nThe length of the SenderCertificate in bytes.\nThis value shall not exceed MaxSenderCertificateSize bytes.\nIf a certificate is not specified this value may be 0 or -1.\nOther negative values are invalid.\nSenderCertificate\nByte []\nThe X.509 v3 Certificate assigned to the sending application Instance.\nThis is a DER encoded blob.\nThe structure of an X.509 v3 Certificate is defined in X.509 v3.\nThe DER format for a Certificate is defined in[X690](/\u00A7X690)\nThis indicates what"
    },
    {
      "Id": "b63c947d-92c6-4bbb-9f6b-b7875b439b33",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.3 Security Header\n---\n",
      "Content": "This indicates what Private Key was used to sign the MessageChunk.\nThe Stack shall close the channel and report an error to the application if the SenderCertificate is too large for the buffer size supported by the transport layer.\nThis field shall be null if the Message is not signed.\nIf the Certificate is signed by a CA, the DER encoded CA Certificate may be appended after the Certificate in the byte array. If the CA Certificate is also signed by another CA this process is repeated until the entire Certificate chain is in the buffer or if MaxSenderCertificateSize limit is reached (the process stops after the last whole Certificate that can be added without exceeding the MaxSenderCertificateSize limit).\nReceivers can extract the Certificates from the byte array by using the Certificate size contained in DER header (see[X.509 v3](/\u00A7X509)).\nReceivers that do not handle Certificate chains shall ignore the extra bytes.\nReceiverCertificateThumbprintLength\nInt32\nThe length of the ReceiverCertificateThumbprint in bytes.\nWhen using RSA Public Keys:\nIf encrypted, the value of this field is 20 bytes.\nIf not encrypted the value may be 0 or -1.\nWhen using ECC Public Keys:\nThe value of this field is 20 bytes.\nOther negative values are invalid.\nReceiverCertificateThumbprint\nByte []\nThe thumbprint of the X.509 v3 Certificate assigned to the receiving application Instance.\nThe thumbprint is the CertificateDigest of the DER encoded form of the Certificate.\nWhen using RSA Public Keys it indicates which Public Key was used to encrypt the MessageChunk.\nWhen using ECC Public Keys it indicates the intended recipient of the MessageChunk.\n\nThe receiver shall close the communication channel if any of the fields in the security header have invalid lengths.\nThe SenderCertificate, including"
    },
    {
      "Id": "462cd48e-6b19-4321-85f4-64882b8f7905",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.3 Security Header\n---\n",
      "Content": "The SenderCertificate, including any chains, shall be small enough to fit into a single MessageChunk and leave room for at least one byte of body information. The maximum size for the SenderCertificate can be calculated with this formula:\nMaxSenderCertificateSize =\nMessageChunkSize -\n12 -// Header size\n4 -// SecurityPolicyUriLength\nSecurityPolicyUri -// UTF-8 encoded string\n4 -// SenderCertificateLength\n4 -// ReceiverCertificateThumbprintLength\n20 -// ReceiverCertificateThumbprint\n8 -// SequenceHeader size\n1 -// Minimum body size\n1 -// PaddingSize if present\nPadding -// Padding if present\nExtraPadding -// ExtraPadding if present\nAsymmetricSignatureSize// If present\nThe MessageChunkSize depends on the transport protocol but shall be at least 8192 bytes. The AsymmetricSignatureSize depends on the number of bits in the public key for the SenderCertificate. The Int32FieldLength is the length of an encoded Int32 value and it is always 4 bytes.\nThe security header used for symmetric algorithms defined in[Table 58](/\u00A7_Ref163971907). Symmetric algorithms are used to secure all Messages other than the OpenSecureChannel Messages.[FIPS 197](/\u00A7Fips197) define symmetric encryption algorithms that UASC implementations may use.[FIPS 180-4](/\u00A7Fips180) and[HMAC](/\u00A7Hmac) define some symmetric signature algorithms.\nTable 58- Symmetric algorithm Security header\nName\nData Type\nDescription\nTokenId\nUInt32\nA unique identifier for the SecureChannel SecurityToken used to secure the Message.\nThis identifier is returned by the Server in an OpenSecureChannel response Message. If a Server"
    },
    {
      "Id": "5f93145c-c23c-4fb3-85f3-c391aca8876e",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.3 Security Header\n---\n",
      "Content": "Message. If a Server receives a TokenId which it does not recognize it shall return an appropriate transport layer error."
    },
    {
      "Id": "19067017-b8f8-43f6-9b6f-1fdc3654fed9",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2 MessageChunkstructure\n---\n",
      "Content": "6.7.2.4 Sequence Header"
    },
    {
      "Id": "3d806b01-cd2d-4466-8a94-3c25629bd222",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.4 Sequence Header\n---\n",
      "Content": "The security header is always followed by the sequence header which is defined in[Table 59](/\u00A7_Ref171766345). The sequence header ensures that the first encrypted block of every Message sent over a channel will start with different data.\nTable 59- Sequence header\nName\nData Type\nDescription\nSequenceNumber\nUInt32\nA monotonically increasing sequence number assigned by the sender to each MessageChunk sent over the SecureChannel.\nRequestId\nUInt32\nAn identifier assigned by the Client to OPC UA request Message. All MessageChunks for the request and the associated response use the same identifier.\n\nA SequenceNumber may not be reused for any TokenId. The SecurityToken lifetime shall be short enough to ensure that this never happens; however, if it does the receiver shall treat it as a transport error and force a reconnect. The SequenceNumber does not reset when a new TokenId is issued and it shall be incremented by exactly one for each MessageChunk sent.\nSecurityPolicies with LegacySequenceNumbers set to TRUE, the SequenceNumber shall monotonically increase for all Messages and shall not wrap around until it is greater than 4 294 966 271 (UInt32.MaxValue - 1024). The first number after the wrap around shall be less than 1024.\nSecurityPolicies with LegacySequenceNumbers set to FALSE, the SequenceNumber shall start at 0 and monotonically increase for all Messages and shall not wrap around until it is equal to 4294967295 (UInt32.MaxValue). The first number after the wrap around shall be 0.\nSome applications will find it takes time to validate the OpenSecureChannel Requests and Responses used to renew a TokenId. In these situations, the receiver may assume the SequenceNumber is correct which allows it to process subsequent messages secured with the existing TokenId before the"
    },
    {
      "Id": "2a604469-0e27-49c4-a0e9-f5bef069a13d",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.4 Sequence Header\n---\n",
      "Content": "TokenId before the OpenSecureChannel Message is validated. When processing of the OpenSecureChannel Message completes, the receiver checks the SequenceNumber and closes the SecureChannel if it is incorrect.\nThe sequence header is followed by the Message body which is encoded with the OPC UA Binary encoding as described in[5.2.9](/\u00A7_Ref424493954). The body may be split across multiple MessageChunks."
    },
    {
      "Id": "d5fd1975-9680-44a3-b14b-71a85a085066",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2 MessageChunkstructure\n---\n",
      "Content": "6.7.2.5 Message Footer"
    },
    {
      "Id": "315cae18-fd1f-44d5-ab56-e899af0da7f2",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.5 Message Footer\n---\n",
      "Content": "6.7.2.5.1 Unauthenticated Encryption Algorithms"
    },
    {
      "Id": "5ab8ce8e-1a15-4cc5-aa39-b81706234660",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.5.1 Unauthenticated Encryption Algorithms\n---\n",
      "Content": "Each MessageChunk when using SecurityPolicies with an Unauthenticated Encryption algorithms have a footer with the fields defined in[Table 60](/\u00A7_Ref35524563).\nTable 60- Message Footer for Unauthenticated Encryption Algorithms\nName\nData Type\nDescription\nPaddingSize\nByte\nThe number of padding bytes (not including the byte for the PaddingSize).\nPadding\nOctetString\nPadding added to the end of the Message to ensure length of the data to encrypt is an integer multiple of the encryption block size.\nThe value of each byte of the padding is equal to PaddingSize.\nExtraPaddingSize\nByte\nThe most significant byte of a two-byte integer used to specify the padding size when the key used to encrypt the message chunk is larger than 2048 bits. This field is omitted if the key length is less than or equal to 2048 bits.\nSignature\nOctetString\nThe signature for the MessageChunk.\nThe signature includes the headers, all Message data, the PaddingSize and the Padding.\nThe signature is encoded as sequence of Bytes with a length specified by the SecurityPolicy.\n\nThe formula to calculate the amount of padding depends on the amount of data that needs to be sent (called BytesToWrite). The sender shall first calculate the maximum amount of space available in the MessageChunk(called MaxBodySize) using the following formula:\nMaxBodySize = PlainTextBlockSize * Floor ((MessageChunkSize- MessageHeaderSize- SecurityHeaderSize- SignatureSize - 1)/CipherTextBlockSize) - SequenceHeaderSize;\nThe MessageHeaderSize is 12 bytes and the SecurityHeader size depends on whether symmetric or asymmetric cryptography is used. The SequenceHeaderSize is always 8 bytes.\nDuring encryption a block with a size equal to PlainTextBlockSize"
    },
    {
      "Id": "4373d702-3f14-4e83-a3fb-931bac6c74ea",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.5.1 Unauthenticated Encryption Algorithms\n---\n",
      "Content": "PlainTextBlockSize is processed to produce a block with size equal to CipherTextBlockSize. These values depend on the encryption algorithm and may be the same.\nThe OPC UA Message can fit into a single chunk if BytesToWrite is less than or equal to the MaxBodySize. In this case the PaddingSize is calculated with this formula:\nPaddingSize = PlainTextBlockSize -\n((BytesToWrite \u002B SignatureSize \u002B 1) % PlainTextBlockSize);\nIf the BytesToWrite is greater than MaxBodySize the sender shall write MaxBodySize bytes with a PaddingSize of 0. The remaining BytesToWrite- MaxBodySize bytes shall be sent in subsequent MessageChunks.\nThe PaddingSize and Padding fields are not present if the MessageChunk is not encrypted.\nThe Signature field is not present if the MessageChunk is not signed."
    },
    {
      "Id": "06fc3f6d-3664-49c2-bc0a-e305fe21a9cc",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.5 Message Footer\n---\n",
      "Content": "6.7.2.5.2 Authenticated Encryption Algorithms"
    },
    {
      "Id": "11faf95e-75b8-416c-9854-f974199e8668",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.2.5.2 Authenticated Encryption Algorithms\n---\n",
      "Content": "Each MessageChunk when using SecurityPolicies with an Authenticated Encryption algorithms have a footer with the fields defined in[Table 61](/\u00A7_Ref35524528).\nTable 61- Message Footer for Authenticated Encryption Algorithms\nName\nData Type\nDescription\nSignature\nOctetString\nThe signature for the MessageChunk.\nThe signature includes the headers and all Message data.\nThe signature is encoded as sequence of Bytes with a length specified by the SecurityPolicy."
    },
    {
      "Id": "e12e246c-02a1-4622-81fb-a03b89ce1c9f",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7 OPC UA Secure Conversation\n---\n",
      "Content": "6.7.3 MessageChunks and error handling"
    },
    {
      "Id": "c263d601-6ccd-4c23-974a-b4a77572f162",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.3 MessageChunks and error handling\n---\n",
      "Content": "MessageChunks are sent as they are encoded. MessageChunks belonging to the same Message shall be sent sequentially. If an error occurs creating a MessageChunk then the sender shall send a final MessageChunk to the receiver that tells the receiver that an error occurred and that it should discard the previous chunks. The sender indicates that the MessageChunk contains an error by setting the IsFinal flag to \u0027A\u0027 (for Abort).[Table 62](/\u00A7_Ref187931392) specifies the contents of the Message abort MessageChunk.\nTable 62- OPC UA Secure Conversation Message abort body\nName\nData Type\nDescription\nError\nUInt32\nThe numeric code for the error.\nPossible values are listed in[Table 77](/\u00A7_Ref164020643).\nReason\nString\nA more verbose description of the error.\nThis string shall not be more than 4096 bytes.\nA Client shall ignore strings that are longer than this.\nAny security related information shall not be returned. This includes any indication of the reason that caused Bad_SecurityChecksFailed to be returned.\n\nThe receiver shall check the security on the abort MessageChunk before processing it. If everything is ok, then the receiver shall ignore the Message but shall not close the SecureChannel. The Client shall report the error back to the application as StatusCode for the request. If the Client is the sender, then it shall report the error without waiting for a response from the Server."
    },
    {
      "Id": "6b887dfb-c20b-4b7c-9e6a-b35eb7a846d2",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7 OPC UA Secure Conversation\n---\n",
      "Content": "6.7.4 Establishing a SecureChannel"
    },
    {
      "Id": "1b5925a6-9867-4750-8037-cc768a17bc99",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.4 Establishing a SecureChannel\n---\n",
      "Content": "Most Messages require a SecureChannel to be established. A Client does this by sending an OpenSecureChannel request to the Server. The Server shall validate the Message and the ClientCertificate and return an OpenSecureChannel response. Some of the parameters defined for the OpenSecureChannel service are specified in the security header (see[6.7.2](/\u00A7_Ref164007251)) instead of the body of the Message.[Table 63](/\u00A7_Ref157834565) lists the parameters that appear in the body of the Message.\nNote that[OPC 10000-4](/\u00A7UAPart4) is an abstract specification which defines interfaces that can work with any protocol. This document provides a concrete implementation for specific protocols. This document is the normative reference for all protocols and takes precedence if there are differences with[OPC 10000-4](/\u00A7UAPart4).\nTable 63- OPC UA Secure Conversation OpenSecureChannel Service\nName\nData Type\nRequest\n\nRequestHeader\nRequestHeader\nClientProtocolVersion\nUInt32\nRequestType\nSecurityTokenRequestType\nSecurityMode\nMessageSecurityMode\nClientNonce\nByteString\nRequestedLifetime\nUInt32\n\n\nResponse\n\nResponseHeader\nResponseHeader\nServerProtocolVersion\nUInt32\nSecurityToken\nChannelSecurityToken\nSecureChannelId\nUInt32\nTokenId\nUInt32\nCreatedAt\nUtcTime\nRevisedLifetime\nUInt32\nServerNonce\nByteString\n\nThe ClientProtocolVersion and ServerProtocolVersion parameters are not defined in[OPC 10000-4](/\u00A7UAPart4) and are added to the Message to allow backward compatibility if OPC UA-SecureConversation needs to be updated in the future.\nIf OPC UA- SecureConversation"
    },
    {
      "Id": "086c774a-202e-4339-bed3-b7aad9d872df",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.4 Establishing a SecureChannel\n---\n",
      "Content": "SecureConversation is used with the OPC UA-TCP protocol (see[7.1](/\u00A7_Ref164097216)) then the ClientProtocolVersion specified in the OpenSecureChannel Request shall be the same as the ProtocolVersion specified in the Hello Message. In addition, the ServerProtocolVersion specified in the OpenSecureChannel Response shall be the same as the ProtocolVersion specified in the Acknowledge Message. The receiver shall close the channel and report a Bad_ ProtocolVersionUnsupported error if there is a mismatch.\nThe Server shall return an error response as described in[OPC 10000-4](/\u00A7UAPart4) if there are any errors with the parameters specified by the Client.\nThe RevisedLifetime tells the Client when it shall renew the SecurityToken by sending another OpenSecureChannel request. The Client shall continue to accept the old SecurityToken until it expires or it receives a Message from the Server secured with the new SecurityToken. The Client shall send a Messages secured with new SecurityToken as soon as it finishes processing the OpenSecureChannel response. The Client shall close the SecureChannel if the Certificate used to sign the response is not the same as the Certificate used to encrypt the request.\nThe Server shall accept requests secured with the old SecurityToken until that SecurityToken expires or until it receives a Message from the Client secured with the new SecurityToken. The Server shall reject renew requests if the SenderCertificate is not the same as the one used to create the SecureChannel or if there is a problem decrypting or verifying the signature.\nThe datatype of the RevisedLifetime is a UInt32 value representing the number of milliseconds instead of the Double( Duration) defined in[OPC 10000-4](/\u00A7UAPart4). This optimization is possible because sub-millisecond timeouts are not supported.\nThe"
    },
    {
      "Id": "70f388cf-aa11-433b-9fa6-67058d1ab373",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.4 Establishing a SecureChannel\n---\n",
      "Content": "The OpenSecureChannel Messages are signed and encrypted if the SecurityMode is not None(even if the SecurityMode is Sign).\nThe Nonces shall be cryptographic random numbers with a length specified by the SecureChannelNonceLength of the SecurityPolicy.\nSee[OPC 10000-2](/\u00A7UAPart2) for more information on the requirements for random number generators. The OpenSecureChannel Messages are not signed or encrypted if the SecurityMode is None. The Nonces are ignored and should be set to null. The SecureChannelId and the TokenId are still assigned but no security is applied to Messages exchanged via the channel. The SecurityToken shall still be renewed before the RevisedLifetime expires. Receivers shall still ignore invalid or expired TokenIds.\nThe AuthenticationToken in the RequestHeader shall be set to null.\nIf an error occurs after the Server has verified Message security it shall return a ServiceFault instead of a OpenSecureChannel response. The ServiceFault Message is described in[OPC 10000-4](/\u00A7UAPart4).\nIf the SecurityMode is not None then the Server shall verify that a SenderCertificate and a ReceiverCertificateThumbprint were specified in the SecurityHeader."
    },
    {
      "Id": "fe43b6c0-eb4d-4678-9f63-0bce971295ce",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7 OPC UA Secure Conversation\n---\n",
      "Content": "6.7.5 Deriving keys"
    },
    {
      "Id": "40d6f1dd-7b1b-42a7-acf9-2f8f044bada9",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.5 Deriving keys\n---\n",
      "Content": "Once the SecureChannel is established the Messages are signed and encrypted with keys derived from the Nonces exchanged in the OpenSecureChannel call. These keys are derived by passing the Nonces to a pseudo-random function (PRF) which produces a sequence of bytes from a set of inputs. A pseudo-random function is represented by the following function declaration:\nByte[] PRF(\nByte[] secret,\nByte[] seed,\nInt32 length,\nInt32 offset)\nWhere length is the number of bytes to return and offset is a number of bytes from the beginning of the sequence.\nThe lengths of the keys that need to be generated depend on the SecurityPolicy used for the channel. The following information is specified by the SecurityPolicy:\nSigningKeyLength(from the DerivedSignatureKeyLength);\nEncryptingKeyLength(implied by the SymmetricEncryptionAlgorithm);\nInitializationVectorLength(from by the InitializationVectorLength).\n\nThe pseudo random function requires a secret and a seed. These values are derived from the Nonces exchanged in the OpenSecureChannel request and response.[Table 64](/\u00A7_Ref482623701) specifies how to derive the secrets and seeds when using RSA based SecurityPolicies.\nTable 64- PRF inputs for RSA based SecurityPolicies\nName\nDerivation\nClientSecret\nThe value of the ClientNonce provided in the OpenSecureChannel request.\nClientSeed\nThe value of the ClientNonce provided in the OpenSecureChannel request.\nServerSecret\nThe value of the ServerNonce provided in the OpenSecureChannel response.\nServerSeed\nThe value of the ServerNonce provided in the OpenSecureChannel response.\n\nThe parameters passed to the pseudo random function are specified in[Table 65](/\u00A7_Ref164010221).\nTable 65- Cryptography key generation parameters\nKey"
    },
    {
      "Id": "3a049483-34ec-4777-b690-83062d7eca9f",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.5 Deriving keys\n---\n",
      "Content": "Key\nSecret\nSeed\nLength\nOffset\nClientSigningKey\nServerSecret\nClientSeed\nSigningKeyLength\n0\nClientEncryptingKey\nServerSecret\nClientSeed\nEncryptingKeyLength\nSigningKeyLength\nClientInitializationVector\nServerSecret\nClientSeed\nInitializationVectorLength\nSigningKeyLength\u002BEncryptingKeyLength\nServerSigningKey\nClientSecret\nServerSeed\nSigningKeyLength\n0\nServerEncryptingKey\nClientSecret\nServerSeed\nEncryptingKeyLength\nSigningKeyLength\nServerInitializationVector\nClientSecret\nServerSeed\nInitializationVectorLength\nSigningKeyLength\u002BEncryptingKeyLength\n\nThe Client keys are used to secure Messages sent by the Client. The Server keys are used to secure Messages sent by the Server.\nThe[TLS](/\u00A7Tls) specification defines a pseudo random function called P_HASH which is used for this purpose. The function is iterated until it produces enough data for all of the required keys. The Offset in[Table 65](/\u00A7_Ref164010221) references to the offset from the start of the generated data.\nThe P_ hash algorithm is defined as follows:\nP_HASH(secret, seed) = HMAC_HASH(secret, A(1) \u002B seed) \u002B\nHMAC_HASH(secret, A(2) \u002B seed) \u002B\nHMAC_HASH(secret, A(3) \u002B seed) \u002B ...\nWhere A(n) is defined as:\nA(0) = seed\nA(n) = HMAC_HASH(secret, A(n-1))\n\u002B indicates that the results are appended to previous results.\nWhere \u0027HASH\u0027 is a hash function such as SHA256. The hash function to use depends on the SecurityPolicyUri."
    },
    {
      "Id": "0d710aaa-ef63-4bb7-af51-db406c7d22e3",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7 OPC UA Secure Conversation\n---\n",
      "Content": "6.7.6 Verifying Message Security"
    },
    {
      "Id": "d80002ac-4e7e-401e-9b5e-7bd770c38c59",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.6 Verifying Message Security\n---\n",
      "Content": "The contents of the MessageChunk shall not be interpreted until the Message is decrypted and the signature and sequence number verified.\nIf an error occurs during Message verification the receiver shall close the communication channel. If the receiver is the Server, it shall also send a transport error Message before closing the channel. Once the channel is closed the Client shall attempt to re-open the channel and request a new SecurityToken by sending an OpenSecureChannel request. The mechanism for sending transport errors to the Client depends on the communication channel.\nThe receiver shall first check the SecureChannelId. This value may be 0 if the Message is an OpenSecureChannel request. For other Messages, it shall report a Bad_SecureChannelUnknown error if the SecureChannelId is not recognized. If the Message is an OpenSecureChannel request and the SecureChannelId is not 0 then the SenderCertificate shall be the same as the SenderCertificate used to create the channel.\nIf the Message is secured with asymmetric algorithms, then the receiver shall verify that it supports the requested SecurityPolicy. If the Message is the response sent to the Client, then the SecurityPolicy shall be the same as the one specified in the request. In the Server, the SecurityPolicy shall be the same as the one used to originally create the SecureChannel.\nThe receiver shall verify the ReceiverCertificateThumbprint and report a Bad_CertificateInvalid error if it does not recognize it.\nThe receiver shall check that the Certificate is trusted first and return Bad_SecurityChecksFailed on error. The receiver shall then verify the SenderCertificate using the rules defined in[OPC 10000-4](/\u00A7UAPart4). The receiver shall report the appropriate error if Certificate validation fails.\nIf the Message is secured with symmetric algorithms, then a Bad_SecureChannel TokenUnknown e rror shall be reported if the TokenId"
    },
    {
      "Id": "fae92178-5d8e-4002-aa85-2b53a7a31e13",
      "Header": "Document: Part 6 - Mappings\nSection: 6.7.6 Verifying Message Security\n---\n",
      "Content": "TokenId refers to a SecurityToken that has expired or is not recognized.\nIf decryption or signature validation fails, then a Bad_SecurityChecksFailed error is reported. If an implementation allows multiple SecurityModes to be used the receiver shall also verify that the Message was secured properly as required by the SecurityMode specified in the OpenSecureChannel request.\nAfter the security validation is complete the receiver shall verify the RequestId and the SequenceNumber. If these checks fail a Bad_SecurityChecksFailed error is reported. The RequestId only needs to be verified by the Client since only the Client knows if it is valid or not. If the SequenceNumber is not valid, the receiver shall log a Bad_SequenceNumberInvalid error.\nAt this point the SecureChannel knows it is dealing with an authenticated Message that was not tampered with or resent. This means the SecureChannel can return secured error responses if any further problems are encountered.\nStacks that implement UASC shall have a mechanism to log errors when invalid Messages are discarded. This mechanism is intended for developers, systems integrators and administrators to debug network system configuration issues and to detect attacks on the network."
    },
    {
      "Id": "ff2c86d9-2a9a-4e3f-b14a-d7852bdc5661",
      "Header": "Document: Part 6 - Mappings\nSection: 6 Message SecurityProtocols\n---\n",
      "Content": "6.8 Elliptic Curve Cryptography (ECC)"
    },
    {
      "Id": "9ebf7215-5dfb-45fc-9754-80c88f64d8e2",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8 Elliptic Curve Cryptography (ECC)\n---\n",
      "Content": "6.8.1 Secure Channel Handshake"
    },
    {
      "Id": "2562b7d9-6bf2-439d-9bfd-26ba352bf690",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "The OPC UA Secure Conversation (UASC) mechanism described[6.7](/\u00A7_Ref164097164) is designed for use with asymmetric cryptography algorithms, such as RSA, that allow Public Keys to be used for encryption and for digital signatures. ECC is an asymmetric cryptography algorithm that only supports digital signatures. To accommodate algorithms like ECC, the UASC handshake needs to be modified to allow negotiation of inputs used for key derivation in[6.7.5](/\u00A7_Ref165967540) without making the keys available to eavesdroppers. This negotiation uses a Diffie Hellman algorithm defined in[RFC 8422](/\u00A7RFC8422) and is shown in[Figure 13](/\u00A7_Ref2326914)."
    },
    {
      "Id": "cc8b0da3-0c5c-43cc-bc9b-d8414c0a7c29",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\nCaption: Figure 13 - ECC Key Negotiation\n---\n",
      "Content": "[image016.png](images/image016.png)"
    },
    {
      "Id": "9809eeb4-ff57-409a-8f59-1bb651b3932a",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "Figure 13 - ECC Key Negotiation\nApplicationInstance Certificates for ECC have a public-private key pair that are used to create and verify a digital signature. To negotiate the keys needed for the SecureChannel the Client generates a new key pair (J C, K C) and passes the Public Key(J C) in the request. After verifying the signature on the request, the Server generates a new key pair (J S, K S) and returns the Public Key(J S) in the response. The new key pairs are used each time a SecureChannel is negotiated and they are called EphemeralKeys.\nECC public-private key pairs are always based on a specific elliptic curve function which is used for the ECC calculations. Many curves exist, however, ECC cryptography libraries support a finite set of \u0022named curves\u0022 to allow for better interoperability. Each OPC UA SecurityPolicy defined in[OPC 10000-7](/\u00A7UAPart7) specifies exactly one named curve which is used for the EphemeralKeys.\nEach ECC ApplicationInstance Certificate is also based on a named curve. Each SecurityPolicy specifies a list of named curves which are permitted for use in the ApplicationInstance Certificate. This list always includes the named curved used for the EphemeralKey, however, it may allow other named curves. OPC UA applications that support ECC SecurityPolicies will need to support multiple ApplicationInstance Certificates.\nECC Public Keys and digital signatures are the output of an ECC operation. The encoding of these outputs depends on the ECC curve and are described by the SecurityPolicy in[OPC 10000-7](/\u00A7UAPart7).\nClause 6.7.4 specifies the contents of the OpenSecureChannel request and response messages. When using an ECC SecurityPolicy the ClientNonce is the Public Key"
    },
    {
      "Id": "cf30de4f-6a2b-40ca-8e8e-54c7a22feefc",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "is the Public Key for the Client\u0027s EphemeralKey encoded using the Public Key encoding for the curve. Similarly, the ServerNonce is the Public Key for the Server\u0027s EphemeralKey.\nThe encoding of the EphemeralKeys depends on the ECC curve used. For NIST and Brainpool curves the EphemeralKey is the x and y coordinate encoded as zero padded big-endian OctetString. For Edwards curves the EphemeralKey format is defined by RFC 7748.\nThe EphemeralKeys are used to calculate a shared secret by using the Private Key of an EphemeralKey and the Public Key of the peer\u0027s EphemeralKey. The exact algorithm to calculate the shared secret depends on the ECC curve and is defined by the SecurityPolicy. This shared secret is then used to derive key data using the following algorithm from[RFC 5869](/\u00A7RFC5869). Note that the algorithm is repeated here for clarity, however, the RFC is the normative source.\nStep 1: Calculate Salts\nServerSalt = L | UTF8(opcua-server) | ServerNonce | ClientNonce\nClientSalt = L | UTF8(opcua-client) | ClientNonce | ServerNonce\nWhere\nL is the length of derived key material needed encoded as a 16-bit little endian integer;\nUTF8(label) is the UTF8 encoding of the string literal \u0027label\u0027;\nServerNonce is the Server EphemeralKey from the OpenSecureChannel response;\nClientNonce is the Client EphemeralKey from the OpenSecureChannel request;\n| concatenates sequences of bytes;\nSalt is a sequence of bytes.\n\nStep 2: Extract\nPRK = HMAC-Hash(Salt, IKM)\n\nWhere\nHMAC uses a Hash function specified by the"
    },
    {
      "Id": "09217205-8ccd-410b-8c5c-09a01cef4247",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "KeyDerivationAlgorithm;\nIKM is the x-coordinate of the shared secret;\nSalt is calculated in Step 1;\nPRK is a pseudorandom output with length equal to the Hash size.\n\nThe encoding of the x-coordinate depends on the ECC curve used. For NIST and Brainpool curves the x-coordinate is encoded as a zero padded big-endian OctetString. For Edwards curves the coordinate format is defined by RFC 7748.\n\nStep 3: Expand\nN = ceil(L/HashLen)\nT = T(1) | T(2) | T(3) | ... | T(N)\nOKM = first L octets of T\n\nwhere:\nT(0) = empty string (zero length)\nT(1) = HMAC-Hash(PRK, T(0) | Info | 0x01)\nT(2) = HMAC-Hash(PRK, T(1) | Info | 0x02)\nT(3) = HMAC-Hash(PRK, T(2) | Info | 0x03)\n...\n\nWhere\nHMAC uses a Hash function specified by the KeyDerivationAlgorithm;\nPRK is the output from Step 1;\nInfo is a sequence of bytes;\nL is the length of keying material needed;\n0x01 is the number 1 encoded as a byte.\nOKM is the output with length equal to L bytes.\n\nThe client keys are extracted from the keying material created with IKM=shared secret, Salt= ClientSalt and Info= ClientSalt as shown in[Table 66](/\u00A7_Ref2328109).\nTable 66- Deriving Client Keys from Keying Material\nName\nOffset\nLength\nClientSigningKey"
    },
    {
      "Id": "59cc6c51-195c-46d9-a205-34c2994a98a8",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "Length\nClientSigningKey\n0\nDerivedSignatureKeyLength\nClientEncryptingKey\nDerivedSignatureKeyLength\nEncryptionKeyLength\nClientInitializationVector\nDerivedSignatureKeyLength \u002B EncryptionKeyLength\nInitializationVectorLength\n\nThe server keys are extracted from the keying material created with IKM=shared secret, Salt= ServerSalt and Info= ServerSalt as shown in[Table 67](/\u00A7_Ref525491083).\nTable 67- Deriving Server Keys from Keying Material\nName\nOffset\nLength\nServerSigningKey\n0\nDerivedSignatureKeyLength\nServerEncryptingKey\nDerivedSignatureKeyLength\nEncryptionKeyLength\nServerInitializationVector\nDerivedSignatureKeyLength \u002B EncryptionKeyLength\nInitializationVectorLength\n\nThe SymmetricEncryptionAlgorithm for the SecurityPolicy sets the EncryptionKeyLength and EncryptionBlockSize.\nWhen using AuthenticatedEncryption, the SigningKey, EncryptingKey and InitializationVector are always calculated, however, only the EncryptingKey and InitializationVector are used. The only difference between Sign and SignAndEncrypt is the length of encrypted data which is zero when Sign is used. The process of signing and encrypting data with AuthenticatedEncryption is illustrated in[Figure 14](/\u00A7_Ref133969576)."
    },
    {
      "Id": "c067b4e3-165f-45c8-809e-bb23d3c0f1bd",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\nCaption: Figure 14 - Signing and Encryption with Authenticated Encryption\n---\n",
      "Content": "[image017.png](images/image017.png)"
    },
    {
      "Id": "5f7e47f6-1416-4194-9dde-0f1d9f2aecd4",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "Figure 14 - Signing and Encryption with Authenticated Encryption\nWhen using unauthenticated Encryption with Sign only the SigningKey needs to be computed, however, the length of the derived key material used to calculate the Salt shall be the same as the length of the derived key material used with SignAndEncrypt. The encryption algorithm is not used and the padding is zero length when using Sign mode. The process of signing and encrypting data with unauthenticated Encryption is illustrated in[Figure 15](/\u00A7_Ref133970015)."
    },
    {
      "Id": "d778b4f2-7a6e-4d54-9078-60711c765bb2",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\nCaption: Figure 15 - Signing and Encryption with Unauthenticated Encryption\n---\n",
      "Content": "[image018.png](images/image018.png)"
    },
    {
      "Id": "fd05af92-8f55-447d-8bfe-20ae10bc9ee6",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.1 Secure Channel Handshake\n---\n",
      "Content": "Figure 15 - Signing and Encryption with Unauthenticated Encryption\nIn addition, a unique InitializationVector is needed for each Message. This value constructed from the ClientInitializationVector or ServerInitializationVector where the first 8 bytes are XORed with the values in[Table 68](/\u00A7_Ref35543669) encoded as described in[5.2.2.2](/\u00A7_Ref90086478).\nTable 68- Creating a Mask for the Initialization Vector\nName\nBytes\nLength\nTokenId\n4\nThe TokenId specified in the SecurityHeader of MessageChunk being processed.\nIt is encoded as a UInt32 as described in 5.2.2.2.\nLastSequenceNumber\n4\nThe SequenceNumber specified in the SequenceHeader of last MessageChunk sent in the same direction on the SecureChannel.\nThe value is 0 to indicate there is no LastSequenceNumber for the first MessageChunk which is always the OpenSecureChannel Message.\nIt is encoded as a UInt32 as described in 5.2.2.2.\n\nThe ClientInitializationVector is used when the Client encrypts the MessageChunk and the ServerInitializationVector is used when the Server encrypts the MessageChunk.\nThe LastSequenceNumber is the SequenceNumber from the previously sent Message which normally requires the previous Message to be decrypted. If the receiver processes incoming Messages in parallel it can calculate the expected SequenceNumber based on the order in which the encrypted Messages are received.\nOnce the keys are derived ECC SecureChannels behave the same as RSA SecureChannels."
    },
    {
      "Id": "d887c03f-8a33-4c4b-8886-c27e597833ff",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8 Elliptic Curve Cryptography (ECC)\n---\n",
      "Content": "6.8.2 UserIdentityToken Encryption"
    },
    {
      "Id": "a305a1f9-5e19-444d-9664-baf879bfa826",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.2 UserIdentityToken Encryption\n---\n",
      "Content": "ActivateSession allows a Client to provide an encrypted UserIdentityToken using a SecurityPolicy specified by a UserTokenPolicy supported by the current Endpoint. With ECC, encryption requires that the Client and Server exchange EphemeralKeys and there is no mechanism in the current CreateSession/ ActivateSession handshake to do this. For that reason, EphemeralKeys are returned in the AdditionalHeader field of the ResponseHeader of the CreateSession and ActivateSession responses. An overview of the handshake is shown in[Figure 16](/\u00A7_Ref516233956)."
    },
    {
      "Id": "bdc5cf26-28c8-4141-adcd-bbb7cd6ffc26",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.2 UserIdentityToken Encryption\nCaption: Figure 16 - ECC CreateSession/ActivateSession Handshake\n---\n",
      "Content": "[image019.png](images/image019.png)"
    },
    {
      "Id": "e9fafe8c-d0cf-4c16-84fc-9ad6077245b5",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.2 UserIdentityToken Encryption\n---\n",
      "Content": "Figure 16 - ECC CreateSession/ActivateSession Handshake\nThe UserTokenPolicies are returned in the GetEndpoints response. A UserTokenPolicy may specify a SecurityPolicyUri that is different than the SecureChannel, however, all UserTokenPolicies in an EndpointDescription shall specify a SecurityPolicyUri that is valid for all Certificates that are valid for SecurityPolicyUri specified in the EndpointDescription. For example, an EndpointDescription providing an ECC SecurityPolicyUri shall not specify RSA SecurityPolicyUris in the UserTokenPolicies.\nWhen a Client calls CreateSession via a SecureChannel based on an ECC SecurityPolicy the Client specifies the SecurityPolicyUri it plans to use for the UserIdentityToken in the RequestHeader. Server returns an EphemeralKey in the ResponseHeader that can be used for the SecurityPolicyUri specified by the Client. If the SecurityPolicyUri is not valid the Server returns a StatusCode in the ResponseHeader instead of an EphemeralKey.\nWhen the Client calls ActivateSession it creates an EccEncryptedSecret(see[OPC 10000-4](/\u00A7UAPart4)) using the EphemeralKey provided in CreateSession response. The Server always returns a new EphemeralKey in the ResponseHeader which the Client saves for when it calls ActivateSession again. The SecurityPolicyUri passed in CreateSession is used to determine what type of EphemeralKey to return.\nThe EphemeralKeys may be used for exactly one key negotiation. After that they are discarded. Each time ActivateSession is called the UserIdentityToken is encrypted using the last EphemeralKey returned by the Server. The EphemeralKey is changed even if the Client did not provide an encrypted UserIdentityToken.\nIf the Client does not provide SecurityPolicyUri in the call to CreateSession"
    },
    {
      "Id": "479c56ae-bb9e-4071-a52c-25367e51c93f",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.2 UserIdentityToken Encryption\n---\n",
      "Content": "CreateSession it will not be able to use any UserIdentityTokens that require encryption with ECC SecurityProfiles.\n[OPC 10000-4](/\u00A7UAPart4) defines AdditionalParametersType which is a list of name-value pairs. An instance of this type is passed in the AdditionalHeader field. Instances of the EphemeralKeyType defined in[OPC 10000-4](/\u00A7UAPart4) are passed as values in the name-value pair list in the response messages. The names used for the parameters defined for the CreateSession/ActivateSession exchange are defined in[Table 69](/\u00A7_Ref524457115).\nTable 69- Additional Header Key Names\nName\nDataType\nDescription\nECDHPolicyUri\nString\nSpecifies the SecurityPolicyUri used for the EphemeralKey s.\nECDHKey\nEphemeralKeyType\nSpecifies an EphemeralKey.\nIf the EphemeralKey could not be created a StatusCode indicating the reason for the error is used instead of an instance of EphemeralKeyType."
    },
    {
      "Id": "b4ec0cfc-9528-4e8b-b294-a608bc8443fd",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8 Elliptic Curve Cryptography (ECC)\n---\n",
      "Content": "6.8.3 ECC Encrypted Secret"
    },
    {
      "Id": "a7fafeef-73d1-42c7-bf8f-2487a746f829",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.3 ECC Encrypted Secret\n---\n",
      "Content": "[OPC 10000-4](/\u00A7UAPart4) defines the layout of EccEncryptedSecret structure which is used to protect secrets with ECC SecurityPolicies. Applying security with ECC requires two EphemeralKeys generated by the sender and the receiver which are used create the symmetric keys need for encryption.\n[6.8.1](/\u00A7_Ref516165796) defines a mechanism to allows the sender to acquire the receiver EphemeralKey when using a Session. Using the EccEncryptedSecret in other contexts requires a different mechanism.\nOnce the sender has the receiver EphemeralKey, it creates its own EphemeralKey. The ECC curve and key length for the EphemeralKeys are specified by the SecurityPolicyUri.\nThe encryption uses the symmetric encryption algorithm specified by the SecurityPolicyUri. The encrypting key and initialization vector are generated by using the EphemeralKeys to create the shared secret and then derive keys using the algorithm defined in[6.8.1](/\u00A7_Ref516165796). Step 1 is slightly different and defined as follows:\nStep 1: Calculate Salt\nSecretSalt = L | UTF8(opcua-secret) | SenderPublicKey | ReceiverPublicKey\nWhere:\nL is the length of derived key material needed encoded as a 16-bit little endian integer;\nUTF8(opcua-secret) is the UTF8 encoding of the string literal \u0027opcua-secret\u0027;\nSenderPublicKey and ReceiverPublicKey are from the PolicyHeader;\n| concatenates sequences of bytes;\nSalt is a sequence of bytes.\n\nThe encryption keys are extracted from the keying material created with IKM=shared secret, Salt=SecretSalt and Info=SecretSalt as shown in[Table 70](/\u00A7_Ref525272562).\nTable"
    },
    {
      "Id": "f0ed7eec-f10d-42f9-b4c4-c54c813ed6fc",
      "Header": "Document: Part 6 - Mappings\nSection: 6.8.3 ECC Encrypted Secret\n---\n",
      "Content": ".\nTable 70- Deriving Keys from Keying Material\nName\nOffset\nLength\nEncryptingKey\n0\nEncryptionKeyLength\nInitializationVector\nEncryptionKeyLength\nInitializationVectorLength\nThe EncryptionKeyLength and EncryptionBlockSize are specified by the Symmetric Encryption Algorithm for the SecurityPolicy. The Signature is created with the SigningCertificate and is calculated after encryption. Receivers shall validate the SigningCertificate and signature before decrypting the Secret."
    },
    {
      "Id": "48cf8d0f-90b0-4381-941e-5e50eb84b0df",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "7 TransportProtocols"
    },
    {
      "Id": "9031c4b3-0554-45e1-87d7-0c0e8c40dcb0",
      "Header": "Document: Part 6 - Mappings\nSection: 7 TransportProtocols\n---\n",
      "Content": "7.1 OPC UA Connection Protocol"
    },
    {
      "Id": "92266808-6f68-497a-969d-6d786b3ef03b",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1 OPC UA Connection Protocol\n---\n",
      "Content": "7.1.1 Overview"
    },
    {
      "Id": "d283f4fa-761e-4d76-b763-19eba72585ee",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.1 Overview\n---\n",
      "Content": "OPC UA Connection Protocol (UACP) is an abstract protocol that establishes a full duplex channel between a Client and Server. Concrete implementations of the UACP can be built with any middleware that supports full-duplex exchange of messages including TCP/IP and WebSockets. The term \u0022 TransportConnection\u0022 describes the specific connection used to exchange messages. For example, a socket is the TransportConnection for TCP/IP. TransportConnections allow responses to be returned in any order. If the TransportConnection breaks the SecureChannel is interrupted and a new SecureChannel needs to be created.\nThe OPC UA Connection Protocol is designed to work with the SecureChannel implemented by a layer higher in the stack. For this reason, the OPC UA Connection Protocol defines its interactions with the SecureChannel in addition to the wire protocol."
    },
    {
      "Id": "6655dcfb-d59c-4175-8dd4-1792fe469548",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1 OPC UA Connection Protocol\n---\n",
      "Content": "7.1.2 Message structure"
    },
    {
      "Id": "91c98b7d-2256-4152-a45a-8eb1b713d147",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2 Message structure\n---\n",
      "Content": "7.1.2.1 Overview"
    },
    {
      "Id": "02eb5fe8-6206-47cc-b3b5-d47f11234eee",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.1 Overview\n---\n",
      "Content": "[Figure 17](/\u00A7_Ref457769363) illustrates the structure of a Message placed on the wire. This also illustrates how the Message elements defined by the OPC UA Binary Encoding mapping (see[5.2](/\u00A7_Ref164095085)) and the OPC UA Secure Conversation mapping (see[6.7](/\u00A7_Ref164097164)) relate to the OPC UA Connection Protocol Messages."
    },
    {
      "Id": "9f900af7-af3c-4712-9eda-c8d66a5661ef",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.1 Overview\nCaption: Figure 17 - OPC UA Connection Protocol Message structure\n---\n",
      "Content": "[image020.png](images/image020.png)"
    },
    {
      "Id": "940d17be-23b5-4182-9c0d-68b5f920a8a4",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.1 Overview\n---\n",
      "Content": "Figure 17 - OPC UA Connection Protocol Message structure"
    },
    {
      "Id": "f99fc111-e326-469a-a4d8-2b57658a5ce1",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2 Message structure\n---\n",
      "Content": "7.1.2.2 Message Header"
    },
    {
      "Id": "cb4f443c-0cf2-4ef6-b2c0-175d4525f6c9",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.2 Message Header\n---\n",
      "Content": "Every OPC UA Connection Protocol Message has a header with the fields defined in[Table 71](/\u00A7_Ref165969843).\nTable 71- OPC UA Connection Protocol Message header\nName\nType\nDescription\nMessageType\nByte [3]\nA three byte ASCII code that identifies the Message type.\nThe following values are defined at this time:\nHEL a Hello Message.\nACK an Acknowledge Message.\nERR an Error Message.\nRHE a ReverseHello Message.\nThe SecureChannel layer defines additional values which the OPC UA Connection Protocol layer shall accept.\nReserved\nByte [1]\nIgnored. shall be set to the ASCII codes for \u0027F\u0027 if the MessageType is one of the values supported by the OPC UA Connection Protocol.\nMessageSize\nUInt32\nThe length of the Message, in bytes. This value includes the 8 bytes for the Message header.\n\nThe layout of the OPC UA Connection Protocol Message header is intentionally identical to the first 8 bytes of the OPC UA Secure Conversation Message header defined in[Table 56](/\u00A7_Ref163954977). This allows the OPC UA Connection Protocol layer to extract the SecureChannel Messages from the incoming stream even if it does not understand their contents.\nThe OPC UA Connection Protocol layer shall verify the MessageType and make sure the MessageSize is less than the negotiated ReceiveBufferSize before passing any Message onto the SecureChannel layer."
    },
    {
      "Id": "fbacf78e-cb94-463a-b624-c545c90ca924",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2 Message structure\n---\n",
      "Content": "7.1.2.3 Hello Message"
    },
    {
      "Id": "95e5bee1-efb1-4f6a-8df8-ad6d937946b3",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.3 Hello Message\n---\n",
      "Content": "The Hello Message has the additional fields shown in[Table 72](/\u00A7_Ref164020144).\nTable 72- OPC UA Connection Protocol Hello Message\nName\nData Type\nDescription\nProtocolVersion\nUInt32\nThe version of the UACP protocol requested by the Client.\nIf Server does not support the requested version or any lower version it rejects the Client by returning Bad_ProtocolVersionUnsupported.\nIf the Server supports the requested version or a lower version it shall return the version it will use in the Acknowledge Message.\nThe ProtocolVersion for this version of the standard is 0.\nReceiveBufferSize\nUInt32\nThe largest MessageChunk that the sender can receive.\nShall be at least 1024 bytes if the sender intends to use an ECC SecurityPolicy.\nShall be at least 8192 bytes otherwise.\nSendBufferSize\nUInt32\nThe largest MessageChunk that the sender will send.\nShall be at least 1024 bytes if the sender intends to use an ECC SecurityPolicy.\nShall be at least 8192 bytes otherwise.\nMaxMessageSize\nUInt32\nThe maximum size for any response Message.\nIf MessageChunks have not been sent, the Server shall return an Error Message with a Bad_ResponseTooLarge error if a response Message exceeds this value.\nIf MessageChunks have already been sent the Server shall abort the Message as described in[6.7.3](/\u00A7_Ref188022819).\nThe Message size is calculated using the unencrypted Message body.\nA value of zero indicates that the Client has no limit.\nMaxChunkCount\nUInt32\nThe maximum number of chunks in any response Message.\nThe Server shall abort the Message with a Bad_ResponseTooLarge Error Message if a response Message exceeds this value."
    },
    {
      "Id": "52212777-d2f2-48ed-ac3b-d077dbdf4b65",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.3 Hello Message\n---\n",
      "Content": "The mechanism for aborting Messages is described fully in[6.7.3](/\u00A7_Ref188022819).\nA value of zero indicates that the Client has no limit.\nEndpointUrl\nString\nThe URL of the Endpoint which the Client wished to connect to.\nThe encoded value shall be less than 4096 bytes.\nServers shall return a Bad_TcpEndpointUrlInvalid Error Message and close the connection if the length exceeds 4096 or if it does not recognize the resource identified by the URL.\n\nThe EndpointUrl parameter is used to allow multiple Servers to share the same endpoint on a machine. The process listening (also known as the proxy) on the endpoint would connect to the Server identified by the EndpointUrl and would forward all Messages to the Server via this socket. If one socket closes, then the proxy shall close the other socket.\nIf the Server does not have sufficient resources to allow the establishment of a new SecureChannel it shall immediately return a Bad_TcpNotEnoughResources Error Message and gracefully close the socket. Client should not overload Servers that return this error by immediately trying to create a new SecureChannel."
    },
    {
      "Id": "5b91b1a4-1c6a-4edf-8894-171265279c49",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2 Message structure\n---\n",
      "Content": "7.1.2.4 Acknowledge Message"
    },
    {
      "Id": "18fc9aca-45d4-4b77-87bb-de5320a4c8f8",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.4 Acknowledge Message\n---\n",
      "Content": "The Acknowledge Message has the additional fields shown in[Table 73](/\u00A7_Ref179131842).\nTable 73- OPC UA Connection Protocol Acknowledge Message\nName\nType\nDescription\nProtocolVersion\nUInt32\nA protocol version supported by the Server that is less than or equal to the protocol version requested in the Hello Message.\nIf the Client accepts the protocol version it shall ensure that it sends Messages that conform to this version.\nThe ProtocolVersion for this version of the standard is 0.\nReceiveBufferSize\nUInt32\nThe largest MessageChunk that the sender can receive.\nThis value shall not be larger than the SendBufferSize requested in the Hello Message.\nShall be at least 8192 bytes if the SendBufferSize requested in the Hello Message is \u003E= 8192 bytes. Shall be at least 1024 bytes otherwise.\nSendBufferSize\nUInt32\nThe largest MessageChunk that the sender will send.\nThis value shall not be larger than the ReceiveBufferSize requested in the Hello Message.\nShall be at least 8192 bytes if the ReceiveBufferSize requested in the Hello Message is \u003E= 8192 bytes. Shall be at least 1024 bytes otherwise.\nMaxMessageSize\nUInt32\nThe maximum size for any request Message.\nIf a request Message exceeds this value the Client shall report a Bad_ Bad_RequestTooLarge error to the application. If MessageChunks have already been sent the Client shall also abort the Message as described in[6.7.3](/\u00A7_Ref188022819).\nThe Message size is calculated using the unencrypted Message body.\nA value of zero indicates that the Server has no limit.\nMaxChunkCount\nUInt32\nThe maximum number of chunks in any request Message.\nThe Client shall abort the Message with a"
    },
    {
      "Id": "0aea682d-8aab-48d6-bc76-114dedc85ae3",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.4 Acknowledge Message\n---\n",
      "Content": "Message with a Bad_RequestTooLarge StatusCode if a request Message exceeds this value.\nThe mechanism for aborting Messages is described fully in[6.7.3](/\u00A7_Ref188022819).\nA value of zero indicates that the Server has no limit."
    },
    {
      "Id": "77cb69da-b79f-4972-8bfd-a75b65f9fad8",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2 Message structure\n---\n",
      "Content": "7.1.2.5 Error Message"
    },
    {
      "Id": "a9df1346-50fb-4735-9e40-a781eef4030e",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.5 Error Message\n---\n",
      "Content": "The Error Message has the additional fields shown in[Table 74](/\u00A7_Ref164020837).\nTable 74- OPC UA Connection Protocol Error Message\nName\nType\nDescription\nError\nUInt32\nThe numeric code for the error.\nPossible values are listed in[Table 77](/\u00A7_Ref164020643).\nReason\nString\nA more verbose description of the error.\nThis string shall not be more than 4096 bytes.\nA Client shall ignore strings that are longer than this.\n\nThe socket is always closed gracefully by the Client after it receives an Error Message."
    },
    {
      "Id": "b1abf650-fa6c-4949-bb47-e6df6da054e4",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2 Message structure\n---\n",
      "Content": "7.1.2.6 ReverseHello Message"
    },
    {
      "Id": "ac9ac308-d9f8-44eb-9c85-3439dfaa6c74",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.2.6 ReverseHello Message\n---\n",
      "Content": "The ReverseHello Message has the additional fields shown in[Table 75](/\u00A7_Ref456137651).\nTable 75- OPC UA Connection Protocol ReverseHello Message\nName\nData Type\nDescription\nServerUri\nString\nThe ApplicationUri of the Server which sent the Message.\nThe encoded value shall be less than 4096 bytes.\nClient shall return a Bad_TcpEndpointUrlInvalid error and close the connection if the length exceeds 4096 or if it does not recognize the Server identified by the URI.\nEndpointUrl\nString\nThe URL of the Endpoint which the Client uses when establishing the SecureChannel.\nThis value shall be passed back to the Server in the Hello Message.\nThe encoded value shall be less than 4096 bytes.\nClients shall return a Bad_TcpEndpointUrlInvalid error and close the connection if the length exceeds 4096 or if it does not recognize the resource identified by the URL.\nThis value is a unique identifier for the Server which the Client may use to look up configuration information. It should be one of the URLs returned by the GetEndpoints Service.\n\nFor connection-based protocols, such as TCP, the ReverseHello Message allows Servers behind firewalls with no open ports to connect to a Client and request that the Client establish a SecureChannel using the socket created by the Server.\nFor message-based protocols the ReverseHello Message allows Servers to announce their presence to a Client. In this scenario, the EndpointUrl specifies the Server\u0027s specific address and any tokens required to access it."
    },
    {
      "Id": "f599c6a3-852e-4255-ad16-c0a95085b7e8",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1 OPC UA Connection Protocol\n---\n",
      "Content": "7.1.3 Establishing a connection"
    },
    {
      "Id": "213bf822-0a6f-4cbc-8229-095a82d31e9f",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\n---\n",
      "Content": "Connections may be initiated by the Client or by the Server when they create a TransportConnection and establish a communication with their peer. The connection is initiated by using an EndpointUrl that specifies a network address where a peer listens for new connections. The EndpointUrl specifies a network address that is accessible to the initiator. If the listener is behind a NAT firewall, the EndpointUrl specifies an address outside the firewall. If the EndpointUrl specifies a domain name then the initiator requires access to a domain name resolution service (e.g., the DNS protocol) that maps the domain name onto a usable network address.[OPC 10000-7](/\u00A7UAPart7) defines Profiles for different name resolution protocols that Clients and Servers may support.\nIf the Client creates the TransportConnection, the first Message sent shall be a Hello which specifies the buffer sizes that the Client supports. The Server shall respond with an Acknowledge Message which completes the buffer negotiation. The negotiated buffer size shall be reported to the SecureChannel layer. The negotiated SendBufferSize specifies the size of the MessageChunks to use for Messages sent over the connection.\nIf the Server creates the TransportConnection the first Message shall be a ReverseHello sent to the Client. If the Client accepts the connection, it sends a Hello message back to the Server which starts the buffer negotiation described for the Client initiated connection.\nThe Hello/Acknowledge Messages may only be sent once. If they are received again the receiver shall report an error and close the TransportConnection. Applications accepting incoming connections shall close any TransportConnection after a period of time if it does not receive a Hello or ReverseHello Message. This period of time shall be configurable and have a default value which does not exceed two minutes.\nThe Client sends the OpenSecureChannel request once it receives the Acknowledge back from the Server. If the Server"
    },
    {
      "Id": "4818962f-3887-4083-9f08-2c1162bd0ae2",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\n---\n",
      "Content": "Server. If the Server accepts the new channel, it shall associate the TransportConnection with the SecureChannelId. The Server uses this association to determine which TransportConnection to use when it has to send a response to the Client. The Client does the same when it receives the OpenSecureChannel response.\nThe Server application does not do any processing while the SecureChannel is negotiated; however, the Server application shall provide the Stack with the list of trusted Certificates. The Stack shall provide notifications to the Server application whenever it receives an OpenSecureChannel request. These notifications shall include the OpenSecureChannel or Error response returned to the Client.\nThe sequence of Messages when establishing a Client initiated OPC UA Connection Protocol connection is shown in[Figure 18](/\u00A7_Ref164017437)."
    },
    {
      "Id": "72fc2362-0863-4bef-b454-87d6b30de26f",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\nCaption: Figure 18 - Client initiated OPC UA Connection Protocol connection\n---\n",
      "Content": "[image021.png](images/image021.png)"
    },
    {
      "Id": "7e30d809-fa7e-4a28-bac5-cf6ba15da65d",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\n---\n",
      "Content": "Figure 18 - Client initiated OPC UA Connection Protocol connection\nThe sequence of Messages when establishing a Server initiated OPC UA Connection Protocol connection is shown in[Figure 19](/\u00A7_Ref456138622)."
    },
    {
      "Id": "614c5a39-8ed9-4590-b522-d30d416dfea8",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\nCaption: Figure 19 - Server initiated OPC UA Connection Protocol connection\n---\n",
      "Content": "[image022.png](images/image022.png)"
    },
    {
      "Id": "0c4eba8b-b5db-4097-8c3f-2b62e525496c",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\n---\n",
      "Content": "Figure 19 - Server initiated OPC UA Connection Protocol connection\nFor Server-initiated connections, the Server needs to be configured and enabled by an administrator to connect to one or more Clients. For each Client, the administrator shall provide an EndpointUrl which may be use to establish a connection. If the Client EndpointUrl is not known, the administrator may provide the EndpointUrl for a GDS (see[OPC 10000-12](/\u00A7UAPart12)) which knows about the Client. In this case, the administrator shall also provide an ApplicationUri which can be used to find the Client in the GDS.\nServers shall maintain at least one open socket without an active Session with each Client it is configured to connect to. Servers may delay re-connecting if the Client reports an error.[Table 76](/\u00A7_Ref138186180) describes the process in full and how the Server is expected to react to different actions by the Client.\nTable 76- Client and Server Handshake during Reverse Connect\nAction\nNotes\nOpen Connection\nServer creates a socket to a URL specified in its configuration.\nClient shall close the socket after short delay if no ReverseHello Message received.\nServer shall create a new socket because it cannot know if it was a network issue or due to action by the Client.\nReverse Hello\nServer sends ReverseHello with its ApplicationUri.\nClient may check the ApplicationUri. If it is not acceptable it shall close the socket.\nClient shall send an Error Message with the code Bad_ServerTooBusy if it does not have enough resources to keep the socket open.\nClient may save socket for use in the future (the sequence may pause here).\nIf the Server receives an Error Message it shall close the socket, log the error and reconnects after a delay specified in its configuration."
    },
    {
      "Id": "44f9cb4d-74af-4e36-ba0a-9d12c7586a6c",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.3 Establishing a connection\n---\n",
      "Content": "If the socket is closed without an Error Message, the Server shall create a new socket with or without a delay and sends a new ReverseHello Message.\nHelloAcknowledgeOpen Secure Channel RequestOpen Secure Channel Response\n\nClient establishes a SecureChannel and verifies that it trusts the Server.\nClient may save the SecureChannel for use in the future (the sequence may pause here).\nClient may use SecureChannel for Discovery or Session-less Service invocations.\nOnce a SecureChannel is established, the Server shall create a new socket if there is not already one without an active SecureChannel.\nIf the SecureChannel is closed, the Server shall create a new socket if there is not already one without an active SecureChannel.\nCreate Session\nClient establishes a Session."
    },
    {
      "Id": "0e06a726-b9ef-42f3-986d-4423de9ee69c",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1 OPC UA Connection Protocol\n---\n",
      "Content": "7.1.4 Closing a connection"
    },
    {
      "Id": "c4336274-5a3f-4cc3-b9a9-545cf38eb30b",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.4 Closing a connection\n---\n",
      "Content": "The Client closes the connection by sending a CloseSecureChannel request and closing the socket gracefully. When the Server receives this Message, it shall release all resources allocated for the channel. The body of the CloseSecureChannel request is empty. The Server does not send a CloseSecureChannel response.\nIf security verification fails for the CloseSecureChannel Message, then the Server shall report the error and close the socket.\nThe sequence of Messages when closing an OPC UA Connection Protocol connection is shown in[Figure 20](/\u00A7_Ref164019178)."
    },
    {
      "Id": "0539fc73-f5d4-488f-a597-e44cef9726bd",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.4 Closing a connection\nCaption: Figure 20 - Closing a OPC UA Connection Protocol connection\n---\n",
      "Content": "[image023.png](images/image023.png)"
    },
    {
      "Id": "b064846e-ccc7-49a5-b7f0-98bc5a5b2ff1",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.4 Closing a connection\n---\n",
      "Content": "Figure 20 - Closing a OPC UA Connection Protocol connection\nThe Server application does not do any processing when the SecureChannel is closed; however, the Stack shall provide notifications to the Server application whenever a CloseSecureChannel request is received or when the Stack cleans up an abandoned SecureChannel."
    },
    {
      "Id": "db11f53c-e431-4837-b757-297acdf816ff",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1 OPC UA Connection Protocol\n---\n",
      "Content": "7.1.5 Error handling"
    },
    {
      "Id": "bd417be3-5b55-4ba3-93b0-c5be1eb288a4",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.5 Error handling\n---\n",
      "Content": "When a protocol level error occurs that cannot be recovered, the Server shall send an Error Message to the Client and closes the TransportConnection gracefully. When the Client receives an Error Message it reports the error to the application and closes the TransportConnection gracefully. If a Client encounters a fatal error, it shall report the error to the application and send a CloseSecureChannel Message. The Server shall close the TransportConnection gracefully when it receives the CloseSecureChannel Message.\nThe possible OPC UA Connection Protocol errors are defined in[Table 77](/\u00A7_Ref164020643).\nTable 77- OPC UA Connection Protocol error codes\nName\nDescription\nBad_TcpServerTooBusy\nThe Server cannot process the request because it is too busy.\nIt is up to the Server to determine when it needs to return this Message.\nA Server can control the how frequently a Client reconnects by waiting to return this error.\nBad_TcpMessageTypeInvalid\nThe type of the Message specified in the header invalid.\nEach Message starts with a 4-byte sequence of ASCII values that identifies the Message type.\nThe Server returns this error if the Message type is not accepted.\nSome of the Message types are defined by the SecureChannel layer.\nBad_TcpSecureChannelUnknown\nThe SecureChannelId and/or TokenId are not currently in use.\nThis error is reported by the SecureChannel layer.\nBad_TcpMessageTooLarge\nThe size of the MessageChunk specified in the header is too large.\nThe Server returns this error if the MessageChunk size exceeds its maximum buffer size or the receive buffer size negotiated during the Hello/Acknowledge exchange.\nBad_Timeout\nA timeout occurred while accessing a resource.\nIt is up to the Server to determine when a timeout occurs.\nBad_TcpNotEnoughResources"
    },
    {
      "Id": "da877867-8967-42a9-a04a-872ce9b4d516",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.5 Error handling\n---\n",
      "Content": "There are not enough resources to process the request.\nThe Server returns this error when it runs out of memory or encounters similar resource problems.\nA Server can control the how frequently a Client reconnects by waiting to return this error.\nBad_TcpInternalError\nAn internal error occurred.\nThis should only be returned if an unexpected configuration or programming error occurs.\nBad_TcpEndpointUrlInvalid\nThe Server does not recognize the EndpointUrl specified.\nBad_SecurityChecksFailed\nThe Message was rejected because it could not be verified.\nBad_RequestInterrupted\nThe request could not be sent because of a network interruption.\nBad_RequestTimeout\nTimeout occurred while processing the request.\nBad_SecureChannelClosed\nThe secure channel has been closed.\nBad_SecureChannelTokenUnknown\nThe SecurityToken has expired or is not recognized.\nBad_CertificateUntrusted\nThe sender Certificate is not trusted by the receiver.\nBad_CertificateTimeInvalid\nThe sender Certificate has expired or is not yet valid.\nBad_CertificateIssuerTimeInvalid\nThe issuer for the sender Certificate has expired or is not yet valid.\nBad_CertificateUseNotAllowed\nThe sender\u0027s Certificate may not be used for establishing a secure channel.\nBad_CertificateIssuerUseNotAllowed\nThe issuer Certificate may not be used as a Certificate Authority.\nBad_CertificateRevocationUnknown\nCould not verify the revocation status of the sender\u0027s Certificate.\nBad_CertificateIssuerRevocationUnknown\nCould not verify the revocation status of the issuer Certificate.\nBad_CertificateRevoked\nThe sender Certificate has been revoked by the issuer.\nBad_IssuerCertificateRevoked\nThe issuer Certificate has been revoked by its issuer.\nBad_SequenceNumberInvalid\nThe sequence number on the message was not valid.\nBad_ServiceUnsupported\nThe Service Request"
    },
    {
      "Id": "8eb0d9fb-e0fd-4067-bfc7-70df96737c7c",
      "Header": "Document: Part 6 - Mappings\nSection: 7.1.5 Error handling\n---\n",
      "Content": "The Service Request contained in the body of the message is not supported. This error is only returned when the Request represents a security risk and it is necessary to immediately close the SecureChannel. For example, calling CreateSession on a SecureChannel that does not allow Sessions.\n\nThe numeric values for these error codes are defined in[A.2](/\u00A7_Ref80223066).\nNOTE: The \u0027Tcp\u0027 prefix for some of the error codes in[Table 77](/\u00A7_Ref164020643) was chosen when TCP/IP was the only implementation of the OPC UA Connection Protocol. These codes are used with any implementation of the OPC UA Connection Protocol."
    },
    {
      "Id": "002bdeeb-695f-4823-a147-394d67dffc7f",
      "Header": "Document: Part 6 - Mappings\nSection: 7 TransportProtocols\n---\n",
      "Content": "7.2 OPC UA TCP"
    },
    {
      "Id": "4881b3eb-745e-4b46-8836-bbaeaf76ade2",
      "Header": "Document: Part 6 - Mappings\nSection: 7.2 OPC UA TCP\n---\n",
      "Content": "TCP/IP is a ubiquitous protocol that provides full-duplex communication between two applications. A socket is the TransportConnection in the TCP/IP implementation of the OPC UA Connection Protocol.\nThe URL scheme for endpoints using OPC UA TCP is \u0027opc.tcp\u0027.\nThe TransportProfileUri shall be a URI for the TCP transport defined in[OPC 10000-7](/\u00A7UAPart7)."
    },
    {
      "Id": "c9bd5a47-b4d0-459d-9d1a-9d156caf2fb4",
      "Header": "Document: Part 6 - Mappings\nSection: 7 TransportProtocols\n---\n",
      "Content": "7.3 SOAP/HTTP"
    },
    {
      "Id": "040d2c42-26ca-4e6f-af44-8cb8126bd436",
      "Header": "Document: Part 6 - Mappings\nSection: 7.3 SOAP/HTTP\n---\n",
      "Content": "Note: Deprecated in Version 1.03 because WS-SecureConversation has not been widely adopted by industry."
    },
    {
      "Id": "6ed911a8-8d3f-455a-a7e1-5aa7ee7bb9f3",
      "Header": "Document: Part 6 - Mappings\nSection: 7 TransportProtocols\n---\n",
      "Content": "7.4 OPC UA HTTPS"
    },
    {
      "Id": "bfd99e95-8d13-4cd8-a17e-0a73e9e70991",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4 OPC UA HTTPS\n---\n",
      "Content": "7.4.1 Overview"
    },
    {
      "Id": "47abef53-c964-4329-a1bd-bdd2440f6e3d",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.1 Overview\n---\n",
      "Content": "[HTTPS](/\u00A7Https) refers[HTTP](/\u00A7Http) Messages exchanged over a[TLS](/\u00A7Tls) connection (see[HTTPS](/\u00A7Https)). The syntax of the HTTP Messages does not change and the only difference is a TLS connection is created instead of a TCP/IP connection. This implies that profiles which use this transport can also be used with HTTP when security is not a concern.\nHTTPS is a protocol that provides transport security. This means all bytes are secured as they are sent without considering the Message boundaries. Transport security can only work for point-to-point communication and does not allow untrusted intermediaries or proxy servers to handle traffic.\nThe SecurityPolicy shall be specified, however, it only affects the algorithms used for signing the Nonces during the CreateSession/ ActivateSession handshake. A SecurityPolicy of None indicates that the Nonces do not need to be signed. The SecurityMode is set to Sign unless the SecurityPolicy is None; in this case the SecurityMode shall be set to None. If a UserIdentityToken is to be encrypted, it shall be explicitly specified in the UserTokenPolicy.\nAn HTTP Header called \u0027OPCUA-SecurityPolicy\u0027 is used by the Client to tell the Server what SecurityPolicy it is using if there are multiple choices available. The value of the header is the URI for the SecurityPolicy. If the Client omits the header, then the Server shall assume a SecurityPolicy of None.\nAll HTTPS communications via a URL shall be treated as a single SecureChannel that is shared by multiple Clients. Stacks shall provide a unique identifier for the SecureChannel which allows applications correlate a request with a SecureChannel. This means that Sessions can only be considered secure if the AuthenticationToken(see[OPC 10000-4](/\u00A7UAPart4)"
    },
    {
      "Id": "caea3867-d3af-4248-8f0d-dc56edf4f22e",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.1 Overview\n---\n",
      "Content": ") is long (\u003E20 bytes) and HTTPS encryption is enabled.\nThe cryptography algorithms used by HTTPS have no relationship to the EndpointDescription SecurityPolicy and are determined by the policies set for HTTPS and are outside the scope of OPC UA.\n[Figure 21](/\u00A7_Ref286609258) illustrates a few scenarios where the HTTPS transport could be used."
    },
    {
      "Id": "e80b2569-3016-4609-aa47-f1222ddb4b39",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.1 Overview\nCaption: Figure 21 - Scenarios for the HTTPS Transport\n---\n",
      "Content": "[image024.png](images/image024.png)"
    },
    {
      "Id": "9b36023a-7185-43c2-a0f6-cb008eef9551",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.1 Overview\n---\n",
      "Content": "Figure 21 - Scenarios for the HTTPS Transport\nIn some scenarios, HTTPS communication will rely on an intermediary which is not trusted by the applications. If this is the case, then the HTTPS transport cannot be used to ensure security and the applications will have to establish a secure tunnel like a VPN before attempting any OPC UA related communication.\nApplications which support the HTTPS transport shall support[HTTP](/\u00A7Http) and[TLS](/\u00A7Tls).\nSome HTTPS implementations require that all Servers have a Certificate with a Common Name (CN) that matches the DNS name of the Server machine. This means that a Server with multiple DNS names will need multiple HTTPS certificates. If multiple Servers are on the same machine they may share HTTPS certificates. This means that ApplicationCertificates are not the same as HTTPS Certificates. Applications which use the HTTPS transport and require application authentication shall check application Certificates during the CreateSession/ ActivateSession handshake.\nHTTPS Certificates can be automatically generated; however, this will cause problems for Clients operating inside a restricted environment such as a web browser. Therefore, HTTPS certificates should be issued by an authority which is accepted by all web browsers which need to access the Server. The set of Certificate authorities accepted by the web browsers is determined by the organization that manages the Client machines. Client applications that are not running inside a web may use the trust list that is used for application Certificates.\nA Server that is configured to use an HTTPS proxy shall have a mechanism to ensure that requests only come from that HTTPS proxy. The exact mechanism, such as binding to the loopback address, is implementation dependent.\nHTTPS connections have an unpredictable lifetime. Therefore, Servers must rely on the AuthenticationToken passed in the RequestHeader to determine the identity of the Client. This means the AuthenticationToken"
    },
    {
      "Id": "a36240be-f485-49d4-aa26-e209c8c72e3b",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.1 Overview\n---\n",
      "Content": "AuthenticationToken shall be a randomly generated value with at least 32 bytes of data and HTTPS with signing and encryption shall always be used.\nHTTPS allows Clients to have certificates; however, they are not required by the HTTPS transport. A Server shall allow Clients to connect without providing a Certificate during negotiation of the HTTPS connection.\nHTTP 1.1 supports Message chunking where the Content-Length header in the request response is set to \u0022chunked\u0022 and each chunk is prefixed by its size in bytes. All applications that support the HTTPS transport shall support HTTP chunking.\nThe URL scheme for endpoints using the HTTPS transport is \u0027opc.https\u0027. Note that \u0027https\u0027 is the generic URL scheme for the underlying transport. The opc prefix specifies that the endpoint accepts OPC UA messages as defined in this document."
    },
    {
      "Id": "2f514488-0a3d-4530-ba24-5f2224d4cf9a",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4 OPC UA HTTPS\n---\n",
      "Content": "7.4.2 Session-less Services"
    },
    {
      "Id": "74cb7db7-d636-4f2d-a478-3cff0046ccb7",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.2 Session-less Services\n---\n",
      "Content": "Session- less Services(see[OPC 10000-4](/\u00A7UAPart4)) may be invoked via HTTPS POST.\nThe HTTP Authorization header is used to specify the UserIdentity used to determine what permissions are available to the caller. The Authorization header may specify a Basic token with a UserName/Password or a Bearer token (see[RFC 6750](/\u00A7RFC6750)) with an AccessToken provided by an AuthorizationService.\nThe HTTP Accept-Language header is used to specify the locales to use for the request. The locales are sorted based on their quality value and then by the order they appear in the header.\nThe Content-Type header in the HTTP request and response shall specify the DataEncoding of the message. Well known media types should be used to ensure interoperability with standard HTTP infrastructure. The application/opcua\u002Buabinary media type is also defined, however, it is not registered with IANA and is only specified for backward compatibility.\nTable 78- HTTP Content-Type Header\nContent-Type\nDescription\napplication/octet-streamapplication/opcua\u002Buabinary\nThe body is encoded using the OPC UA Binary DataEncoding defined in[5.2](/\u00A7_Ref163962885).\napplication/soap\u002Bxml\nThe body is encoded using the XML DataEncoding defined in[5.3](/\u00A7_Ref131702289).\napplication/json\nThe body is encoded using the OPC UA JSON Compact DataEncoding defined in[5.4](/\u00A7_Ref443435038).\n\nXML and JSON messages always use the UTF8 encoding. The charset parameter (i.e. \u0027application/json; charset=utf-8\u0027) may be appended to the media type to indicate this.\nJSON messages may be compressed with[RFC 1952](/\u00A7RFC1952)"
    },
    {
      "Id": "c738c014-a927-4ac8-ac61-a8083e89144b",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.2 Session-less Services\n---\n",
      "Content": ". If compression is used the Content-Encoding HTTP Header is \u0027gzip\u0027."
    },
    {
      "Id": "eef02f22-3027-4dce-abe3-7d0cae793176",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4 OPC UA HTTPS\n---\n",
      "Content": "7.4.3 XML Encoding"
    },
    {
      "Id": "6506c63b-0671-45ef-83ea-de83386d1829",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.3 XML Encoding\n---\n",
      "Content": "This TransportProtocol implements the OPC UA Services using a SOAP request-response message pattern over an HTTPS connection.\nThe body of the HTTP Messages shall be a SOAP 1.2 Message(see[SOAP Part 1](/\u00A7Soap1)). WS-Addressing headers are optional.\nThe OPC UA XML Encoding specifies a way to represent an OPC UA Message as an XML element. This element is added to the SOAP Message as the only child of the SOAP body element. If an error occurs in the Server while parsing the request body, the Server may return a SOAP fault or it may return an OPC UA error response.\nThe SOAP Action associated with an XML encoded request Message always has the form:\nhttp://opcfoundation.org/UA/2008/02/Services.wsdl/\u003Cservice name\u003E\nWhere \u003Cservice name\u003E is the name of the OPC UA Service being invoked.\nThe SOAP Action associated with an XML encoded response Message always has the form:\nhttp://opcfoundation.org/UA/2008/02/Services.wsdl/\u003Cservice name\u003EResponse\nAll requests shall be HTTP POST requests. The Content-type shall be \u0022application/soap\u002Bxml\u0022 and the charset and action parameters shall be specified. The charset parameter shall be \u0022utf-8\u0022 and the action parameter shall be the URI for the SOAP action.\nAn example HTTP request header is:\nPOST /UA/SampleServer HTTP/1.1\nContent-Type: application/soap\u002Bxml; charset=\u0022utf-8\u0022;\naction=\u0022http://opcfoundation.org/UA/2008/02/Services.wsdl/Read\u0022\nContent-Length: nnnn\nThe action parameter appears on the same line as the Content-Type declaration.\nAn example request Message:"
    },
    {
      "Id": "fbed42b8-76dc-4fec-9aaa-bce8ae18bbd2",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.3 XML Encoding\n---\n",
      "Content": "Message:\n\u003Cs:Envelope xmlns:s=\u0022http://www.w3.org/2003/05/soap-envelope\u0022\u003E\n\u003Cs:Body\u003E\n\u003CReadRequest xmlns=\u0022http://opcfoundation.org/UA/2008/02/Types.xsd\u0022\u003E\n\u2026\n\u003C/ReadRequest\u003E\n\u003C/s:Body\u003E\n\u003C/s:Envelope\u003E\nAn example HTTP response header is:\nHTTP/1.1 200 OK\nContent-Type: application/soap\u002Bxml; charset=\u0022utf-8\u0022;\naction=\u0022http://opcfoundation.org/UA/2008/02/Services.wsdl/ReadResponse\u0022\nContent-Length: nnnn\nThe action parameter appears on the same line as the Content-Type declaration.\nAn example response Message:\n\u003Cs:Envelope xmlns:s=\u0022http://www.w3.org/2003/05/soap-envelope\u0022\u003E\n\u003Cs:Body\u003E\n\u003CReadResponse xmlns=\u0022http://opcfoundation.org/UA/2008/02/Types.xsd\u0022\u003E\n\u2026\n\u003C/ReadResponse\u003E\n\u003C/s:Body\u003E\n\u003C/s:Envelope\u003E"
    },
    {
      "Id": "ce6382c6-4cf9-4c50-959c-d35d932911d7",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4 OPC UA HTTPS\n---\n",
      "Content": "7.4.4 Binary Encoding"
    },
    {
      "Id": "0f1257ff-1065-4a98-810a-e6a88b25f813",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.4 Binary Encoding\n---\n",
      "Content": "This TransportProtocol implements the OPC UA Services using an OPC UA Binary encoded Messages exchanged over an HTTPS connection.\nApplications which support the HTTPS Profile shall support HTTP 1.1.\nThe body of the HTTP Messages shall be encoding using the OPC UA Binary DataEncoding. The Content-Type shall be \u0022application/octet-stream\u0022.\nAn example HTTP request header is:\nPOST /UA/SampleServer HTTP/1.1\nContent-Type: application/octet-stream\nContent-Length: nnnn\nAn example HTTP response header is:\nHTTP/1.1 200 OK\nContent-Type: application/octet-stream\nContent-Length: nnnn\nThe Message body is the request or response structure encoded as an ExtensionObject in OPC UA Binary. The Authorization header is only used for Session-less Service calls (see[7.4.2](/\u00A7_Ref468676596)).\nIf the OPC UA Binary DataEncoding is used for a Session-less Service the HTTP request header is:\nPOST /UA/SampleServer HTTP/1.1Authorization : Bearer \u003Cbase64-encoded-token-data\u003E\nContent-Type: application/octet-stream\nContent-Length: nnnn"
    },
    {
      "Id": "48214cda-43a6-4e74-950d-b374f600ca62",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4 OPC UA HTTPS\n---\n",
      "Content": "7.4.5 JSON Encoding"
    },
    {
      "Id": "a8deccc1-0688-4307-bbe0-906b541edd91",
      "Header": "Document: Part 6 - Mappings\nSection: 7.4.5 JSON Encoding\n---\n",
      "Content": "This TransportProtocol implements the OPC UA Services using JSON encoded Messages exchanged over an HTTPS connection.\nApplications which support the HTTPS Profile shall support HTTP 1.1.\nThe body of the HTTP Messages shall be encoded using the OPC UA JSON DataEncoding and the Content-Type shall be \u0027application/json\u0027. If the message is compressed the Content-Encoding shall be \u0027gzip\u0027.\nAn example HTTP request header is:\nPOST /UA/SampleServer HTTP/1.1Authorization : Bearer \u003Cbase64-encoded-token-data\u003E\nContent-Type: application/json\nContent-Length: nnnn\n\nAn example HTTP response header is:\nHTTP/1.1 200 OK\nContent-Type: application/jsonContent-Encoding: gzipContent-Length: nnnn"
    },
    {
      "Id": "f8afc929-a4fd-4de2-8415-073db8b95f30",
      "Header": "Document: Part 6 - Mappings\nSection: 7 TransportProtocols\n---\n",
      "Content": "7.5 WebSockets"
    },
    {
      "Id": "3dec2450-304a-4267-884c-d87c876c9c29",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5 WebSockets\n---\n",
      "Content": "7.5.1 Overview"
    },
    {
      "Id": "cf7460d7-0915-4272-b764-0119390ede09",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.1 Overview\n---\n",
      "Content": "This TransportProtocol sends OPC UA Connection Protocol messages over WebSockets.\nWebSockets is a bi-directional protocol for communication via a web server which is commonly used by browser-based applications to allow the web server to asynchronously send information to the client. WebSockets uses the same default port as HTTP or HTTPS and initiates communication with an HTTP request. This makes it very useful in environments where firewalls limit traffic to the ports used by HTTP or HTTPS.\nWebSockets use HTTP, however, in practice a WebSocket connection is only initiated with a HTTP GET request and the web server provides an HTTP response. After that exchange, all traffic uses the binary framing protocol defined by[RFC 6455](/\u00A7RFC6455).\nA Server that supports the WebSockets transport shall publish one or more Endpoints with the scheme \u0027opc.wss\u0027. The TransportProfileUri shall be one of the URIs for WebSockets transports defined in[OPC 10000-7](/\u00A7UAPart7). The TransportProfileUri specifies the encoding and security protocol used to construct the OPC UA messages sent via the WebSocket.\nThe SecurityMode and SecurityPolicyUri of the Endpoint control the security applied to the messages sent via the WebSocket. This allows the messages to be secure even if the WebSocket connection is established via untrusted HTTPS proxies.\n[Figure 22](/\u00A7_Ref468633763) summarizes the complete process for establishing communication over a WebSocket."
    },
    {
      "Id": "cd7c299d-bd3e-470f-b184-d5a0e966a232",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.1 Overview\nCaption: Figure 22 - Setting up Communication over a WebSocket\n---\n",
      "Content": "[image025.png](images/image025.png)"
    },
    {
      "Id": "d9287b95-231f-4e5a-a06a-536edfa7f6ca",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.1 Overview\n---\n",
      "Content": "Figure 22 - Setting up Communication over a WebSocket\n[Figure 22](/\u00A7_Ref468633763) assumes the opcua\u002Buacp sub-protocol (see[7.5.2](/\u00A7_Ref468637503)). There is no SecureChannel negotiation when using opcua\u002Bjson sub-protocol.\nThe default UserIdentity for any Session-less Service calls made over the WebSocket is specified by the opcua\u002Btoken sub-protocol. It may also be used to determine if the Client is allowed to create a Session."
    },
    {
      "Id": "c9eb77fb-fd39-49c2-8b64-63e0bc0c9f89",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5 WebSockets\n---\n",
      "Content": "7.5.2 Sub-Protocols"
    },
    {
      "Id": "0a7d4506-96a5-4875-8c10-9a63b8a88546",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.2 Sub-Protocols\n---\n",
      "Content": "The WebSocket protocol allows clients to request that servers use specific sub-protocols with the \u0022Sec-WebSocket-Protocol\u0022 header in the WebSocket handshake defined in[RFC 6455](/\u00A7RFC6455). The sub-protocols defined by this document are shown in[Table 79](/\u00A7_Ref468606127).\nTable 79- WebSocket Sub-Protocols\nSub-Protocol\nDescription\nopcua\u002Buacp\nEach WebSocket frame is a MessageChunk as defined in[6.7.2](/\u00A7_Ref164007251). After the WebSocket is created, the handshake described in[7.1.3](/\u00A7_Ref468608921) is used to negotiate the maximum size of the MessageChunk. The maximum size for a buffer needed to receive a WebSocket frame is the maximum length of a MessageChunk plus the maximum size for the WebSocket frame header.\nWhen using this sub-protocol, the payload in each frame is binary (OpCode 0x2 in[RFC 6455](/\u00A7RFC6455)).\nopcua\u002Buajson\nEach WebSocket frame is a Message encoded using the JSON encoding described in[5.4.9](/\u00A7_Ref468608977). There is no mechanism to negotiate the maximum frame size. If the receiver encounters a frame that exceeds its internal limits it shall close the WebSocket connection and provide a 1009 status code as described in[RFC 6455](/\u00A7RFC6455).\nThis sub-protocol is not recommended. The opcua\u002Bopenapi sub-protocol should be used instead.\nopcua\u002Bopenapi\nEach WebSocket frame is a ServiceMessageEnvelope de scribed in[G.3](/\u00A7_Ref175651074)"
    },
    {
      "Id": "c28750a9-61fc-4f43-956c-0120f3b3e83d",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.2 Sub-Protocols\n---\n",
      "Content": ". There is no mechanism to negotiate the maximum frame size. If the receiver encounters a frame that exceeds its internal limits it shall close the WebSocket connection and provide a 1009 status code as described in[RFC 6455](/\u00A7RFC6455).\nWhen using this sub-protocol, the payload in each frame is text (OpCode 0x1 in[RFC 6455](/\u00A7RFC6455)) if the frame contains UTF8 encoded JSON. If the frame contains JSON compressed with[RFC 1952](/\u00A7RFC1952) then the frame is binary (OpCode 0x2 in[RFC 6455](/\u00A7RFC6455)).\nopcua\u002Bopenapi\u002B\u003Caccesstoken\u003E\nThis sub-protocol is only used in addition to the opcua\u002Bopenapi sub-protocol.and specifies the default UserIdentity for all Requests sent over the WebSocket. The \u003Caccesstoken\u003E is the JSON WebToken (see[6.5.2](/\u00A7_Ref473652750)) and is normally passed in the HTTPS Authentication header.\nUsing a sub-protocol to provide an AccessToken is a widely used design pattern needed to deal with limitations of common WebSocket implementations.\n\nEach WebSocket sub-protocol defined has a TransportProfileUri defined in[OPC 10000-7](/\u00A7UAPart7).\nThe Client shall request a sub-protocol. If the Server does not support the sub-protocol requested by the Client, the Client shall close the connection and report an error."
    },
    {
      "Id": "4f5d3c97-96a3-46d3-b102-e317b6eaeaf4",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5 WebSockets\n---\n",
      "Content": "7.5.3 Security"
    },
    {
      "Id": "dad49c9d-c7a6-4466-9f50-f485ff818f29",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.3 Security\n---\n",
      "Content": "The WebSockets protocol requires that the Server have a Certificate, however, the Client may have a Certificate. The Server Certificate should have the domain name as the common name component of the subject name however, Clients that are able to override the Certificate validation procedure can choose to accept Certificates with a domain mismatch.\nWhen using the WebSockets transport from a web browser the browser environment may impose additional restrictions. For example, the web browser may require the Server have a valid TLS Certificate that is issued by CA that is installed in the Trust List for the web browser. To support these Clients, a Server may use a TLS Certificate that does not conform to the requirements for an ApplicationInstance Certificate. In these cases, the TLS Certificate is only used for TLS negotiation and the Server shall use a valid ApplicationInstance Certificate for other interactions that require one. Servers shall allow administrators to specify a Certificate for use with TLS that is different from the ApplicationInstance Certificate.\nClients running in a browser environment specify the \u0027Origin\u0027 HTTP header during the WebSocket upgrade handshake. Servers should return the \u0027Access-Control-Allow-Origin\u0027 to indicate that the connection is allowed.\nAny Client that does not run in a web browser environment and supports the WebSockets transport shall accept OPC UA ApplicationInstance Certificate as the TLS Certificate provided the correct domain is specified in the subjectAltName field.\nA Client may use its ApplicationInstance Certificate as the TLS Certificate and Servers shall accept those Certificates if they are valid according to the OPC UA Certificate validation rules.\nSome operating systems will not give the application any control over the set of algorithms that TLS will negotiate. In some cases, this set will be based on the needs of web browsers and will not be appropriate for the needs of an OPC UA Application. If this is a concern, applications should use OPC UA Secure Conversation in addition to TLS."
    },
    {
      "Id": "1cb96160-b5e5-49e3-8fbc-95a388adf39c",
      "Header": "Document: Part 6 - Mappings\nSection: 7.5.3 Security\n---\n",
      "Content": "Clients that support the WebSocket transport shall support explicit configuration of an HTTPS proxy. When using an HTTPS proxy, the Client shall first send an HTTP CONNECT message (see[HTTP](/\u00A7Http)) before starting the WebSocket protocol handshake. Note that explicit HTTPS proxies allow for man-in-the-middle attacks. This threat may be mitigated by using OPC UA Secure Conversation in addition to TLS."
    },
    {
      "Id": "163183ae-c44e-4546-a74e-b3fbf77559c6",
      "Header": "Document: Part 6 - Mappings\nSection: 7 TransportProtocols\n---\n",
      "Content": "7.6 Well known addresses"
    },
    {
      "Id": "e3e94156-7b62-48e8-ab93-0ccd6e9e6e36",
      "Header": "Document: Part 6 - Mappings\nSection: 7.6 Well known addresses\n---\n",
      "Content": "The Local Discovery Server(LDS) is an OPC UA Server that implements the Discovery Service Set defined in[OPC 10000-4](/\u00A7UAPart4). If an LDS is installed on a machine, it shall use one or more of the well-known addresses defined in[Table 80](/\u00A7_Ref211729160).\nTable 80- Well known addresses for Local Discovery Servers\nTransport Mapping\nURL\nNotes\nOPC UA TCP\nopc.tcp://localhost:4840/UADiscovery\n\nOPC UA WebSockets\nopc.wss://localhost:443/UADiscovery\n\nOPC UA HTTPS\nopc.https://localhost:443/UADiscovery\n\n\nOPC UA applications that make use of the LDS shall allow administrators to change the well-known addresses used within a system.\nThe Endpoint used by Servers to register with the LDS shall be the base address with the path \u0022/registration\u0022 appended to it (e.g.[http://localhost/UADiscovery/registration](http://localhost/UADiscovery/registration)). OPC UA Servers shall allow administrators to configure the address to use for registration.\nEach OPC UA Server application implements the Discovery Service Set. If the OPC UA Server requires a different address for this Endpoint, it shall create the address by appending the path \u0022/discovery\u0022 to its base address."
    },
    {
      "Id": "05f78567-00fd-4fda-8cea-02909c103fc2",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "8 Normative Contracts"
    },
    {
      "Id": "d19443f4-c686-46cb-a52c-7e5c0ca7fc1e",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.1 OPC Binary Schema"
    },
    {
      "Id": "346f9e1c-1493-4eeb-88ee-5ac68aeed19e",
      "Header": "Document: Part 6 - Mappings\nSection: 8.1 OPC Binary Schema\n---\n",
      "Content": "The normative contract for the OPC UA Binary Encoded Messages is an OPC Binary Schema. This file defines the structure of all types and Messages. The syntax for an OPC Binary Type Schema is described in[OPC 10000-3](/\u00A7UAPart3). This schema captures normative names for types and their fields as well the order the fields appear when encoded. The data type of each field is also captured."
    },
    {
      "Id": "5aa32023-08da-439a-8025-8674c635ae94",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.2 XML Schema and WSDL"
    },
    {
      "Id": "41fbaf76-690b-424e-bc5f-4e766d8095ae",
      "Header": "Document: Part 6 - Mappings\nSection: 8.2 XML Schema and WSDL\n---\n",
      "Content": "The normative contract for the OPC UA XML encoded Messages is an XML Schema. This file defines the structure of all types and Messages. This schema captures normative names for types and their fields as well the order the fields appear when encoded. The data type of each field is also captured.\nThe normative contract for Message sent via the SOAP/HTTP TransportProtocol is a WSDL that includes XML Schema for the OPC UA XML encoded Messages. It also defines the port types for OPC UA Servers and DiscoveryServers.\nLinks to the WSDL and XML Schema files can be found in[Annex D](/\u00A7_Ref201137945)."
    },
    {
      "Id": "7f74de35-9dca-47d8-9bab-f82b94cb600f",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.3 Information Model Schema"
    },
    {
      "Id": "df731acf-c45e-4f44-a6ef-05b05c69acc2",
      "Header": "Document: Part 6 - Mappings\nSection: 8.3 Information Model Schema\n---\n",
      "Content": "[Annex F](/\u00A7_Ref363018437) defines the schema to be used for Information Models."
    },
    {
      "Id": "e84f67ad-bad5-46b2-b9dd-da797c55e28f",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.4 Formal definition of UA Information Model"
    },
    {
      "Id": "9dc1e09b-0735-4b79-883c-e48da94394d0",
      "Header": "Document: Part 6 - Mappings\nSection: 8.4 Formal definition of UA Information Model\n---\n",
      "Content": "[Annex B](/\u00A7_Ref33887678) defines the OPC UA NodeSet"
    },
    {
      "Id": "b6665699-fe98-4700-bce3-270f9b1aa82f",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.5 Constants"
    },
    {
      "Id": "57f953c7-5155-4a77-b284-b90e1ea50fa3",
      "Header": "Document: Part 6 - Mappings\nSection: 8.5 Constants\n---\n",
      "Content": "[Annex A](/\u00A7_Ref33887697) defines constants for Attribute Ids, Status Codes and numeric NodeIds"
    },
    {
      "Id": "f32d98d3-c55d-4208-b6a7-82030df32ec5",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.6 DataType encoding"
    },
    {
      "Id": "4b9fdfa5-317e-4a1f-b290-f0c93c0c47bf",
      "Header": "Document: Part 6 - Mappings\nSection: 8.6 DataType encoding\n---\n",
      "Content": "[Annex C](/\u00A7_Ref33887718) defines the binary encoding for all DataTypes and Messages"
    },
    {
      "Id": "12ad5691-f562-465d-99d4-6851f9be017d",
      "Header": "Document: Part 6 - Mappings\nSection: 8 Normative Contracts\n---\n",
      "Content": "8.7 Security configuration"
    },
    {
      "Id": "5f21807f-0767-458d-9742-edfefff3bf35",
      "Header": "Document: Part 6 - Mappings\nSection: 8.7 Security configuration\n---\n",
      "Content": "[Annex E](/\u00A7_Ref293469646) defines a schema for security settings"
    },
    {
      "Id": "9c1c8324-e943-420a-af75-834a4c435a5d",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0A(normative)Constants\nA.1 Attribute Ids"
    },
    {
      "Id": "2edfe74f-7e89-4400-b10d-a76867c64cfe",
      "Header": "Document: Part 6 - Mappings\nSection: A.1 Attribute Ids\n---\n",
      "Content": "[Table A.1](/\u00A7_Ref468632488) shows Identifiers assigned to Attributes\nTable A. 1- Identifiers assigned to Attributes\nAttribute\nIdentifier\nNodeId\n1\nNodeClass\n2\nBrowseName\n3\nDisplayName\n4\nDescription\n5\nWriteMask\n6\nUserWriteMask\n7\nIsAbstract\n8\nSymmetric\n9\nInverseName\n10\nContainsNoLoops\n11\nEventNotifier\n12\nValue\n13\nDataType\n14\nValueRank\n15\nArrayDimensions\n16\nAccessLevel\n17\nUserAccessLevel\n18\nMinimumSamplingInterval\n19\nHistorizing\n20\nExecutable\n21\nUserExecutable\n22\nDataTypeDefinition\n23\nRolePermissions\n24\nUserRolePermissions\n25\nAccessRestrictions\n26\nAccessLevelEx\n27"
    },
    {
      "Id": "edc5c1f3-5f11-40b2-921f-b6de634bb0f0",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "A.2 Status Codes"
    },
    {
      "Id": "271aa6f2-f5a5-4216-8865-d60e69a36a50",
      "Header": "Document: Part 6 - Mappings\nSection: A.2 Status Codes\n---\n",
      "Content": "Clause[A.2](/\u00A7_Ref80223065) defines the numeric identifiers for all of the StatusCodes defined by the OPC UA Specification. The identifiers are specified in a UTF8 encoded CSV file with the following syntax:\n\u003CSymbolName\u003E, \u003CCode\u003E, \u003CDescription\u003E\nWhere the SymbolName is the literal name for the error code that appears in the specification and the Code is the hexadecimal value for the StatusCode(see[OPC 10000-4](/\u00A7UAPart4)). The severity associated with a particular code is specified by the prefix ( Good, Uncertain or Bad).\nThe CSV released with this version of the standards can be found here:\nhttps://reference.opcfoundation.org/files/StatusCode.csv?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest CSV that is compatible with this version of the standard can be found here:\n[https://reference.opcfoundation.org/files/StatusCode.csv?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/StatusCode.csv?u=http://opcfoundation.org/UA/)"
    },
    {
      "Id": "e8549065-1399-4eac-9659-2b8c7244e3e7",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "A.3 Numeric Node Ids"
    },
    {
      "Id": "63206601-85f0-4983-8bd1-8a697d20cf9e",
      "Header": "Document: Part 6 - Mappings\nSection: A.3 Numeric Node Ids\n---\n",
      "Content": "Clause[A.3](/\u00A7_Ref33903711) defines the numeric identifiers for all of the numeric NodeIds defined by the OPC UA Specification. The identifiers are specified in a UTF8 encoded CSV file. The syntax is informative and provided to assist developers of tools. The UANodeSet is the normative source for all identifiers.\nEach line in the CSV file has the following fields:\n\u003CSymbolName\u003E, \u003CIdentifier\u003E, \u003CNodeClass\u003E\nWhere the SymbolName is either the BrowseName of a Type Node or the BrowsePath for an Instance Node that appears in the specification and the Identifier is numeric value for the NodeId. Each SymbolName is unique within the CSV file.\nThe BrowsePath for an instance Node may be constructed by appending the BrowseName of the instance Node to BrowseName for the containing instance or type. A \u0027_\u0027 character is used to separate each BrowseName in the path. For example,[OPC 10000-5](/\u00A7UAPart5) defines the ServerType ObjectType Node which has the NamespaceArray Property. The SymbolName for the NamespaceArray InstanceDeclaration within the ServerType declaration is: ServerType_NamespaceArray.[OPC 10000-5](/\u00A7UAPart5) also defines a standard instance of the ServerType ObjectType with the BrowseName\u0027 Server\u0027. The BrowseName for the NamespaceArray Property of the standard Server Object is: Server_NamespaceArray.\nWhen Nodes do not have a parent that allows the creation of unique SymbolNames then an ad hoc convention is adopted. For example, DataTypeEncoding Nodes have the form:\n\u003CDataTypeName\u003E_Encoding_\u003CBrowseName\u003E\nThe NamespaceUri for all NodeIds defined is[http://opcfoundation.org/UA/](http://opcfoundation.org/UA/)\nThe CSV released with this version of the standards can be found here:"
    },
    {
      "Id": "ab56e7be-da84-406d-9076-491a58cb09e8",
      "Header": "Document: Part 6 - Mappings\nSection: A.3 Numeric Node Ids\n---\n",
      "Content": "https://reference.opcfoundation.org/files/NodeIds.csv?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest CSV that is compatible with this version of the standard can be found here:\n[https://reference.opcfoundation.org/files/NodeIds.csv?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/NodeIds.csv?u=http://opcfoundation.org/UA/)"
    },
    {
      "Id": "3088c617-b68e-4d94-a0a2-40a59c58da5a",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "A.4 Media Types"
    },
    {
      "Id": "44210ded-dfd4-4222-9af7-69dfcb9d5658",
      "Header": "Document: Part 6 - Mappings\nSection: A.4 Media Types\n---\n",
      "Content": "Globally defined media types are assigned by IANA. This clause lists the media types that have been assigned by IANA to document formats defined by OPC UA.\n[Table A.2](/\u00A7_Ref80139874) has media types assigned to OPC UA document formats.\nTable A. 2- Media Types Assigned to OPC UA Document Formats\nMedia Type\nDescription\napplication/opc-nodeset\u002Bxml\nAn XML document that conforms to the XML schema defined in[Annex F](/\u00A7_Ref363018437). It contains set of Nodes."
    },
    {
      "Id": "0a194b26-1e83-4d52-89d7-fe6284583e11",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0B(normative)OPC UA NodeSet"
    },
    {
      "Id": "c1534a55-a2b9-4f1a-8556-3c8f66abeec0",
      "Header": "Document: Part 6 - Mappings\nSection: Annex\u00A0B (normative)OPC UA NodeSet\n---\n",
      "Content": "The OPC UA NodeSet includes the complete Information Model defined in this document. It follows the XML Information Model schema syntax defined in[Annex F](/\u00A7_Ref363018437) and can thus be read and processed by a computer program.\nThe complete Information Model Schema for this version of this document (including any amendments and errata) can be found here:\nhttps://reference.opcfoundation.org/files/Opc.Ua.NodeSet2.Services.xml?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest Information Model schema that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/Opc.Ua.NodeSet2.Services.xml?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/Opc.Ua.NodeSet2.Services.xml?u=http://opcfoundation.org/UA/)\nThe complete Information Model Schema includes many types which are only used in Service Requests and Responses and should not be used by Servers to populate their Address Space.\nThe subset of the Information Model Schema for this version of this document (including any amendments and errata) that is used for creating Address Spaces can be found here:\nhttps://reference.opcfoundation.org/files/Opc.Ua.NodeSet2.xml?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest Information Model schema that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/Opc.Ua.NodeSet2.xml?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/Opc.Ua.NodeSet2.xml?u=http://opcfoundation.org/UA/)"
    },
    {
      "Id": "be7dad8e-4647-482c-9e5e-6206f80c84fb",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0C(normative)Type declarations for the OPC UA native Mapping"
    },
    {
      "Id": "e341a099-ec91-4666-b818-ee58842d03a5",
      "Header": "Document: Part 6 - Mappings\nSection: Annex\u00A0C (normative)Type declarations for the OPC UA native Mapping\n---\n",
      "Content": "Note: Deprecated in Version 1.05."
    },
    {
      "Id": "a3eba37c-9ac1-42ec-8d1f-a4ad7d3f949a",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0D(normative)WSDL for the XML Mapping\nD.1 XML Schema"
    },
    {
      "Id": "affb601f-1a84-4d38-828c-e22396f40911",
      "Header": "Document: Part 6 - Mappings\nSection: D.1 XML Schema\n---\n",
      "Content": "Clause[D.1](/\u00A7_Ref191076542) defines the XML Schema for all DataTypes and Messages defined in the OPC UA namespace\nThe XML Schema released with this version of this document can be found here:\nhttps://reference.opcfoundation.org/files/Opc.Ua.Types.xsd?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/Opc.Ua.Types.xsd?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/Opc.Ua.Types.xsd?u=http://opcfoundation.org/UA/)"
    },
    {
      "Id": "512cc8f1-fb88-469c-a41f-76b65412c5f5",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "D.2 WSDL Port Types"
    },
    {
      "Id": "367f61b8-efcf-4f9c-8abc-236fcf814f7f",
      "Header": "Document: Part 6 - Mappings\nSection: D.2 WSDL Port Types\n---\n",
      "Content": "Clause[D.2](/\u00A7_Ref191076575) defines the WSDL Operations and Port Types for all Services defined in[OPC 10000-4](/\u00A7UAPart4).\nThe WSDL released with this version of this document can be found here:\n[http://www.opcfoundation.org/UA/schemas/1.05/Opc.Ua.Services.wsdl](http://www.opcfoundation.org/UA/schemas/1.05/Opc.Ua.Services.wsdl)\nNOTE The latest file that is compatible with this version of this document can be found here:\n[http://opcfoundation.org/UA/2008/02/Services.wsdl](http://opcfoundation.org/UA/2008/02/Services.wsdl)\nThis WSDL imports the XML Schema defined in[D.1](/\u00A7_Ref191076542)."
    },
    {
      "Id": "125892e8-4271-4b10-8e32-ef629b6b211c",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "D.3 WSDL Bindings"
    },
    {
      "Id": "a65b63f3-3a71-4e90-8486-72d1c7b323de",
      "Header": "Document: Part 6 - Mappings\nSection: D.3 WSDL Bindings\n---\n",
      "Content": "Clause[D.3](/\u00A7_Ref33904003) defines the WSDL Bindings for all Services defined in[OPC 10000-4](/\u00A7UAPart4).\nThe WSDL released with this version of this document can be found here:\n[http://www.opcfoundation.org/UA/schemas/1.05/Opc.Ua.Endpoints.wsdl](http://www.opcfoundation.org/UA/schemas/1.05/Opc.Ua.Endpoints.wsdl)\nNOTE The latest file that is compatible with this version of this document can be found here:\n[http://opcfoundation.org/UA/2008/02/Endpoints.wsdl](http://opcfoundation.org/UA/2008/02/Endpoints.wsdl)\nThis WSDL imports the WSDL defined in[D.2](/\u00A7_Ref191076575)."
    },
    {
      "Id": "c347c6a1-8e80-4f5d-9cad-070c38eff72b",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0E(informative)Security settings management\nE.1 Overview"
    },
    {
      "Id": "320e86fd-a574-442c-b1dd-770ea3f5af0b",
      "Header": "Document: Part 6 - Mappings\nSection: E.1 Overview\n---\n",
      "Content": "All OPC UA applications support security; and this means that Administrators need to configure the security settings for the OPC UA application. Clause[E.1](/\u00A7_Ref33904026) describes an XML Schema which can be used to read and update the security settings for an OPC UA application. This schema provides a reference for application developers adding support for security configuration to their applications.\nThe XML Schema released with this version of the standards can be found here:\n[http://www.opcfoundation.org/UA/schemas/1.05/SecuredApplication.xsd](http://www.opcfoundation.org/UA/schemas/1.05/SecuredApplication.xsd)\nNOTE The latest file that is compatible with this version of this specification can be found here:\n[http://opcfoundation.org/UA/2011/03/SecuredApplication.xsd](http://opcfoundation.org/UA/2011/03/SecuredApplication.xsd)\nThe SecuredApplication schema can be supported in two ways:\nProviding an XML configuration file that can be edited directly;\nProviding an import/export utility that can be run as required;\nIf the application supports direct editing of an XML configuration file, then that file has exactly one element with the local name \u0027SecuredApplication\u0027 and URI equal to the SecuredApplication schema URI. A third-party configuration utility is able to parse the XML file, read and update the \u0027SecuredApplication\u0027 element. The administrator ensures that only authorized administrators can update this file. The following is an example of a configuration that can be directly edited:\n\u003Cs1:SampleConfiguration xmlns:s1=\u0022http://acme.com/UA/Sample/Configuration.xsd\u0022\u003E\n\u003CApplicationName\u003EACME UA Server\u003C/ApplicationName\u003E"
    },
    {
      "Id": "9cc89c11-41fc-4cef-8c52-cfefc355da9c",
      "Header": "Document: Part 6 - Mappings\nSection: E.1 Overview\n---\n",
      "Content": "\u003CApplicationUri\u003Eurn:myfactory.com:Machine54:ACME UA Server\u003C/ApplicationUri\u003E\n\n\u003C!-- any number of application specific elements --\u003E\n\n\u003CSecuredApplication xmlns=\u0022http://opcfoundation.org/UA/2011/03/SecuredApplication.xsd\u0022\u003E\n\u003CApplicationName\u003EACME UA Server\u003C/ApplicationName\u003E\n\u003CApplicationUri\u003Eurn:myfactory.com:Machine54:ACME UA Server\u003C/ApplicationUri\u003E\n\u003CApplicationType\u003EServer_0\u003C/ApplicationType\u003E\n\u003CApplicationCertificate\u003E\n\u003CStoreType\u003EWindows\u003C/StoreType\u003E\n\u003CStorePath\u003ELocalMachine\\My\u003C/StorePath\u003E\n\u003CSubjectName\u003EACME UA Server\u003C/SubjectName\u003E\n\u003C/ApplicationCertificate\u003E\n\u003C/SecuredApplication\u003E\n\n\u003C!-- any number of application specific elements --\u003E\n\n\u003CDisableHiResClock\u003Etrue\u003C/DisableHiResClock\u003E\n\u003C/s1:SampleConfiguration\u003E\nIf an application provides an import/export utility, then the import/export file is a document that conforms to the SecuredApplication schema. The administrator ensures that only authorized administrators can run the utility. The following is an example of a file used by an import/export utility:\n\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022 ?\u003E\n\u003CSecuredApplication xmlns=\u0022http://opcfoundation.org/UA/2011/03/SecuredApplication.xsd\u0022\u003E\n\u003CApplicationName\u003EACME UA Server\u003C/ApplicationName\u003E\n\u003CApplicationUri\u003Eurn:myfactory.com:Machine54:ACME UA Server\u003C/ApplicationUri\u003E\n\u003CApplicationType\u003EServer_0\u003C/ApplicationType\u003E\n\u003CConfigurationMode\u003Eurn:acme.com:ACME Configuration Tool\u003C/ConfigurationMode\u003E\n\u003CLastExportTime\u003E2011-03-04T13:34:12Z\u003C/LastExportTime\u003E"
    },
    {
      "Id": "7c3fad18-1e19-4d45-bae3-bf6dafbb63a7",
      "Header": "Document: Part 6 - Mappings\nSection: E.1 Overview\n---\n",
      "Content": "\u003CExecutableFile\u003E%ProgramFiles%\\ACME\\Bin\\ACME UA Server.exe\u003C/ExecutableFile\u003E\n\u003CApplicationCertificate\u003E\n\u003CStoreType\u003EWindows\u003C/StoreType\u003E\n\u003CStorePath\u003ELocalMachine\\My\u003C/StorePath\u003E\n\u003CSubjectName\u003EACME UA Server\u003C/SubjectName\u003E\n\u003C/ApplicationCertificate\u003E\n\u003CTrustedCertificateStore\u003E\n\u003CStoreType\u003EWindows\u003C/StoreType\u003E\n\u003CStorePath\u003ELocalMachine\\UA applications\u003C/StorePath\u003E\n\u003C!-- Offline CRL Checks by Default --\u003E\n\u003CValidationOptions\u003E16\u003C/ValidationOptions\u003E\n\u003C/TrustedCertificateStore\u003E\n\u003CTrustedCertificates\u003E\n\u003CCertificates\u003E\n\u003CCertificateIdentifier\u003E\n\u003CSubjectName\u003ECN=MyFactory CA\u003C/SubjectName\u003E\n\u003C!--  Online CRL Check for this CA --\u003E\n\u003CValidationOptions\u003E32\u003C/ValidationOptions\u003E\n\u003C/CertificateIdentifier\u003E\n\u003C/Certificates\u003E\n\u003C/TrustedCertificates\u003E\n\u003CRejectedCertificatesStore\u003E\n\u003CStoreType\u003EDirectory\u003C/StoreType\u003E\n\u003CStorePath\u003E%CommonApplicationData%\\OPC Foundation\\RejectedCertificates\u003C/StorePath\u003E\n\u003C/RejectedCertificatesStore\u003E\n\u003C/SecuredApplication\u003E"
    },
    {
      "Id": "312344e3-ccef-4be7-8838-ffa101de495f",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "E.2 SecuredApplication"
    },
    {
      "Id": "094615c9-265b-4a31-aec0-1a8f113d950c",
      "Header": "Document: Part 6 - Mappings\nSection: E.2 SecuredApplication\n---\n",
      "Content": "The SecuredApplication element specifies the security settings for an application. The elements contained in a SecuredApplication are described in[Table E.1](/\u00A7_Ref382473011).\nWhen an instance of a SecuredApplication is imported into an application the application updates its configuration based on the information contained within it. If unrecoverable errors occur during import an application does not make any changes to its configuration and report the reason for the error.\nThe mechanism used to import or export the configuration depends on the application. Applications ensure that only authorized users are able to access this feature.\nThe SecuredApplication element may reference X.509 v3 Certificates which are contained in physical stores. Each application needs to decide whether it uses shared physical stores which the administrator can control directly by changing the location or private stores that can only be accessed via the import/export utility. If the application uses private stores, then the contents of these private stores are copied to the export file during export. If the import file references shared physical stores, then the import/export utility copies the contents of those stores to the private stores.\nThe import/export utility does not export private keys. If the administrator wishes to assign a new public-private key to the application the administrator places the private key in a store where it can be accessed by the import/export utility. The import/export utility is then responsible for ensuring it is securely moved to a location where the application can access it.\nTable E. 1- SecuredApplication\nElement\nType\nDescription\nApplicationName\nString\nA human readable name for the application.\nApplications allow this value to be read or changed.\nApplicationUri\nString\nA globally unique identifier for the instance of the application.\nApplications allow this value to be read or changed.\nApplicationType\nApplicationType\nThe type of application.\nMay be one of"
    },
    {
      "Id": "47a9de6d-ddb5-4c24-9a25-c812a599a682",
      "Header": "Document: Part 6 - Mappings\nSection: E.2 SecuredApplication\n---\n",
      "Content": "May be one of\nServer_0;\nClient_1;\nClientAndServer_2;\nDiscoveryServer_3;\nApplications do not provide this value.\nApplications do not allow this value to be changed.\nProductName\nString\nA name for the product.\nApplications provide this value.\nApplications do not allow this value to be changed.\nConfigurationMode\nString\nIndicates how the application should be configured.\nAn empty or missing value indicates that the configuration file can be edited directly. The location of the configuration file is not provided in this case.\nAny other value is a URI that identifies the configuration utility. The vendor documentation explains how to use this utility.\nApplications provide this value.\nApplications do not allow this value to be changed.\nLastExportTime\nUtcTime\nWhen the configuration was exported by the import/export utility.\nIt may be omitted if applications allow direct editing of the security configuration.\nConfigurationFile\nString\nThe full path to a configuration file used by the application.\nApplications do not provide this value if an import/export utility is used.\nApplications do not allow this value to be changed.\nPermissions set on this file control who has rights to change the configuration of the application.\nExecutableFile\nString\nThe full path to an executable file for the application.\nApplications may not provide this value.\nApplications do not allow this value to be changed.\nPermissions set on this file control who has rights to launch the application.\nApplicationCertificate\nCertificateIdentifier\nThe identifier for the Application Instance Certificate.\nApplications allow this value to be read or changed.\nThis identifier may reference a Certificate store that contains the private key. If the private key is not accessible to outside applications this value contain the X.509 v3 Certificate for the application."
    },
    {
      "Id": "33ef5b00-ebf5-4433-a091-cb3a5322532e",
      "Header": "Document: Part 6 - Mappings\nSection: E.2 SecuredApplication\n---\n",
      "Content": "for the application.\nIf the configuration utility assigns a new private key this value reference the store where the private key is placed. The import/export utility may delete this private key if it moves it to a secure location accessible to the application.\nApplications allow Administrators to enter the password required to access the private key during the import operation. The exact mechanism depends on the application.\nApplications report an error if the ApplicationCertificate is not valid.\nTrustedCertificateStore\nCertificateStoreIdentifier\nThe location of the CertificateStore containing the Certificates of applications or Certificate Authorities (CAs) which can be trusted.\nApplications allow this value to be read or changed.\nThis value is a reference to a physical store which can be managed separately from the application. applications that support shared physical stores check this store for changes whenever they validate a Certificate.\nThe Administrator is responsible for verifying the signature on all Certificates placed in this store. This means the application may trust Certificates in this store even if they cannot be verified back to a trusted root.\nAdministrators place any CA certificates used to verify the signature in the IssuerStore or the IssuerList. This will allow applications to properly verify the signatures.\nThe application check the revocation status of the Certificates in this store if the Certificate was issued by a CA. The application looks for the offline Certificate Revocation List (CRL) for a CA in the store where it found the CA Certificate.\nThe location of an online CRL for CA is specified with the CRLDistributionPoints (OID= 2.5.29.31) X.509 v3 Certificate extension.\nThe ValidationOptions parameter is used to specify which revocation list should be used for CAs in this store.\nTrustedCertificates\nCertificateList\nA list of Certificates for applications for CAs that can be trusted."
    },
    {
      "Id": "04b38424-0318-459f-a6eb-f62a8157a479",
      "Header": "Document: Part 6 - Mappings\nSection: E.2 SecuredApplication\n---\n",
      "Content": "Applications allow this value to be read or changed.\nThe value is an explicit list of Certificates which is private to the application. It is used when the application does not support shared physical Certificate stores or when Administrators need to specify ValidationOptions for individual Certificates.\nIf the TrustedCertificateStore and the TrustedCertificates parameters are both specified, then the application uses the TrustedCertificateStore for checking trust relationships. The TrustedCertificates parameter is only used to lookup ValidationOptions for individual Certificates. It may also be used to provide CRLs for CA certificates.\nIf the TrustedCertificateStore is not specified, then TrustedCertificates parameter contains the complete X.509 v3 Certificate for each entry.\nIssuerStore\nCertificateStoreIdentifier\nThe location of the CertificateStore containing CA Certificates which are not trusted but are needed to check signatures on Certificates.\nApplications allow this value to be read or changed.\nThis value is a reference to a physical store which can be managed separately from the application. Applications that support shared physical stores check this store for changes whenever they validate a Certificate.\nThis store may also contain CRLs for the CAs.\nIssuerCertificates\nCertificateList\nA list of Certificates for CAs which are not trusted but are needed to check signatures on Certificates.\nApplications allow this value to be read or changed.\nThe value is an explicit list of Certificates which is private to the application. It is used when the application does not support shared physical Certificate stores or when Administrators need to specify ValidationOptions for individual Certificates.\nIf the IssuerStore and the IssuerCertificates parameters are both specified, then the application uses the IssuerStore for checking signatures. The IssuerCertificates parameter is only used to lookup ValidationOptions for individual Certificates. It may also be used to provide CRLs for CA certificates.\nRejectedCertificatesStore"
    },
    {
      "Id": "e98e1321-882d-4c1a-ac5e-5de525aa7060",
      "Header": "Document: Part 6 - Mappings\nSection: E.2 SecuredApplication\n---\n",
      "Content": "RejectedCertificatesStore\nCertificateStoreIdentifier\nThe location of the shared CertificateStore containing the Certificates of applications which were rejected.\nApplications allow this value to be read or changed.\nApplications add the DER encoded Certificate into this store whenever it rejects a Certificate because it is untrusted or if it failed one of the validation rules which can be suppressed (see Clause[E.6](/\u00A7_Ref221458960)).\nApplications do not add a Certificate to this store if it was rejected for a reason that cannot be suppressed (e.g. Certificate revoked).\nBaseAddresses\nString []\nA list of URLs for the Endpoints supported by a Server.\nApplications allow these values to be read or changed.\nIf a Server does not support the scheme for a URL it ignores it.\nThis list can have multiple entries for the same URL scheme. The first entry for a scheme is the base URL. The rest are assumed to be DNS aliases that point to the first URL.\nIt is the responsibility of the Administrator to configure the network to route these aliases correctly.\nSecurityProfileUris\nSecurityProfile []\n\nA list of SecurityPolicyUris supported by a Server. The URIs are defined as security Profiles in[OPC 10000-7](/\u00A7UAPart7).\nApplications allow these values to be read or changed.\nApplications allow the Enabled flag to be changed for each SecurityProfile that it supports.\nIf the Enabled flag is false, the Server do not allow connections using the SecurityProfile.\nIf a Server does not support a SecurityProfile it ignores it.\nExtensions\nxs:any []\nA list of vendor defined Extensions attached to the security settings.\nApplications ignore Extensions that they do not recognize.\nApplications that update a file containing Extensions do not delete or modify extensions that they do not recognize."
    },
    {
      "Id": "241c0c07-fe27-410c-80dd-9e5c7cfcac15",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "E.3 CertificateIdentifier"
    },
    {
      "Id": "f1feb1f3-a775-4edf-8bdd-3d87c587f3b8",
      "Header": "Document: Part 6 - Mappings\nSection: E.3 CertificateIdentifier\n---\n",
      "Content": "The CertificateIdentifier element describes an X.509 v3 Certificate. The Certificate can be provided explicitly within the element or the element can specify the location of the CertificateStore that contains the Certificate. The elements contained in a CertificateIdentifier are described in[Table E.2](/\u00A7_Ref382473076).\nTable E. 2- CertificateIdentifier\nElement\nType\nDescription\nStoreType\nString\nThe type of CertificateStore that contains the Certificate.\nPredefined values are \u0022Windows\u0022 and \u0022Directory\u0022.\nIf not specified, the RawData element is specified.\nStorePath\nString\nThe path to the CertificateStore.\nThe syntax depends on the StoreType.\nIf not specified, the RawData element is specified.\nSubjectName\nString\nThe SubjectName for the Certificate.\nThe Common Name (CN) component of the SubjectName.\nThe SubjectName represented as a string that complies with Section 3 of[RFC 4514](/\u00A7RFC4514).\nValues that do not contain \u0027=\u0027 characters are presumed to be the Common Name component.\nThumbprint\nString\nThe CertificateDigest for the Certificate formatted as a hexadecimal string.\nCase is not significant.\nRawData\nByteString\nThe DER encoded Certificate.\nThe CertificateIdentifier is invalid if the information in the DER Certificate conflicts with the information specified in other fields. Import utilities reject configurations containing invalid Certificates.\nThis field is not specified if the StoreType and StorePath are specified.\nValidationOptions\nInt32\nThe options to use when validating the Certificate. The possible options are described in[E.6](/\u00A7_Ref221458960).\nOfflineRevocationList\nByteString\nA Certificate Revocation List (CRL) associated with an Issuer Certificate.\nThe format of a CRL is defined by"
    },
    {
      "Id": "cfe46211-22af-41d3-a9c9-eb4727cca5db",
      "Header": "Document: Part 6 - Mappings\nSection: E.3 CertificateIdentifier\n---\n",
      "Content": "[RFC 5280](/\u00A7RFC3280).\nThis field is only meaningful for Issuer Certificates.\nOnlineRevocationList\nString\nA URL for an Online Revocation List associated with an Issuer Certificate.\nThis field is only meaningful for Issuer Certificates.\n\nA \u0022Windows\u0022 StoreType specifies a Windows Certificate store.\nThe syntax of the StorePath has the form:\n[\\\\HostName\\]StoreLocation[\\(ServiceName | UserSid)]\\StoreName\nwhere:\nHostName - the name of the machine where the store resides.\nStoreLocation - one of LocalMachine, CurrentUser, User or Service\nServiceName - the name of a Windows Service.\nUserSid - the SID for a Windows user account.\nStoreName - the name of the store (e.g. My, Root, Trust, CA, etc.).\nExamples of Windows StorePaths are:\n\\\\MYPC\\LocalMachine\\My\n\\CurrentUser\\Trust\n\\\\MYPC\\Service\\My UA Server\\UA applications\n\\User\\S-1-5-25\\Root\nA \u0022Directory\u0022 StoreType specifies a directory on disk which contains files with DER encoded Certificates. The name of the file is the CertificateDigest for the Certificate. Only public keys may be placed in a \u0022Directory\u0022 Store. The StorePath is an absolute file system path with a syntax that depends on the operating system.\nIf a \u0022Directory\u0022 store contains a \u0027certs\u0027 subdirectory, then it is presumed to be a structured store with the subdirectories described in[Table E.3](/\u00A7_Ref397329771).\nTable E. 3- Structured directory store\nSubdirectory\nDescription\ncerts\nContains the DER encoded X.509 v3 Certificates.\nThe files have a .der file extension.\nprivate"
    },
    {
      "Id": "965efc70-b84c-4798-981d-f2d69f87539b",
      "Header": "Document: Part 6 - Mappings\nSection: E.3 CertificateIdentifier\n---\n",
      "Content": "private\nContains the private keys.\nThe format of the file may be application specific.\nPEM encoded files should have a .pem extension.\nPKCS#12 encoded files should have a .pfx extension.\nThe root file name is the same as the corresponding public key file in the certs directory.\ncrl\nContains the DER encoded CRL for any CA Certificates found in the certs or ca directories.\nThe files have a .crl file extension.\n\nEach Certificate is uniquely identified by its Thumbprint. The SubjectName or the distinguished SubjectName may be used to identify a Certificate to a human; however, they are not unique. The SubjectName may be specified in conjunction with the Thumbprint or the RawData. If there is an inconsistency between the information provided, then the CertificateIdentifier is invalid. Invalid CertificateIdentifiers are handled differently depending on where they are used.\nIt is recommended that the SubjectName always be specified.\nA Certificate revocation list (CRL) contains a list of certificates issued by a CA that are no longer trusted. These lists should be checked before an application can trust a Certificate issued by a trusted CA. The format of a CRL is defined by[RFC 5280](/\u00A7RFC3280).\nOffline CRLs are placed in a local Certificate store with the Issuer Certificate. Online CRLs may exist but the protocol depends on the system. An online CRL is identified by a URL."
    },
    {
      "Id": "4656eac4-eed4-459f-bb4f-3ac626444dba",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "E.4 CertificateStoreIdentifier"
    },
    {
      "Id": "6fafc6e4-6bb8-41d0-8cb1-c876a5d79543",
      "Header": "Document: Part 6 - Mappings\nSection: E.4 CertificateStoreIdentifier\n---\n",
      "Content": "The CertificateStoreIdentifier element describes a physical store containing X.509 v3 Certificates. The elements contained in a CertificateStoreIdentifier are described in[Table E.4](/\u00A7_Ref397329759).\nTable E. 4- CertificateStoreIdentifier\nElement\nType\nDescription\nStoreType\nString\nThe type of CertificateStore that contains the Certificate.\nPredefined values are \u0022Windows\u0022 and \u0022Directory\u0022.\nStorePath\nString\nThe path to the CertificateStore.\nThe syntax depends on the StoreType.\nSee[E.3](/\u00A7_Ref90961021) for a description of the syntax for different StoreTypes.\nValidationOptions\nCertificateValidationOptions\nThe options to use when validating the Certificates contained in the store.\nThe possible options are described in[E.6](/\u00A7_Ref221458960).\n\nAll Certificates are placed in a physical store which can be protected from unauthorized access. The implementation of a store can vary and will depend on the application, development tool or operating system. A Certificate store may be shared by many applications on the same machine.\nEach Certificate store is identified by a StoreType and a StorePath. The same path on different machines identifies a different store."
    },
    {
      "Id": "754e99f5-3890-4493-a901-70eb41ad4dd3",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "E.5 CertificateList"
    },
    {
      "Id": "6aa9c578-1d03-48ef-943a-f9bf0022a212",
      "Header": "Document: Part 6 - Mappings\nSection: E.5 CertificateList\n---\n",
      "Content": "The CertificateList element is a list of Certificates. The elements contained in a CertificateList are described in[Table E.5](/\u00A7_Ref397329749).\nTable E. 5- CertificateList\nElement\nType\nDescription\nCertificates\nCertificateIdentifier []\nThe list of Certificates contained in the Trust List\nValidationOptions\nCertificateValidationOptions\nThe options to use when validating the Certificates contained in the store.\nThese options only apply to Certificates that have ValidationOptions with the UseDefaultOptions bit set. The possible options are described in[E.6](/\u00A7_Ref221458960)."
    },
    {
      "Id": "9b3efb7c-43ea-410f-ab77-b052e576dd3e",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "E.6 CertificateValidationOptions"
    },
    {
      "Id": "ff1fe612-c18f-44c4-9ca1-ab625aa8e6c9",
      "Header": "Document: Part 6 - Mappings\nSection: E.6 CertificateValidationOptions\n---\n",
      "Content": "The CertificateValidationOptions control the process used to validate a Certificate. Any Certificate can have validation options associated. If none are specified, the ValidationOptions for the store or list containing the Certificate are used. The possible options are shown in[Table E.6](/\u00A7_Ref397329736). Note that suppressing any validation step can create security risks which are discussed in more detail in[OPC 10000-2](/\u00A7UAPart2). An audit log entry is created if any error is ignored because a validation option is suppressed.\nTable E. 6- CertificateValidationOptions\nField\nBit\nDescription\nSuppressCertificateExpired\n0\nIgnore errors related to the validity time of the Certificate or its issuers.\nSuppressHostNameInvalid\n1\nIgnore mismatches between the host name or ApplicationUri.\nSuppressRevocationStatusUnknown\n2\nIgnore errors if the issuer\u0027s revocation list cannot be found.\nCheckRevocationStatusOnline\n3\nCheck the revocation status online.\nIf set, the validator will look for the authorityInformationAccess extension to find an OCSP (RFC 6960) endpoint which can be used to determine if the Certificate has been revoked.\nIf the OCSP endpoint is not reachable then the validator will look for offline CRLs if the CheckRevocationStatusOffline bit is set. Otherwise, validation fails.\nThis option is specified for Issuer Certificates and used when validating Certificates issued by that Issuer.\nCheckRevocationStatusOffline\n4\nCheck the revocation status offline.\nIf set the validator will look a CRL in the Certificate Store where the CA Certificate was found.\nValidation fails if a CRL is not found.\nThis option is specified for Issuer Certificates and used when validating Certificates issued by that Issuer.\nUseDefaultOptions\n5\nIf set the CertificateValidationOptions"
    },
    {
      "Id": "7c5c223c-086d-4dbe-9073-489fdf3e7fbb",
      "Header": "Document: Part 6 - Mappings\nSection: E.6 CertificateValidationOptions\n---\n",
      "Content": "CertificateValidationOptions from the CertificateList is used.\nIf a Certificate does not belong to a CertificateList then the default is 0 for all bits."
    },
    {
      "Id": "0c8933a6-3241-48bc-a5a1-0ddf9ad91feb",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0F(normative)Information Model XML Schema\nF.1 Overview"
    },
    {
      "Id": "7d8fc28d-223c-48d0-9b62-8a775fd444e3",
      "Header": "Document: Part 6 - Mappings\nSection: F.1 Overview\n---\n",
      "Content": "Information Model developers define standard AddressSpaces which are implemented by many Servers. There is a need for a standard syntax that Information Model developers can use to formally define their models in a form that can be read by a computer program.[Annex F](/\u00A7_Ref363018437) defines an XML-based schema for this purpose.\nThe XML Schema released with this version of the standards can be found here:\nhttps://reference.opcfoundation.org/files/UANodeSet.xsd?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of the standards can be found here:\n[https://reference.opcfoundation.org/files/UANodeSet.xsd?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/UANodeSet.xsd?u=http://opcfoundation.org/UA/)\nThe schema document is the formal definition. The description in[Annex F](/\u00A7_Ref363018437) only discusses details of the semantics that cannot be captured in the schema document. Types which are self-describing are not discussed.\nThis schema can also be used to serialize (i.e. import or export) an arbitrary set of Nodes in the Server Address Space. This serialized form can be used to save Server state for use by the Server later or to exchange with other applications (e.g. to support offline configuration by a Client).\nThis schema only defines a way to represent the structure of Nodes. It is not intended to represent the numerous semantic rules which are defined in other parts of the OPC UA specification. Consumers of data serialized with this schema need to handle inputs that conform to the schema, however, do not conform to the OPC UA specification because of one or more semantic rule violations.\nThere are cases where an Information Model defines Nodes"
    },
    {
      "Id": "d209b2cf-17b4-4dc8-b497-c5644866b57c",
      "Header": "Document: Part 6 - Mappings\nSection: F.1 Overview\n---\n",
      "Content": "Information Model defines Nodes such as standard Properties which can be attached to many different Nodes. These Nodes are represented in the UANodeSet as Nodes which are not a target of any reference that would make them visible in an AddressSpace.\nThe tables defining the DataTypes in the specification have field names starting with a lowercase letter. The first letter shall be converted to upper case when the field names are formally defined in a UANodeSet.\nEvery UANodeSet that defines DataTypes has associated schema files that define how to serialize the DataTypes using the UA Binary Encoding ([5.2](/\u00A7_Ref163962885)) and the UA XML Encoding ([5.3](/\u00A7_Ref131702289)). The XML schema file may be referenced by the UANodeSet if it includes Variable Values([F.8](/\u00A7_Ref79442048)) for one or more of the DataTypes defined in the UANodeSet. The namespace URI assigned to the XML schema is set by the tool that generated it. The URI for the XML schema for OPC UA DataTypes is[http://opcfoundation.org/UA/2008/02/Types.xsd](http://opcfoundation.org/UA/2008/02/Types.xsd)."
    },
    {
      "Id": "6c0c2ee0-becf-42b7-8348-48a3bc404533",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.2 UANodeSet"
    },
    {
      "Id": "ebb8eee5-18b4-4645-9fba-a929aa7d8d8b",
      "Header": "Document: Part 6 - Mappings\nSection: F.2 UANodeSet\n---\n",
      "Content": "The UANodeSet is the root of the document. It defines a set of Nodes, their Attributes and References. References to Nodes outside of the document are allowed.\nThe structure of a UANodeSet is shown in[Table F.1](/\u00A7_Ref397325999).\nTable F. 1- UANodeSet\nElement\nType\nDescription\nNamespaceUris\nUriTable\nA list of NamespaceUris used in the UANodeSet.\nThis array shall have at least one entry which is equal to the ModelUri for each entry in the Models array.\nAll entries in this list shall have an entry in Model array or an entry in the RequiredModel arrays.\nServerUris\nUriTable\nA list of ServerUris used in the UANodeSet.\nModels\nModelTableEntry []\nA list of models that are defined in the UANodeSet along with any dependencies these models have.\nModelUri\nString\nThe URI for the model.\nThis URI shall be one of the entries in the NamespaceUris table.\nXmlSchemaUri\nString\nThe URI for the XML schema namespace used to serialize values of the DataTypes defined by the Model.\nThe field is required if DataTypes are defined in the UANodeSet.\nThe UA XML Encoding ([5.3](/\u00A7_Ref131702289)) rules implicitly define the XML schema for any DataType described by a DataTypeDefinition([F.12](/\u00A7_Ref472366023)).\nVersion\nString\nThe version of the model defined in the UANodeSet.\nThis is a human readable string and not intended for programmatic comparisons.\nPublicationDate\nDateTime\nWhen the model was published.\nThis value is used for comparisons if the Model is defined in multiple UANodeSet"
    },
    {
      "Id": "71afaad0-9429-4fd4-b501-2be90cdd759d",
      "Header": "Document: Part 6 - Mappings\nSection: F.2 UANodeSet\n---\n",
      "Content": "UANodeSet files when the ModelVersion is not provided.\nModelVersion\nVersionString\nThe version of the UANodeSet expressed as a string which conforms to the syntax defined in the[SemVer](/\u00A7SemVer) specification. The comparison rules from the specification are used to determine which UANodeSet precedes another.\nWhen comparing two UANodeSets the following rules apply:\nWhen the ModelVersion is specified in both UANodeSets it is used for the comparison and if they are the same then the PublicationDate is used.\nWhen the ModelVersion is specified in only one UANodeSet it is considered newer than the one without the ModelVersion. The PublicationDate is ignored.\nWhen the ModelVersion is not specified in either UANodeSet the PublicationDate is used for comparison.\nThe ModelVersion is mandatory for all UANodeSets conforming to version 1.05.02 or later of this specification.\nRolePermissions\nRolePermission []\nThe list of default RolePermissions for all Nodes in the model.\nAccessRestrictions\nAccessRestriction\nThe default AccessRestrictions that apply to all Nodes in the model.\nThe default value is 0.\nRequiredModels\nModelTableEntry []\nA list of dependencies for the model.\nIf the model requires a minimum version, the ModelVersion and PublicationDate shall be specified. Tools which attempt to resolve these dependencies may accept any model with the same or later ModelVersion and if ModelVersion is the same then accept the same or later PublicationDate.\nThe RolePermission and AccessRestrictions elements shall not be specified for any entry in this list.\nA dependency shall only be specified if the ModelUri is in the NamespaceUris list.\nEntries in this list shall not have any RequiredModels.\nAliases\nAliasTable"
    },
    {
      "Id": "b8832f3a-f7ba-4c83-85ed-cea5ea3b1d45",
      "Header": "Document: Part 6 - Mappings\nSection: F.2 UANodeSet\n---\n",
      "Content": "Aliases\nAliasTable\nA list of UANodeSet aliases used in the UANodeSet.\nExtensions\nxs:any []\nAn element containing a list of vendor defined extensions to the UANodeSet.\nLastModified\nDateTime\nThe last time a document was modified.\n\u003Cchoice\u003E\nUAObject\nUAVariable\nUAMethod\nUAView\nUAObjectType\nUAVariableType\nUADataType\nUAReferenceType\nThe Nodes in the UANodeSet.\nThe NamespaceUris is a list of URIs for namespaces used in the UANodeSet. The NamespaceIndexes used in NodeIds, ExpandedNodeIds and QualifiedNames identify an element in this list. The first index is always 1 (0 is always the OPC UA namespace).\nThe ServerUris is a list of URIs for Servers referenced in the UANodeSet. The ServerIndex in ExpandedNodeIds identifies an element in this list. The first index is always 1 (0 is always the current Server).\nThe Models element specifies the Models which are formally defined by the UANodeSet. It includes version information as well as information about any dependencies which the model may have. If a Model is defined in the UANodeSet then the file shall also define an instance of the NamespaceMetadataType ObjectType. See[OPC 10000-5](/\u00A7UAPart5) for more information. Following the references in the RequiredModels field shall not result in circular dependencies.\nThe XML schema file associated with a UANodeSet shall have an XML annotation with a Model element that identifies the associated UANodeSet with the form:\n\u003Cxs:annotation\u003E\n\u003Cxs:appinfo\u003E\n\u003Cua:Model\nModelUri=\u0022\u003Cmodel-uri\u003E\u0022       ModelVersion=\u0022\u003Cmodel-version\u003E\u0022       PublicationDate=\u0022\u003Cpublication-date\u003E\u0022\n/\u003E"
    },
    {
      "Id": "0981192d-d2b6-4a79-bd26-88f2d5684696",
      "Header": "Document: Part 6 - Mappings\nSection: F.2 UANodeSet\n---\n",
      "Content": "/\u003E\n\u003C/xs:appinfo\u003E\n\u003C/xs:annotation\u003E\n\nWhere:\n\u003Cmodel-uri\u003E is the URI of the associated UANodeSet;\n\u003Cmodel-version\u003E is the SemVer of the associated UANodeSet;\n\u003Cpublication-date\u003E is the date the associated UANodeSet was published.\n\nWhen NodeSets are normative documents for a specification, they can include Nodes, such as unattached Properties, that exist only to formally define elements of the specification. For example, the base NodeSet for this specification includes an unattached Property Node called \u0022NodeVersion\u0022 which can be added to any Node. The Node in the NodeSet defines the BrowseName, DataType and ValueRank.\nThe UANodeSet aliases are a list of string substitutions for NodeIds. UANodeSet aliases can be used to make the file more readable by allowing a string like \u0027HasProperty\u0027 in place of a numeric NodeId(i=46). Aliases are optional. Aliases may only be used in fields defined in this Annex that have the NodeId type such as ParentNodeId([F.7](/\u00A7_Ref472619842)) or DataType([F.8](/\u00A7_Ref148460936)). Fields with the Variant type shall not contain UANodeSet aliases.\nThe Extensions are free form XML data that can be used to attach vendor defined data to the UANodeSet."
    },
    {
      "Id": "31a76d96-9aaa-467e-8f5a-2880ede8b771",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.3 UANode"
    },
    {
      "Id": "37d711d0-8d31-4bde-89ae-6665a5e1deb0",
      "Header": "Document: Part 6 - Mappings\nSection: F.3 UANode\n---\n",
      "Content": "A UANode is an abstract base type for all Nodes. It defines the base set of Attributes and the References. There are subtypes for each NodeClass defined in[OPC 10000-4](/\u00A7UAPart4). Each of these subtypes defines XML elements and attributes for the OPC UA Attributes specific to the NodeClass. The fields in the UANode type are defined in[Table F.2](/\u00A7_Ref397326059).\nTable F. 2- UANode\nElement\nType\nDescription\nNodeId\nNodeId\nA NodeId serialized as a String.\nThe syntax of the serialized String is defined in[5.3.1.10](/\u00A7_Ref293890313).\nBrowseName\nQualifiedName\nA QualifiedName serialized as a String with the form:\n\u003Cnamespace index\u003E:\u003Cname\u003E\nWhere the NamespaceIndex refers to the NamespaceUris table.\nSymbolicName\nString\nA symbolic name for the Node that can be used as a class/field name in auto generated code. It should only be specified if the BrowseName cannot be used for this purpose.\nThis field does not appear in the AddressSpace and is intended for use by design tools. Only letters, digits or the underscore (\u0027_\u0027) are permitted and the first character shall be a letter.\nWriteMask\nWriteMask\nThe value of the WriteMask Attribute.\nUserWriteMask\nWriteMask\nNot used. Kept in schema for backward compatibility.\nAccessRestrictions\nAccessRestriction\nThe AccessRestrictions that apply to the Node.\nThis attribute is optional.\nIf not specified the AccessRestrictions for the Model are applied.\nDisplayName\nLocalizedText []\nA list of DisplayNames for the Node in different locales.\nThere shall be only one entry per locale.\nDescription"
    },
    {
      "Id": "7a2bca9d-9b51-4eea-8377-7278c85141d2",
      "Header": "Document: Part 6 - Mappings\nSection: F.3 UANode\n---\n",
      "Content": "Description\nLocalizedText []\nThe list of the Descriptions for the Node in different locales.\nThere shall be only one entry per locale.\nCategory\nString []\nA list of ConformanceUnits associated with the Node.\nThe ConformanceUnits are specified by the authors of the UANodeSet and allow users of the UANodeSet to exclude Nodes based on a selection of ConformanceUnits.\nWhen an UAInstance has the ParentNodeId specified, the UAInstance inherits the ConformanceUnits from its parent in addition to any ConformanceUnits explicitly specified on the instance.\nDocumentation\nString\nAdditional non-localized documentation for use by tools that create/edit UANodeSet files.\nReleaseStatus\nReleaseStatus\nAn enumeration specifying the release status for the UANode.\nValid values are:\nReleased: The type is released. Changes require errata;\nDraft: The type is draft and subject to change;\nDeprecated: The type should not be used;\nThis field is for use on UATypes and static UAInstances. The field shall not be specified for UAInstances that are InstanceDeclarations.\nReferences\nReference []\nThe list of References for the Node.\nRolePermissions\nRolePermission []\nThe list of RolePermissions for the Node.\nIf the list is not specified or has zero length the default RolePermissions from the Model are used unless HasNoPermissions is TRUE.\nHasNoPermissions\nBoolean\nIf TRUE, the UANode has no RolePermissions and the contents of the RolePermissions array and the default RolePermissions for the model are ignored. The default value is FALSE.\nExtensions\nxs:any []\nAn element containing a list of vendor defined extensions to the UANode.\nThe Extensions are free form XML data that can be used to attach vendor defined data to the UANode."
    },
    {
      "Id": "ee0464a3-8cd0-48dd-bde6-5f44e689f29f",
      "Header": "Document: Part 6 - Mappings\nSection: F.3 UANode\n---\n",
      "Content": "UANode.\nArray values are denoted with [], however, in the XML Schema arrays are mapped to a complex type starting with the \u0027ListOf\u0027 prefix.\nA UANodeSet is expected to contain many UANodes which reference each other. Tools that create UANodeSets should not add Reference elements for both directions in order to minimize the size of the XML file. Tools that read the UANodeSets shall automatically add reverse references unless reverse references are not appropriate given the ReferenceType semantics. HasTypeDefinition and HasModellingRule are two examples where it is not appropriate to add reverse references.\nWhen a UANodeSet is the normative definition for the Nodes defined by a specification then the RolePermissions are the minimum requirements. Implementors may add additional Roles that have privileges equivalent to the Roles specified, however, they may not make the Node more accessible. For example, Anonymous or AuthenticatedUser Roles shall not be granted more access to the Node than is specified in this field.\nSimilarly, the AccessRestrictions are the minimum required. For example, a Node that has the EncryptionRequired AccessRestriction specified shall not have that restriction removed, however, additional restrictions may be added by the implementor. Note, that a UANodeSet represents a collection of Nodes in an address space. This implies that any instances shall include the fully inherited InstanceDeclarationHierarchy as defined in[OPC 10000-3](/\u00A7UAPart3)."
    },
    {
      "Id": "fc678bff-426a-484a-bae0-d221accdf383",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.4 Reference"
    },
    {
      "Id": "68cd9168-97a8-4039-8541-c4ca641a9554",
      "Header": "Document: Part 6 - Mappings\nSection: F.4 Reference\n---\n",
      "Content": "The Reference type specifies a Reference for a Node. The Reference can be forward or inverse. Only one direction for each Reference needs to be in a UANodeSet. The other direction shall be added automatically during any import operation. The fields in the Reference type are defined in[Table F.3](/\u00A7_Ref397326073).\nTable F. 3- Reference\nElement\nType\nDescription\nNodeId\nNodeId\nThe NodeId of the target of the Reference serialized as a String.\nThe syntax of the serialized String is defined in[5.3.1.11](/\u00A7_Ref293890208)( ExpandedNodeId).\nThis value can be replaced by an Alias.\nReferenceType\nNodeId\nThe NodeId of the ReferenceType serialized as a String.\nThe syntax of the serialized String is defined in[5.3.1.10](/\u00A7_Ref293890313)( NodeId).\nThis value can be replaced by an Alias.\nIsForward\nBoolean\nIf TRUE, the Reference is a forward reference."
    },
    {
      "Id": "18578186-0eec-44c0-87d0-fbea9cf6879d",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.5 RolePermission"
    },
    {
      "Id": "484eae1d-fa90-4bf8-a4d8-65ea7f8607a4",
      "Header": "Document: Part 6 - Mappings\nSection: F.5 RolePermission\n---\n",
      "Content": "The RolePermission type specifies the Permissions granted to Role for a Node. The fields in the RolePermission type are defined in[Table F.4](/\u00A7_Ref469512740).\nTable F. 4- RolePermission\nElement\nType\nDescription\nNodeId\nNodeId\nThe NodeId of the Role which has the Permissions.\nPermissions\nUInt32\nA bitmask specifying the Permissions granted to the Role.\nThe bitmask values the Permissions bits defined in[OPC 10000-3](/\u00A7UAPart3)."
    },
    {
      "Id": "9c009057-92e7-495d-a698-e5fc01df4faf",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.6 UAType"
    },
    {
      "Id": "e69c2a83-2cf2-4163-916c-0c45b0a2f836",
      "Header": "Document: Part 6 - Mappings\nSection: F.6 UAType\n---\n",
      "Content": "A UAType is a subtype of the UANode defined in[F.3](/\u00A7_Ref311621445). It is the base type for the types defined in[Table F.5](/\u00A7_Ref382473263).\nTable F. 5- UANodeSet Type Nodes\nSubtype\nDescription\nUAObjectType\nDefines an ObjectType Node as described in[OPC 10000-3](/\u00A7UAPart3).\nUAVariableType\nDefines a VariableType Node as described in[OPC 10000-3](/\u00A7UAPart3).\nUADataType\nDefines a DataType Node as described in[OPC 10000-3](/\u00A7UAPart3).\nUAReferenceType\nDefines a ReferenceType Node as described in[OPC 10000-3](/\u00A7UAPart3)."
    },
    {
      "Id": "561cabc0-cdbe-43aa-ac31-8da6f75cf43f",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.7 UAInstance"
    },
    {
      "Id": "adb43e70-5704-4aaa-8c37-b7f564350985",
      "Header": "Document: Part 6 - Mappings\nSection: F.7 UAInstance\n---\n",
      "Content": "A UAInstance is a subtype of the UANode defined in[F.3](/\u00A7_Ref311621445). It is the base type for the types defined in[Table F.6](/\u00A7_Ref397326113). The fields in the UAInstance type are defined in[Table F.7](/\u00A7_Ref397326129). Subtypes of UAInstance which have fields in addition to those defined in[OPC 10000-3](/\u00A7UAPart3) are described in detail below.\nTable F. 6- UANodeSet Instance Nodes\nSubtype\nDescription\nUAObject\nDefines an Object Node as described in[OPC 10000-3](/\u00A7UAPart3).\nUAVariable\nDefines a Variable Node as described in[OPC 10000-3](/\u00A7UAPart3).\nUAMethod\nDefines a Method Node as described in[OPC 10000-3](/\u00A7UAPart3).\nUAView\nDefines a View Node as described in[OPC 10000-3](/\u00A7UAPart3).\n\nTable F. 7- UAInstance\nElement\nType\nDescription\nAll of the fields from the UANode type described in[F.3](/\u00A7_Ref311621445).\nParentNodeId\nNodeId\nThe NodeId of the Node that is the parent of the Node within the information model. This field is used to indicate that a tight coupling exists between the Node and its parent (e.g., when the parent is deleted, the child is deleted as well). This information does not appear in the AddressSpace and is intended for use by design tools.\nThis field shall be specified for all InstanceDeclarations and shall reference a UANode which is the source of a"
    },
    {
      "Id": "7219dc3c-58b0-4442-abec-e1ef147fbd4d",
      "Header": "Document: Part 6 - Mappings\nSection: F.7 UAInstance\n---\n",
      "Content": "HierarchicalReference to the Node.\nDesignToolOnly\nBoolean\nIf TRUE the instance is a placeholder for use by design tools and does not appear in the AddressSpace. For example, well-known Properties or Objects.\nOnly UAObject and UAVariable Nodes may have DesignToolOnly is TRUE.\nIf DesignToolOnly is TRUE, the ParentNodeId shall not be specified and the UAInstance may not be the target of references from other Nodes and may not be the ParentNodeId for other instances. This implies that child Nodes, even Mandatory ones, are not added to the Node.\nThe HasTypeDefinition reference shall be specified."
    },
    {
      "Id": "4ead8052-301d-4d04-a02a-3cca39c39054",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.8 UAVariable"
    },
    {
      "Id": "4fff9233-a5f3-428d-bcff-5513433ffd96",
      "Header": "Document: Part 6 - Mappings\nSection: F.8 UAVariable\n---\n",
      "Content": "A UAVariable is a subtype of the UAInstance defined in. It represents a Variable Node. The fields in the UAVariable type are defined in[Table F.8](/\u00A7_Ref397326141).\nTable F. 8- UAVariable\nElement\nType\nDescription\nAll of the fields from the UAInstance type described in[F.7](/\u00A7_Ref472619842).\nValue\nVariant\nThe Value of the Node encoding using the UA XML wire encoding defined in[5.3](/\u00A7_Ref131702289).\nIf a Value is not provided and a UANodeSet is used to initialize a Server AddressSpace then the Server shall report a StatusCode of Bad_NoValue or choose a default Value consistent with the DataType and ValueRank.\nTranslation\nTranslationType []\nA list of translations for the Value if the Value is a LocalizedText or a structure containing LocalizedTexts.\nThis field may be omitted.\nIf the Value is an array the number of elements in this array shall match the number of elements in the Value. Extra elements are ignored.\nIf the Value is a scalar, then there is one element in this array.\nIf the Value is a structure, then each element contains translations for one or more fields identified by a name. See the TranslationType for more information.\nDataType\nNodeId\nThe data type of the value.\nValueRank\nValueRank\nThe value rank.\nIf not specified, the default value is -1 (Scalar).\nArrayDimensions\nArrayDimensions\nThe number of dimensions in an array value.\nAccessLevel\nAccessLevel\nThe access level.\nThis value is a UInt32 that includes all of the bits exposed by the AccessLevelEx. Servers which do not support the additional bits in AccessLevelEx should ignore them.\nUserAccessLevel"
    },
    {
      "Id": "dee349f5-f5e7-4ff5-9da8-8079d9219722",
      "Header": "Document: Part 6 - Mappings\nSection: F.8 UAVariable\n---\n",
      "Content": "UserAccessLevel\nAccessLevel\nNot used. Kept in schema for backward compatibility.\nMinimumSamplingInterval\nDuration\nThe minimum sampling interval.\nHistorizing\nBoolean\nWhether history is being archived."
    },
    {
      "Id": "a33add7b-d94c-43a2-9001-2a7f956d3fba",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.9 UAMethod"
    },
    {
      "Id": "4318ff91-74f6-4ac9-a60b-0a3bab548089",
      "Header": "Document: Part 6 - Mappings\nSection: F.9 UAMethod\n---\n",
      "Content": "A UAMethod is a subtype of the UAInstance defined in[F.7](/\u00A7_Ref472619842). It represents a Method Node. The fields in the UAMethod type are defined in[Table F.9](/\u00A7_Ref397326155).\nTable F. 9- UAMethod\nElement\nType\nDescription\nAll of the fields from the UAInstance type described in[F.7](/\u00A7_Ref472619859).\nMethodDeclarationId\nNodeId\nMay be specified for Method Nodes that are a target of a HasComponent reference from a single Object Node. It is the NodeId of the UAMethod with the same BrowseName contained in the TypeDefinition associated with the Object Node.\nIf the TypeDefinition overrides a Method inherited from a base ObjectType then this attribute shall reference the Method Node in the subtype.\nExecutable\nBoolean\nIndicates that the Method is executable.\nThe default value is TRUE.\nUserExecutable\nBoolean\nNot used. Kept in schema for backward compatibility.\nArgumentDescription\nUAMethodArgument []\nA list of Descriptions for the Method Node Arguments.\nEach entry has a Name which uniquely identifies the Argument that the Descriptions apply to. There shall only be one entry per Name.\nEach entry also has a list of Descriptions for the Argument in different locales. There shall be only one entry per locale per Argument."
    },
    {
      "Id": "d2f27438-126f-4fb6-b5c4-41f6ec77e832",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.10 TranslationType"
    },
    {
      "Id": "0c38bdbe-50f5-4651-9ca4-9d1717dda3c5",
      "Header": "Document: Part 6 - Mappings\nSection: F.10 TranslationType\n---\n",
      "Content": "A TranslationType contains additional translations for LocalizedTexts used in the Value of a Variable. The fields in the TranslationType are defined in[Table F.10](/\u00A7_Ref397326179). If multiple Arguments existed there would be a Translation element for each Argument.\nThe type can have two forms depending on whether the Value is a LocalizedText or a Structure containing LocalizedTexts. If it is a LocalizedText is contains a simple list of translations. If it is a Structure, it contains a list of fields which each contain a list of translations. Each field is identified by a Name which is unique within the structure. The mapping between the Name and the Structure requires an understanding of the Structure encoding. If the Structure field is encoded as a LocalizedText with UA XML, then the name is the unqualified path to the XML element where names in the path are separated by \u0027/\u0027. For example, a structure with a nested structure containing a LocalizedText could have a path like \u0022Server/ApplicationName\u0022.\nThe following example illustrates how translations for the Description field in the Argument Structure are represented in XML:\n\u003CValue\u003E\n\u003CListOfExtensionObject xmlns=\u0022http://opcfoundation.org/UA/2008/02/Types.xsd\u0022\u003E\n\u003CExtensionObject\u003E\n\u003CTypeId\u003E\n\u003CIdentifier\u003Ei=297\u003C/Identifier\u003E\n\u003C/TypeId\u003E\n\u003CBody\u003E\n\u003CArgument\u003E\n\u003CName\u003EConfigData\u003C/Name\u003E\n\u003CDataType\u003E\n\u003CIdentifier\u003Ei=15\u003C/Identifier\u003E\n\u003C/DataType\u003E\n\u003CValueRank\u003E-1\u003C/ValueRank\u003E\n\u003CArrayDimensions /\u003E\n\u003CDescription\u003E\n\u003CText\u003E[English Translation for Description]\u003C/Text\u003E\n\u003C/Description\u003E\n\u003C/Argument\u003E\n\u003C/Body\u003E\n\u003C/ExtensionObject\u003E\n\u003C/ListOfExtensionObject\u003E\n\u003C/Value\u003E\n\u003CTranslation\u003E\n\u003CField Name=\u0022Description\u0022\u003E"
    },
    {
      "Id": "289cdc91-5acc-46a7-af29-3fc9c517ebf9",
      "Header": "Document: Part 6 - Mappings\nSection: F.10 TranslationType\n---\n",
      "Content": "\u003CText Locale=\u0022de-DE\u0022\u003E[German Translation for Description]\u003C/Text\u003E\n\u003CText Locale=\u0022fr-FR\u0022\u003E[French Translation for Description]\u003C/Text\u003E\n\u003C/Field\u003E\n\u003C/Translation\u003E\n\nIf multiple Arguments existed there would be a Translation element for each Argument.\nTable F. 10- TranslationType\nElement\nType\nDescription\nText\nLocalizedText []\nAn array of translations for the Value.\nIt only appears if the Value is a LocalizedText or an array of LocalizedText.\nField\nStructureTranslationType []\nAn array of structure fields which have translations.\nIt only appears if the Value is a Structure or an array of Structures.\nName\nString\nThe name of the field.\nThis uniquely identifies the field within the structure.\nThe exact mapping depends on the encoding of the structure.\nText\nLocalizedText []\nAn array of translations for the structure field."
    },
    {
      "Id": "d50e2b07-4a6f-4aec-801f-6c8f06225dfd",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.11 UADataType"
    },
    {
      "Id": "81865e5a-e11f-4c1c-8831-407124240047",
      "Header": "Document: Part 6 - Mappings\nSection: F.11 UADataType\n---\n",
      "Content": "A UADataType is a subtype of the UAType defined in[Table F.5](/\u00A7_Ref382473263). It defines a DataType Node. The fields in the UADataType type are defined in[Table F.11](/\u00A7_Ref397326192).\nTable F. 11- UADataType\nElement\nType\nDescription\nAll of the fields from the UANode type described in[F.3](/\u00A7_Ref311621445).\nDefinition\nDataTypeDefinition\nAn abstract definition of the data type that can be used by design tools to create code that can serialize the data type in XML and/or Binary forms. This is only used to define subtypes of the Structure, Enumeration or UInteger DataTypes. UInteger DataTypes only have this field if they represent an OptionSet.\nPurpose\nDataTypePurpose\nAn enumeration that indicates the purpose of the DataType.\nIt can be used by modelling tools and code generators to exclude DataTypes that are not needed.\n\nPossible values are:\nNormal - The DataType is used in the AddressSpace.\nServicesOnly - The DataType is only used as Service parameters.\nCodeGenerator - The DataType is only used by code generation tools.\nThis field is only specified for the OPC UA NodeSet. Other NodeSets shall omit this field and the value of \u0022Normal\u0022 is assumed."
    },
    {
      "Id": "4a179622-e439-4f14-b9c9-a2599c6fd479",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.12 DataTypeDefinition"
    },
    {
      "Id": "d5ef7bd5-902a-4b08-ba37-052e42cb3abb",
      "Header": "Document: Part 6 - Mappings\nSection: F.12 DataTypeDefinition\n---\n",
      "Content": "A DataTypeDefinition defines a representation of a UADataType that can be used by design tools to automatically create serialization code. The fields in the DataTypeDefinition type are defined in[Table F.12](/\u00A7_Ref397326205).\nThis field may not be present for DataTypes that have no fields. Code generators may choose to create a class with no fields if the programming environment supports the concept.\nTable F. 12- DataTypeDefinition\nElement\nType\nDescription\nName\nQualifiedName\nA unique name for the data type.\nThis name should be the same as the BrowseName for the containing DataType.\nSymbolicName\nString\nA symbolic name for the data type that can be used as a class/structure name in autogenerated code. It should only be specified if the Name cannot be used for this purpose.\nOnly letters, digits or the underscore (\u0027_\u0027) are permitted and the first character shall be a letter.\nThis field is only specified for nested DataTypeDefinitions.\nThe SymbolicName of the DataType Node is used otherwise.\nBaseType\nQualifiedName\nNot used. Kept in schema for backward compatibility.\nIsUnion\nBoolean\nThis flag indicates if the data type represents a union.\nOnly one of the Fields defined for the data type is encoded into a value.\nThis field is optional. The default value is false.\nIf this value is true, the first field is the switch value.\nIsOptionSet\nBoolean\nThis flag indicates that the data type defines the OptionSetValues Property.\nThis field is optional. The default value is false.\nFields\nDataTypeField []\nThe list of fields that make up the data type.\nThis definition assumes the structure has a sequential layout.\nFor enumerations, the fields are simply a list of values.\nThis list does not include fields inherited from a base DataType."
    },
    {
      "Id": "e35906f1-250d-442e-9b55-20a834ed1ed1",
      "Header": "Document: Part 6 - Mappings\nSection: F.12 DataTypeDefinition\n---\n",
      "Content": "DataType.\nWhen Applications ingest a UANodeSet they need to follow the HasSubtype References between DataType Nodes to collect all of the fields needed to fill in the DataTypeDefinition Attribute.\n\nThe DataTypeDefinition Attribute maybe populated from the DataTypeDefinition belonging to a UADataType. If the UADataType is a subtype of Structure the mapping to the StructureType Enumeration is specified in[Table F.13](/\u00A7_Ref123078572).\nTable F. 13- StructureType Enumeration Mapping\nValue\nIsUnion\nField.IsOptional\nField.AllowSubTypes\nStructure\nFalse\nAll False\nAll False\nStructureWithOptionalFields\nFalse\nOne or More True\nAll False\nUnion\nTrue\nAll False\nAll False\nStructureWithSubtypedValues\nFalse\nAll False\nOne or More True\nUnionWithSubtypedValues\nTrue\nAll False\nOne or More True\n\nAny combination of flags that does have a mapping is invalid and an error should be raised."
    },
    {
      "Id": "4aef93e1-b2cb-44d7-bafd-8a5c82252d07",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.13 DataTypeField"
    },
    {
      "Id": "aff7841a-98e9-4015-ab9a-e26958448e67",
      "Header": "Document: Part 6 - Mappings\nSection: F.13 DataTypeField\n---\n",
      "Content": "A DataTypeField defines an abstract representation of a field within a UADataType that can be used by design tools to automatically create serialization code. The fields in the DataTypeField type are defined in[Table F.14](/\u00A7_Ref397326220).\nTable F. 14- DataTypeField\nElement\nType\nDescription\nName\nString\nA name for the field that is unique within the DataTypeDefinition.\nSymbolicName\nString\nA symbolic name for the field that can be used in autogenerated code.\nIt should only be specified if the Name cannot be used for this purpose.\nOnly letters, digits or the underscore (\u0027_\u0027) are permitted.\nDisplayName\nLocalizedText []\nA display name for the field in multiple locales.\nDataType\nNodeId\nThe NodeId of the DataType for the field.\nThis NodeId can refer to another Node with its own DataTypeDefinition.\nThis field is not specified for Enumeration or OptionSet DataTypes.\nValueRank\nInt32\nThe value rank for the field.\nIt shall be Scalar(-1) or a fixed rank Array(\u003E=1).\nThis field is not specified for Enumeration or OptionSet DataTypes.\nArrayDimensions\nString\nThe maximum length of an array.\nThis field is a comma separated list of unsigned integer values. The list has a number of elements equal to the ValueRank.\nThe value is 0 if the maximum is not known for a dimension.\nThis field is not specified if the ValueRank \u003C= 0.\nThis field is not specified for Enumeration or OptionSet DataTypes.\nMaxStringLength\nUInt32\nThe maximum length of a String or ByteString value.\nIf not known the value is 0.\nThe value is 0 if the DataType is not String or ByteString.\nIf the ValueRank"
    },
    {
      "Id": "406bf0b5-ddff-4076-a002-b5a58dd6f655",
      "Header": "Document: Part 6 - Mappings\nSection: F.13 DataTypeField\n---\n",
      "Content": "If the ValueRank \u003E 0 the maximum applies to each element in the array.\nThis field is not specified for Enumeration or OptionSet DataTypes.\nDescription\nLocalizedText []\nA description for the field in multiple locales.\nValue\nInt32\nThe value associated with the field.\nThis field is only specified for Enumeration or OptionSet DataTypes.\nIsOptional\nBoolean\nThe field indicates if a data type field in a structure is optional.\nThe default value is false.\nThis field is not specified for Enumeration, Union or OptionSet DataTypes.\nAllowSubTypes\nBoolean\nFor backward compatibility, this field shall be omitted if the DataType is BaseDataType, Structure, Number, Integer or UInteger or if the DataType is a subtype of simple built-in types such as a String or Int32.\nThis field shall be TRUE for all abstract DataTypes except for BaseDataType, Structure, Number, Integer or UInteger or if the DataType is a subtype of simple built-in types such as a String or Int32.\nWhen TRUE, the field\u0027s value is allowed to contain subtypes of the DataType.\nIf TRUE, all subtypes of Structure are encoded as an ExtensionObject(see[5.1.6](/\u00A7_Ref293469420)) and all DataTypes that are not subtypes of Structure are encoded as a Variant(see[5.1.9](/\u00A7_Ref64146623)).\nThe default value is FALSE.\nThis field is omitted for Enumeration or OptionSet DataTypes."
    },
    {
      "Id": "dc359ecf-1a98-437f-9375-3d02e42a5f42",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.14 Variant"
    },
    {
      "Id": "95ed3015-d2d1-4d52-9202-a7b9c1945c8f",
      "Header": "Document: Part 6 - Mappings\nSection: F.14 Variant\n---\n",
      "Content": "The Variant type specifies the value for a Variable or VariableType Node. This type is the same as the type defined in[5.3.1.17](/\u00A7_Ref294074990). As a result, the functions used to serialize Variants during Service calls can be used to serialize Variant in this file syntax.\nVariants can contain NodeIds, ExpandedNodeIds and QualifiedNames which must be modified so the NamespaceIndexes and ServerIndexes reference the NamespaceUri and ServerUri tables in the UANodeSet.\nVariants can also contain ExtensionObjects which contain an EncodingId and a Structure with fields which with any DataType including NodeIds, ExpandedNodeIds or QualifiedNames. The NamespaceIndexes and ServerIndexes in these fields shall also reference the tables in the UANodeSet."
    },
    {
      "Id": "bf9d5019-5400-4fef-9ac2-6a8828f68732",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.15 Example"
    },
    {
      "Id": "db3d1a06-8654-441b-b130-c23940a9a721",
      "Header": "Document: Part 6 - Mappings\nSection: F.15 Example\n---\n",
      "Content": "An example of the UANodeSet can be found below.\nThis example defines the Nodes for an InformationModel with the URI of \u0022http://sample.com/Instances\u0022. This example references Nodes defined in the base OPC UA InformationModel and an InformationModel with the URI \u0022http://sample.com/Types\u0022.\nThe XML namespaces declared at the top include the URIs for the Namespaces referenced in the document because the document includes Complex Data. Documents without Complex Data would not have these declarations.\n\n\u003CUANodeSet\nxmlns:s1=\u0022http://sample.com/Instances\u0022\nxmlns:s0=\u0022http://sample.com/Types\u0022\nxmlns:uax=\u0022http://opcfoundation.org/UA/2008/02/Types.xsd\u0022 xmlns=\u0022http://opcfoundation.org/UA/2011/03/UANodeSet.xsd\u0022\u003E\n\nThe NamespaceUris table includes all Namespaces referenced in the document except for the base OPC UA InformationModel. A NamespaceIndex of 1 refers to the URI \u0022http://sample.com/Instances\u0022.\n\n\u003CNamespaceUris\u003E\n\u003CUri\u003Ehttp://sample.com/Instances\u003C/Uri\u003E\n\u003CUri\u003Ehttp://sample.com/Types\u003C/Uri\u003E\n\u003C/NamespaceUris\u003E\n\nThe Aliases table is provided to enhance readability. There are no rules for what is included. A useful guideline would include standard ReferenceTypes and DataTypes if they are referenced in the document. An Alias may be used for any NodeId value in the document except for the value of the NodeId attribute and NodeIds that appear in Values of Variables or VariableTypes.\n\n\u003CAliases\u003E\n\u003CAlias Alias=\u0022HasComponent\u0022\u003Ei=47\u003C/Alias\u003E\n\u003CAlias Alias=\u0022HasProperty\u0022\u003Ei=46\u003C/Alias\u003E\n\u003CAlias Alias=\u0022HasSubtype\u0022\u003Ei=45\u003C/Alias\u003E"
    },
    {
      "Id": "14517f2d-6e7c-426a-9076-5c5d0560c145",
      "Header": "Document: Part 6 - Mappings\nSection: F.15 Example\n---\n",
      "Content": "\u003CAlias Alias=\u0022HasTypeDefinition\u0022\u003Ei=40\u003C/Alias\u003E\n\u003C/Aliases\u003E\n\nThe BicycleType is a DataType Node that inherits from a DataType defined in another InformationModel(ns=2;i=314). It is assumed that any application importing this file will already know about the referenced InformationModel. A Server could map the references onto another OPC UA Server by adding a ServerIndex to TargetNode NodeIds. The structure of the DataType is defined by the Definition element. This information can be used by code generators to automatically create serializers for the DataType.\n\n\u003CUADataType NodeId=\u0022ns=1;i=365\u0022 BrowseName=\u00221:BicycleType\u0022\u003E\n\u003CDisplayName\u003EBicycleType\u003C/DisplayName\u003E\n\u003CReferences\u003E\n\u003CReference ReferenceType=\u0022HasSubtype\u0022 IsForward=\u0022false\u0022\u003Ens=2;i=314\u003C/Reference\u003E\n\u003C/References\u003E\n\u003CDefinition Name=\u0022BicycleType\u0022\u003E\n\u003CField Name=\u0022NoOfGears\u0022 DataType=\u0022UInt32\u0022 /\u003E\n\u003CField Name=\u0022ManufacturerName\u0022 DataType=\u0022String\u0022 /\u003E\n\u003C/Definition\u003E\n\u003C/UADataType\u003E\n\nThis Node is an instance of an Object TypeDefinition Node defined in another InformationModel(ns=2;i=341). It has a single Property which is declared later in the document.\n\u003CUAObject NodeId=\u0022ns=1;i=375\u0022 BrowseName=\u00221:DriverOfTheMonth\u0022 ParentNodeId=\u0022ns=1;i=281\u0022\u003E\n\u003CDisplayName\u003EDriverOfTheMonth\u003C/DisplayName\u003E\n\u003CReferences\u003E\n\u003CReference ReferenceType=\u0022HasProperty\u0022\u003Ens=1;i=376\u003C/Reference\u003E\n\u003CReference ReferenceType=\u0022HasTypeDefinition\u0022\u003Ens=2;i=341\u003C/Reference\u003E\n\u003CReference ReferenceType=\u0022HasComponent\u0022 IsForward=\u0022false\u0022\u003Ens=1;i=281\u003C/Reference\u003E\n\u003C/References\u003E\n\u003C/UAObject\u003E\n\nThis Node"
    },
    {
      "Id": "5243bc91-1165-4291-80b6-68f5395eb113",
      "Header": "Document: Part 6 - Mappings\nSection: F.15 Example\n---\n",
      "Content": "This Node is an instance of a Variable TypeDefinition Node defined in base OPC UA InformationModel(i=68). The DataType is the base type for the BicycleType DataType. The AccessLevels declare the Variable as Readable and Writable. The ParentNodeId indicates that this Node is tightly coupled with the Parent (DriverOfTheMonth) and will be deleted if the Parent is deleted.\n\u003CUAVariable NodeId=\u0022ns=1;i=376\u0022 BrowseName=\u00222:PrimaryVehicle\u0022\nParentNodeId=\u0022ns=1;i=375\u0022 DataType=\u0022ns=2;i=314\u0022 AccessLevel=\u00223\u0022\u003E\n\u003CDisplayName\u003EPrimaryVehicle\u003C/DisplayName\u003E\n\u003CReferences\u003E\n\u003CReference ReferenceType=\u0022HasTypeDefinition\u0022\u003Ei=68\u003C/Reference\u003E\n\u003CReference ReferenceType=\u0022HasProperty\u0022 IsForward=\u0022false\u0022\u003Ens=1;i=375\u003C/Reference\u003E\n\u003C/References\u003E\nThis Value is an instance of a BicycleType DataType. It is wrapped in an ExtensionObject which declares that the value is serialized using the Default XML DataTypeEncoding for the DataType. The Value could be serialized using the Default Binary DataTypeEncoding but that would result in a document that cannot be edited by hand. No matter which DataTypeEncoding is used, the NamespaceIndex used in the ManufactureName field refers to the NamespaceUris table in this document. The application is responsible for changing whatever value it needs to be when the document is loaded by an application.\n\n\u003CValue\u003E\n\u003CExtensionObject xmlns=\u0022http://opcfoundation.org/UA/2008/02/Types.xsd\u0022\u003E\n\u003CTypeId\u003E\n\u003CIdentifier\u003Ens=1;i=366\u003C/Identifier\u003E\n\u003C/TypeId\u003E\n\u003CBody\u003E\n\u003Cs1:BicycleType\u003E\n\u003Cs0:Make\u003ETrek\u003C/s0:Make\u003E\n\u003Cs0:Model\u003ECompact\u003C/s0:Model\u003E"
    },
    {
      "Id": "8a3cf001-94b8-4505-bd21-4073410abf22",
      "Header": "Document: Part 6 - Mappings\nSection: F.15 Example\n---\n",
      "Content": "\u003Cs1:NoOfGears\u003E10\u003C/s1:NoOfGears\u003E\n\u003Cs1:ManufactureName\u003E\n\u003Cuax:NamespaceIndex\u003E1\u003C/uax:NamespaceIndex\u003E\n\u003Cuax:Name\u003EHello\u003C/uax:Name\u003E\n\u003C/s1:ManufactureName\u003E\n\u003C/s1:BicycleType\u003E\n\u003C/Body\u003E\n\u003C/ExtensionObject\u003E\n\u003C/Value\u003E\n\u003C/UAVariable\u003E\n\nThese are the DataTypeEncoding Nodes for the BicycleType DataType.\n\u003CUAObject NodeId=\u0022ns=1;i=366\u0022 BrowseName=\u0022Default XML\u0022\u003E\n\u003CDisplayName\u003EDefault XML\u003C/DisplayName\u003E\n\u003CReferences\u003E\n\u003CReference ReferenceType=\u0022HasEncoding\u0022 IsForward=\u0022false\u0022\u003Ens=1;i=365\u003C/Reference\u003E\n\u003CReference ReferenceType=\u0022HasTypeDefinition\u0022\u003Ei=76\u003C/Reference\u003E\n\u003C/References\u003E\n\u003C/UAObject\u003E\n\u003CUAObject NodeId=\u0022ns=1;i=370\u0022 BrowseName=\u0022Default Binary\u0022\u003E\n\u003CDisplayName\u003EDefault Binary\u003C/DisplayName\u003E\n\u003CReferences\u003E\n\u003CReference ReferenceType=\u0022HasEncoding\u0022 IsForward=\u0022false\u0022\u003Ens=1;i=365\u003C/Reference\u003E\n\u003CReference ReferenceType=\u0022HasTypeDefinition\u0022\u003Ei=76\u003C/Reference\u003E\n\u003C/References\u003E\n\u003C/UAObject\u003E"
    },
    {
      "Id": "998b3ac3-ed7f-4f7a-8c42-fb809ef58439",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.16 UANodeSetChanges"
    },
    {
      "Id": "10ec52c9-493d-42f0-b28b-03c6069975a8",
      "Header": "Document: Part 6 - Mappings\nSection: F.16 UANodeSetChanges\n---\n",
      "Content": "The UANodeSetChanges is the root of a document that contains a set of changes to an AddressSpace. It is expected that a single file will contain either a UANodeSet or a UANodeSetChanges element at the root. It provides a list of Nodes/ References to add and/or a list Nodes/ References to delete. The UANodeSetChangesStatus structure defined in[F.22](/\u00A7_Ref368713677) is produced when a UANodeSetChanges document is applied to an AddressSpace.\nThe elements of the type are defined in[Table F.15](/\u00A7_Ref397326259).\nTable F. 15- UANodeSetChanges\nElement\nType\nDescription\nNamespaceUris\nUriTable\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nServerUris\nUriTable\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nModels\nModelTableEntry []\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nAliases\nAliasTable\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nExtensions\nxs:any []\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nLastModified\nDateTime\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nNodesToAdd\nNodesToAdd\nA list of new Nodes to add to the AddressSpace.\nReferencesToAdd\nReferencesToChange\nA list of new References to add to the AddressSpace.\nNodesToDelete\nNodesToDelete\nA list of Nodes to delete from the AddressSpace.\nReferencesToDelete\nReferencesToChange"
    },
    {
      "Id": "cbe01175-6ff6-4d9e-84f2-2793b656e065",
      "Header": "Document: Part 6 - Mappings\nSection: F.16 UANodeSetChanges\n---\n",
      "Content": "ReferencesToChange\nA list of References to delete from the AddressSpace.\n\nThe Models element specifies the version of one or more Models which the UANodeSetChanges file will create when it is applied to an existing Address Space. The UANodeSetChanges cannot be applied if the current version of the Model in the Address Space is higher. The RequiredModels sub-element (see[Table F.1](/\u00A7_Ref397325999)) specifies the versions Models which must already exist before the UANodeSetChanges file can be applied. When checking dependencies, the version of the Model in the existing Address Space must exactly match the required version.\nIf a UANodeSetChanges file modifies types and there are existing instances of the types in the AddressSpace, then the Server shall automatically modify the instances to conform to the new type or generate an error.\nA UANodeSetChanges file is processed as a single operation. This allows mandatory Nodes or References to be replaced by specifying a Node/ Reference to delete and a Node/ Reference to add."
    },
    {
      "Id": "ccf1f1f8-661c-4fd6-a956-66c95002e06b",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.17 NodesToAdd"
    },
    {
      "Id": "c0a2ab7d-210b-441c-9b49-f2118422c4ea",
      "Header": "Document: Part 6 - Mappings\nSection: F.17 NodesToAdd\n---\n",
      "Content": "The NodesToAdd type specifies a list of Nodes to add to an AddressSpace. The structure of these Nodes is defined by the UANodeSet type in[Table F.1](/\u00A7_Ref397325999).\nThe elements of the type are defined in[Table F.16](/\u00A7_Ref397326301).\nTable F. 16- NodesToAdd\nElement\nType\nDescription\n\u003Cchoice\u003E\nUAObject\nUAVariable\nUAMethod\nUAView\nUAObjectType\nUAVariableType\nUADataType\nUAReferenceType\nThe Nodes to add to the AddressSpace.\nWhen adding Nodes, References can be specified as part of the Node definition or as a separate ReferencesToAdd.\nNote that References to Nodes that could exist are always allowed. In other words, a Node is never rejected simply because it has a reference to an unknown Node.\nReverse References are added automatically when deemed practical by the processor."
    },
    {
      "Id": "e97aef85-5224-4618-a72e-ae66c2d39eba",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.18 ReferencesToChange"
    },
    {
      "Id": "f9d29089-e51c-4aaf-94ec-92e9b40ffb72",
      "Header": "Document: Part 6 - Mappings\nSection: F.18 ReferencesToChange\n---\n",
      "Content": "The ReferencesToChange type specifies a list of References to add to or remove from an AddressSpace.\nThe elements of the type are defined in[Table F.17](/\u00A7_Ref397326324).\nTable F. 17- ReferencesToChange\nElement\nType\nDescription\nReference\nReferenceToChange\nA Reference to add to the AddressSpace."
    },
    {
      "Id": "87e2fcc6-c6c3-4155-8383-82d0ec2883b6",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.19 ReferenceToChange"
    },
    {
      "Id": "4f1c6aaa-a2f6-4d9a-b53a-0540f03bd905",
      "Header": "Document: Part 6 - Mappings\nSection: F.19 ReferenceToChange\n---\n",
      "Content": "The ReferenceToChange type specifies a single Reference to add to or remove from an AddressSpace.\nThe elements of the type are defined in[Table F.18](/\u00A7_Ref397326334).\nTable F. 18- ReferencesToChange\nElement\nType\nDescription\nSource\nNodeId\nThe identifier for the source Node of the Reference.\nReferenceType\nNodeId\nThe identifier for the type of the Reference.\nIsForward\nBoolean\nTRUE if the Reference is a forward reference.\nTarget\nNodeId\nThe identifier for the target Node of the Reference.\nReferences to Nodes that could exist are always allowed. In other words, a Reference is never rejected simply because the target is unknown Node.\nThe source of the Reference must exist in the AddressSpace or in UANodeSetChanges document being processed.\nReverse References are added when deemed practical by the processor."
    },
    {
      "Id": "c7258067-52f1-4503-b5f4-1c01f7f19c00",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.20 NodesToDelete"
    },
    {
      "Id": "726e5633-f4a4-4316-af9b-4dbe7fa0827e",
      "Header": "Document: Part 6 - Mappings\nSection: F.20 NodesToDelete\n---\n",
      "Content": "The NodesToDelete type specifies a list of Nodes to remove from an AddressSpace.\nThe elements of the type are defined in[Table F.19](/\u00A7_Ref397326344).\nTable F. 19- NodesToDelete\nElement\nType\nDescription\nNode\nNodeToDelete\nA Node to delete from the AddressSpace."
    },
    {
      "Id": "da542821-4737-4a1a-8471-c57a4f3d230a",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.21 NodeToDelete"
    },
    {
      "Id": "94c96fec-3f56-4ef4-90c9-ff932fac86ea",
      "Header": "Document: Part 6 - Mappings\nSection: F.21 NodeToDelete\n---\n",
      "Content": "The NodeToDelete type specifies a Node to remove from an AddressSpace.\nThe elements of the type are defined in[Table F.20](/\u00A7_Ref397326386).\nTable F. 20- ReferencesToChange\nElement\nType\nDescription\nNode\nNodeId\nThe identifier for the Node to delete.\nDeleteReverseReferences\nBoolean\nIf TRUE, then References to the Node are deleted as well."
    },
    {
      "Id": "49369c3f-05fc-4f34-a6a3-4d58ba7a45cc",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.22 UANodeSetChangesStatus"
    },
    {
      "Id": "393878a3-a9fb-472f-b543-d10c98bbd4ad",
      "Header": "Document: Part 6 - Mappings\nSection: F.22 UANodeSetChangesStatus\n---\n",
      "Content": "The UANodeSetChangesStatus is the root of a document that is produced when a UANodeSetChanges document is processed.\nThe elements of the type are defined in[Table F.21](/\u00A7_Ref397326399).\nTable F. 21- UANodeSetChangesStatus\nElement\nType\nDescription\nNamespaceUris\nUriTable\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nServerUris\nUriTable\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nAliases\nAliasTable\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nExtensions\nxs:any []\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nVersion\nString\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nLastModified\nDateTime\nSame as described in[Table F.1](/\u00A7_Ref397325999).\nTransactionId\nString\nA globally unique identifier from the original UANodeSetChanges document.\nNodesToAdd\nNodeSetStatusList\nA list of results for the NodesToAdd specified in the original document.\nThe list is empty if all elements were processed successfully.\nReferencesToAdd\nNodeSetStatusList\nA list of results for the ReferencesToAdd specified in the original document.\nThe list is empty if all elements were processed successfully.\nNodesToDelete\nNodeSetStatusList\nA list of results for the NodesToDelete specified in the original document.\nThe list is empty if all elements were processed successfully.\nReferencesToDelete\nNodeSetStatusList\nA list of results for the ReferencesToDelete specified in the original document."
    },
    {
      "Id": "acf66105-42e4-429b-ac55-4328dc9771b8",
      "Header": "Document: Part 6 - Mappings\nSection: F.22 UANodeSetChangesStatus\n---\n",
      "Content": "The list is empty if all elements were processed successfully."
    },
    {
      "Id": "575459b8-e6f2-4f0d-8f36-e585bc0f833e",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.23 NodeSetStatusList"
    },
    {
      "Id": "73d32193-e11c-496a-a8f3-c29ade4def4e",
      "Header": "Document: Part 6 - Mappings\nSection: F.23 NodeSetStatusList\n---\n",
      "Content": "The NodeSetStatusList type specifies a list of results produced when applying a UANodeSetChanges document to an AddressSpace.\nIf no errors occurred this list is empty.\nIf one or more errors occur, then this list contains one element for each operation specified in the original document.\nThe elements of the type are defined in[Table F.22](/\u00A7_Ref397326506).\nTable F. 22- NodeSetStatusList\nElement\nType\nDescription\nResult\nNodeSetStatus\nThe result of a single operation."
    },
    {
      "Id": "9cfd793f-5918-48ce-874c-07bf6aa2bc7c",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "F.24 NodeSetStatus"
    },
    {
      "Id": "78aa17d0-9e18-4f25-b723-fef3e428de76",
      "Header": "Document: Part 6 - Mappings\nSection: F.24 NodeSetStatus\n---\n",
      "Content": "The NodeSetStatus type specifies a single result produced when applying an operation specified in a UANodeSetChanges document to an AddressSpace.\nThe elements of the type are defined in[Table F.23](/\u00A7_Ref397326515).\nTable F. 23- NodeSetStatus\nElement\nType\nDescription\nCode\nStatusCode\nThe result of the operation.\nThe possible StatusCodes are defined in[OPC 10000-4](/\u00A7UAPart4).\nDetails\nString\nA string providing information that is not conveyed by the StatusCode.\nThis is not a human readable string for the StatusCode."
    },
    {
      "Id": "6fa44018-87aa-4023-8e10-a406acda7946",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0G(normative)Mapping to JSON Schema\nG.1 Overview"
    },
    {
      "Id": "50a3cd56-394a-4e09-9bb8-70f5172e0afd",
      "Header": "Document: Part 6 - Mappings\nSection: G.1 Overview\n---\n",
      "Content": "The UA JSON DataEncoding defined in[5.4](/\u00A7_Ref443435038) specifies how OPC UA DataTypes are serialized in JSON. This Annex specifies how to describe the DataEncoding using a machine-readable schema syntax. Unlike, XML there is no universally accepted JSON schema syntax. This Annex defines mappings to two of the most widely used:[JSON Schema](/\u00A7JsonSchema) and[OpenAPI](/\u00A7OpenAPI)."
    },
    {
      "Id": "887357e8-9dae-4fdb-8247-2ec3b7cbe70a",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "G.2 JSON Schema Mapping"
    },
    {
      "Id": "f773a99d-09b9-4785-8703-c87eb743ea4c",
      "Header": "Document: Part 6 - Mappings\nSection: G.2 JSON Schema Mapping\n---\n",
      "Content": "Clause[G.2](/\u00A7_Ref157900596) defines the[JSON Schema](/\u00A7JsonSchema) for all DataTypes defined in the OPC UA namespace.\nThe[JSON Schema](/\u00A7JsonSchema) for the CompactEncoding for all DataTypes released with this version of this document can be found here:\nhttps://reference.opcfoundation.org/files/opc.ua.services.jsonschema.compact.json?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/opc.ua.services.jsonschema.compact.json?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/opc.ua.services.jsonschema.compact.json?u=http://opcfoundation.org/UA/)\nThe[JSON Schema](/\u00A7JsonSchema) for the CompactEncoding for all DataTypes, excluding DataTypes used for only for Services, released with this version of this document can be found here:\nhttps://reference.opcfoundation.org/files/opc.ua.jsonschema.compact.json?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/opc.ua.jsonschema.compact.json?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/opc.ua.jsonschema.compact.json?u=http://opcfoundation.org/UA/\u0026v=1.05.04)\nThe[JSON Schema](/\u00A7JsonSchema) for the VerboseEncoding for all DataTypes, excluding DataTypes used for only for Services, released with this version of this document can be found here:"
    },
    {
      "Id": "065ae435-fe4b-4059-b5be-03c697150977",
      "Header": "Document: Part 6 - Mappings\nSection: G.2 JSON Schema Mapping\n---\n",
      "Content": "https://reference.opcfoundation.org/files/opc.ua.jsonschema.verbose.json?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/opc.ua.jsonschema.verbose.json?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/opc.ua.jsonschema.verbose.json?u=http://opcfoundation.org/UA/\u0026v=1.05.04)"
    },
    {
      "Id": "6bb87668-502b-4aef-bc47-5b69d70822a7",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "G.3 OpenAPI Mapping"
    },
    {
      "Id": "733ed148-6787-4055-b997-533b48c78e66",
      "Header": "Document: Part 6 - Mappings\nSection: G.3 OpenAPI Mapping\n---\n",
      "Content": "The[OpenAPI](/\u00A7OpenAPI) mapping defines path for each Service. The Request and Response messages have a structure generated from the Service definitions in[OPC 10000-4](/\u00A7UAPart4). The types for the payload of the HTTP message have the name \u0027Request\u0027 and \u0027Response\u0027 with the Service name as a prefix (i.e. ReadRequest and ReadResponse).\nThe OpenAPI schema is intended for use with HTTPS, however, the schema definitions are useful in other contexts, such as when using WebSockets or MQTT. When a Service message is sent via protocols other than HTTPS, the messages are wrapped in an envelope that defines the information sent in the HTTPS headers. The envelope is defined in[Table G.1](/\u00A7_Ref162246186).\nTable G. 1- OpenAPI Message Envelope\nName\nType\nDescription\nServiceId\nNodeId\nThe DataTypeId for the Body.\nLocaleIds []\nLocaleId\nList of locale ids to use when creating a Response to a Request.\nNot specified for Response messages.\nBody\n*\nThe Request or Response associated with the Service.\nThe ServiceId indicates the content of the Body.\n\nThe authorization header needs to be handled in a way specific to the transport (see[7.5](/\u00A7_Ref468620830) for WebSockets).\nThe[OpenAPI](/\u00A7OpenAPI) schema for the subset of Services that support Session-less invocation released with this version of this document can be found here:\nhttps://reference.opcfoundation.org/files/opc.ua.openapi.sessionless.json?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of this document can be found here:"
    },
    {
      "Id": "2db03386-45dc-4210-b77f-af617f7b42ad",
      "Header": "Document: Part 6 - Mappings\nSection: G.3 OpenAPI Mapping\n---\n",
      "Content": "[https://reference.opcfoundation.org/files/opc.ua.openapi.sessionless.json?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/opc.ua.openapi.sessionless.json?u=http://opcfoundation.org/UA/)\nThe[OpenAPI](/\u00A7OpenAPI) Schema for all Services released with this version of this document can be found here:\nhttps://reference.opcfoundation.org/files/opc.ua.openapi.allservices.json?u=http://opcfoundation.org/UA/\u0026v=1.05.06\nNOTE The latest file that is compatible with this version of this document can be found here:\n[https://reference.opcfoundation.org/files/opc.ua.openapi.allservices.json?u=http://opcfoundation.org/UA/](https://reference.opcfoundation.org/files/opc.ua.openapi.allservices.json?u=http://opcfoundation.org/UA/)"
    },
    {
      "Id": "11fa4b4e-e02d-41dd-a1d0-a337e24d6501",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "Annex\u00A0H(normative)Reversible and NonReversible Encoding (deprecated)"
    },
    {
      "Id": "12a0a8a0-35dd-4e64-b317-3af462605594",
      "Header": "Document: Part 6 - Mappings\nSection: Annex\u00A0H (normative)Reversible and NonReversible Encoding (deprecated)\n---\n",
      "Content": ""
    },
    {
      "Id": "d7a60309-694f-4b5a-bbf7-c53b0438b34c",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.1 Overview"
    },
    {
      "Id": "068cc686-7620-4408-a2b2-b7427ac451cf",
      "Header": "Document: Part 6 - Mappings\nSection: H.1 Overview\n---\n",
      "Content": "This version of the specification introduced significant optimizations to the JSON encoding, however, there are existing products that support the deprecated JSON encoding. This Annex summarizes the differences and explains how a product can be designed to seamlessly support the deprecated and current versions of the JSON encoding.\nThe ReversibleEncoding is largely the same as the CompactEncoding. The NonReversibleEncoding is largely the same as the VerboseEncoding. The differences are described in the rest of this Annex.\nAny product that supports the OpenAPI mappings defined in[G.3](/\u00A7_Ref173261294) only supports the CompactEncoding. The deprecated encodings published in earlier versions of this specification are only used by older products implementing MQTT mapping for PubSub defined in[OPC 10000-14](/\u00A7UAPart14).\nThe expectation is that all encoders used for Publishers support all four encodings and all decoders for Subscribers support the ReversibleEncoding, CompactEncoding and VerboseEncodings."
    },
    {
      "Id": "aca6bc9b-93ff-4cff-9755-15e421e87dae",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.2 NodeId"
    },
    {
      "Id": "fda0e215-7091-4466-a1af-d85c18a016e2",
      "Header": "Document: Part 6 - Mappings\nSection: H.2 NodeId\n---\n",
      "Content": "NodeId values shall be encoded as a JSON object with the fields defined in[Table H.1](/\u00A7_Ref173262743).\nDecoders that support the deprecated encodings use the JSON datatype to detect which encoding is used. A JSON string is the current encoding; a JSON object means it is the deprecated encoding.\nTable H. 1- JSON Object Definition for a NodeId\nName\nDescription\nIdType\nThe IdentifierType encoded as a JSON number.\nAllowed values are:\n0 - UInt32 identifier encoded as a JSON number.\n1 - A String identifier encoded as a JSON string.\n2 - A Guid identifier encoded as described in[5.4.2.7](/\u00A7_Ref472620952).\n3 - A ByteString identifier encoded as described in[5.4.2.8](/\u00A7_Ref432359677).\nThis field is omitted for UInt32 identifiers.\nId\nThe identifier.\nThe value of the IdType field specifies the encoding of this field.\nNamespace\nThis field is a JSON number with the NamespaceIndex. The field is omitted if the NamespaceIndex is 0.\nFor NonReversibleEncoding this field is the JSON string containing the NamespaceUri associated with the NamespaceIndex unless the NamespaceIndex is 0. If the NamespaceIndex is 0 the field is omitted."
    },
    {
      "Id": "e0d9bba5-9863-421d-89c2-f24e9b612cc7",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.3 ExpandedNodeId"
    },
    {
      "Id": "919e1b59-021f-4f95-8f3e-720d43ed24bd",
      "Header": "Document: Part 6 - Mappings\nSection: H.3 ExpandedNodeId\n---\n",
      "Content": "ExpandedNodeId values shall be encoded as a JSON object with the fields defined in[Table H.2](/\u00A7_Ref432213667).\nDecoders that support the deprecated encodings use the JSON datatype to detect which encoding is used. A JSON string is the current encoding; a JSON object means it is the deprecated encoding.\nTable H. 2- JSON Object Definition for an ExpandedNodeId\nName\nDescription\nIdType\nThe IdentifierType encoded as a JSON number.\nAllowed values are:\n0 - UInt32 Identifier encoded as a JSON number.\n1 - A String Identifier encoded as a JSON string.\n2 - A Guid Identifier encoded as described in[5.4.2.7](/\u00A7_Ref472620952).\n3 - A ByteString Identifier encoded as described in[5.4.2.8](/\u00A7_Ref432359677).\nThis field is omitted for UInt32 identifiers.\nId\nThe Identifier.\nThe value of the IdType field specifies the encoding of this field.\nNamespace\nFor ReversibleEncoding this field is a JSON string with the NamespaceUri if the NamespaceUri is specified. Otherwise, it is a JSON number with the NamespaceIndex. The field is omitted if the NamespaceIndex is 0.\nFor NonReversibleEncoding this field is the JSON string containing the NamespaceUri or the NamespaceUri associated with the NamespaceIndex unless the NamespaceIndex is 0 or 1. If the NamespaceIndex is 0 the field is omitted.\nServerUri\nFor ReversibleEncoding this field is a JSON number with the ServerIndex. The field is omitted if the ServerIndex is 0.\nFor NonReversibleEncoding this field is the JSON string containing the ServerUri associated with the ServerIndex unless the ServerIndex is 0. If the ServerIndex"
    },
    {
      "Id": "40fb0167-bd8b-4740-8069-1214ab562fc1",
      "Header": "Document: Part 6 - Mappings\nSection: H.3 ExpandedNodeId\n---\n",
      "Content": "ServerIndex is 0 the field is omitted."
    },
    {
      "Id": "89a21d2e-1e73-41b1-be03-5cbf1acf284d",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.4 StatusCode"
    },
    {
      "Id": "6cfd76ae-ac55-4535-9334-2376f1647812",
      "Header": "Document: Part 6 - Mappings\nSection: H.4 StatusCode\n---\n",
      "Content": "StatusCode values shall be encoded as a JSON number for the ReversibleEncoding. If the StatusCode is Good (0) it is only encoded if it is an element of a JSON array.\nFor the NonReversibleEncoding, StatusCode values shall be encoded as a JSON object with the fields defined in[Table H.3](/\u00A7_Ref183036304).\nTable H. 3- JSON Object Definition for a StatusCode\nName\nDescription\nCode\nThe numeric code encoded as a JSON number.\nThe Code is omitted if the numeric code is 0 (Good).\nSymbol\nThe string literal associated with the numeric code encoded as JSON string.\ne.g. 0x80AB0000 has the associated literal \u0022Bad_InvalidArgument\u0022.\nThe Symbol is omitted if the numeric code is 0 (Good).\nIf the string literal is not known to the encoder the field is omitted.\n\nFor the NonReversibleEncoding, a StatusCode of Good (0) it is only encoded if it is an element JSON array.\nThe CompactEncoding and VerboseEncoding use the same JSON object as the NonReversibleEncoding. The CompactEncoding always omits the Symbol."
    },
    {
      "Id": "0134d5f6-e1f6-4557-bf14-6a7fd07a6601",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.5 QualifiedName"
    },
    {
      "Id": "1c644afc-8740-4231-8366-53403b74af26",
      "Header": "Document: Part 6 - Mappings\nSection: H.5 QualifiedName\n---\n",
      "Content": "QualifiedName values shall be encoded as a JSON object with the fields shown in[Table H.4](/\u00A7_Ref432213824).\nDecoders that support the deprecated encodings use the JSON datatype to detect which encoding is used. A JSON string is the current encoding; a JSON object means it is the deprecated encoding.\nTable H. 4- JSON Object Definition for a QualifiedName\nName\nDescription\nName\nThe Name component of the QualifiedName.\nUri\nFor ReversibleEncoding this field is a JSON number with the NamespaceIndex. The field is omitted if the NamespaceIndex is 0.\nFor NonReversibleEncoding this field is the JSON string containing the NamespaceUri associated with the NamespaceIndex unless the NamespaceIndex is 0. If the NamespaceIndex is 0 the field is omitted."
    },
    {
      "Id": "318e293a-c552-4928-8057-a16f3588d808",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.6 LocalizedText"
    },
    {
      "Id": "ea6d5cfd-f56a-42ff-87d6-8f8964420c45",
      "Header": "Document: Part 6 - Mappings\nSection: H.6 LocalizedText\n---\n",
      "Content": "For the ReversibleEncoding, LocalizedText values shall be encoded as a JSON object with the fields shown in[Table H.5](/\u00A7_Ref176660725).\nTable H. 5- JSON Object Definition for a LocalizedText\nName\nDescription\nLocale\nThe Locale portion of LocalizedText values shall be encoded as a JSON string\nText\nThe Text portion of LocalizedText values shall be encoded as a JSON string.\n\nFor the NonReversibleEncoding, LocalizedText value shall be encoded as a JSON string containing the Text component.\nDecoders that support the NonReversibleEncoding use the JSON datatype to detect which encoding is used. A JSON object is the current encoding; a JSON string means it is the NonReversibleEncoding."
    },
    {
      "Id": "b9f4a4fd-2039-47dc-88e2-04fa7c1bca6a",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.7 ExtensionObject"
    },
    {
      "Id": "3e36f25e-1f1c-42c0-9bcf-789ac86983f1",
      "Header": "Document: Part 6 - Mappings\nSection: H.7 ExtensionObject\n---\n",
      "Content": "For the ReversibleEncoding, ExtensionObject values shall be encoded as a JSON object with the fields shown in[Table H.6](/\u00A7_Ref432359532).\nTable H. 6- JSON Object Definition for an ExtensionObject\nName\nDescription\nTypeId\nThe NodeId of a DataTypeEncoding Node or a DataType Node formatted using the rules in[H.2](/\u00A7_Ref176660998).\nEncoding\nThe format of the Body field encoded as a JSON number.\nThis value is 0 if the body is Structure encoded as a JSON object.\nThis value is 1 if the body is a ByteString value encoded as a JSON string.\nThis value is 2 if the body is a XmlElement value encoded as a JSON string.\nThis field is omitted if the value is 0.\nBody\nBody of the ExtensionObject. The type of this field is specified by the Encoding field.\nIf the Body is empty, the ExtensionObject is NULL and is omitted or encoded as a JSON null.\n\nFor the NonReversibleEncoding, ExtensionObject values shall be encoded as a JSON value containing only the value of the Body field. The TypeId and Encoding fields are dropped.\nDecoders that support the NonReversibleEncoding need to have out of band knowledge of the encoded Structure or treat the value as a generic JSON object."
    },
    {
      "Id": "00918c20-7381-45bf-ad28-a70154871ba8",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.8 Variant"
    },
    {
      "Id": "d9a4aac2-cfc9-4965-8cfe-3305680def4f",
      "Header": "Document: Part 6 - Mappings\nSection: H.8 Variant\n---\n",
      "Content": "For the ReversibleEncoding, Variant values shall be encoded as a JSON object with the fields shown in[Table H.7](/\u00A7_Ref183036235).\nTable H. 7- JSON Object Definition for a Variant\nName\nDescription\nType\nThe Built-in type for the value contained in the Body(see[Table 1](/\u00A7_Ref83387521)) encoded as JSON number.\nIf type is 0 (NULL) the Variant contains a NULL value and the containing JSON object shall be omitted or replaced by the JSON literal \u0027null\u0027 (when an element of a JSON array).\nBody\nIf the value is a scalar, it is encoded using the rules for type specified for the Type.\nIf the value is a one-dimensional array it is encoded as JSON array (see[H.9](/\u00A7_Ref173677219)).\nMulti-dimensional arrays are encoded as a one-dimensional JSON array which is reconstructed using the value of the Dimensions field (see[5.2.2.16](/\u00A7_Ref400568926)).\nDimensions\nThe dimensions of the array encoded as a JSON array of JSON numbers.\nThe Dimensions are omitted for scalar and one-dimensional array values.\nFor the NonReversibleEncoding, Variant values shall be encoded as a JSON value containing only the value of the Body field. The Type and Dimensions fields are dropped. Multi-dimensional arrays are encoded as a multi-dimensional JSON array as described in[H.9](/\u00A7_Ref173677219).\nDecoders that support the NonReversibleEncoding need to have out of band knowledge of value encoded in the Variant or treat the value as a generic JSON object."
    },
    {
      "Id": "56506a20-a179-41a3-a0cd-e1bdec93edb9",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.9 Arrays"
    },
    {
      "Id": "7812b1ac-6674-4e84-ac84-38e1cbd541d1",
      "Header": "Document: Part 6 - Mappings\nSection: H.9 Arrays\n---\n",
      "Content": "One dimensional Arrays shall be encoded as JSON arrays.\nIf an element is NULL, the element shall be encoded as the JSON literal \u0027null\u0027.\nOtherwise, the element is encoded according to the rules defined for the type.\nIn the deprecated encodings, Multi-dimensional Arrays are encoded as nested JSON arrays. The outer array is the first dimension and the innermost array is the last dimension. For example, the following matrix\n0 2 3\n1 3 4\nis encoded in JSON as\n[[0, 2, 3], [1, 3, 4]]\n\nThe current encoding defines a JSON object for multi-dimensional Arrays. Decoders that support the deprecated encodings use the JSON datatype to detect which encoding is used. A JSON object means it is the current encoding; a JSON array means it is the deprecated encoding.\nEncoders that support the deprecated encoding rely on a switch set by the application that controls which encoding is emitted."
    },
    {
      "Id": "f5662ec0-0fef-4277-b390-9e0d7ca4bc95",
      "Header": "Document: Part 6 - Mappings\n---\n",
      "Content": "H.10 Unions"
    },
    {
      "Id": "2d572eee-99bc-47dd-8cbe-1aaae14ffbdb",
      "Header": "Document: Part 6 - Mappings\nSection: H.10 Unions\n---\n",
      "Content": "Unions shall be encoded as JSON objects as shown in[Table H.8](/\u00A7_Ref183036204) for the ReversibleEncoding.\nNote that JSON objects are unordered sets of name-value pairs. The order specified by the DataTypeDefinition is not preserved when a Union is serialized in JSON. The SwitchField may not appear as the first field.\nTable H. 8- JSON Object Definition for a Union\nName\nDescription\nSwitchField\nThe identifier for the field in the Union which is encoded as a JSON number.\nThe valid values for this field follow the conventions defined in[5.2.8](/\u00A7_Ref35886801).\nIf the SwitchField value is its DefaultValue of 0, then the SwitchField and the Value field are not present.\nValue\nThe value of the field encoded using the rules that apply to the data type.\nFor the NonReversibleEncoding, Union values are encoded using the rule for the current value. If the SwitchField is 0 the Union is encoded as a JSON null value.\nFor example, instances of the union:\nstruct Union1\n{\nByte Selector;\n\n{\nInt32 A;\nDouble B;\nChar* C;\n}\nValue;\n};\n\nwould be represented in the ReversibleEncoding as:\n{ \u0022SwitchField\u0022:2, \u0022Value\u0022:3.1415 }\n\nIn the NonReversibleEncoding, it is represented as:\n3.1415\n\nThe CompactEncoding is the same as the ReversibleEncoding. The VerboseEncoding always has a JSON object with a name and value for the active field, however, the NonReversibleEncoding only encodes the value.\n___________"
    }
  ]
}